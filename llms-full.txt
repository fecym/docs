---
url: /docs/@pages/tagsPage.md
---


---

---
url: /docs/01.前端/04. 浏览器/jwt.md
---

还有几分钟就要跨年了，2019 即将结束，跨年夜独自一人闲来无趣，整理一下 `cookie、token` 和 `jwt` 的，记得在学校的时候我就很奇怪 `cookie` 是什么，当时老师只对我们说他就是用来存储数据的，只能存储 `4kb`，超过 `4kb` 之后就会开始删除之前的 `cookie` 值，不同浏览器删除的行为是不一样的。然后就没了。直到后来参加工作了，刚入公司没多久一次接触到了 `cookie` 让我一脸懵逼（当时带我的大佬有事回家了），项目出了 bug 因为 `cookie` 传递的不对，后台解析不了，然后我折腾了一晚上（回想当初小白的时候是真的有趣）。

今天来记录下工作这么久我对 cookie、session 和 jwt 的理解。

## Cookie

http 是无状态协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务器呢无法确认当前访问者的身份信息，也不能分辨上一次请求与这一次请求是不是同一个人。

所以服务器与浏览器为了进行会话跟踪（知道谁在访问我），就需要去维护一个状态，这个状态用于告知服务器前后两个请求是不是同一个浏览器。而这个状态需要通过 `cookie` 或者 `session` 来实现的

cookie 保存在客户端：`cookie` 是服务器发送到浏览器并保存在本地的一块数据，他会在浏览器下次请求同一服务器的时候被携带到服务器上。

cookie 是不可跨域的：每个 `cookie` 都会绑定单一的域名，无法在其他域名下获取，一级二级域名之间可以共享，设置相同的 `domain` 即可

当我们第一次请求服务器的时候（服务器已设置 cookie），我们会看到响应头中有 `Set-Cookie` 字段。

第二请求的时候，我们会发现，请求头中携带了 `Cookie` 字段，第一次请求的时候是没有 `Cookie` 字段的。

### cookie 的重要属性

在上图中看到 `Set-Cookie` 字段是一个字符串，是一对对 `name=value; name=value; name=value; ...` 这样的组合，那么他们是什么意思呢？

| 属性         | 说明                                                                                                                                      |
|------------|-----------------------------------------------------------------------------------------------------------------------------------------|
| name=value | 键值对，设置 `Cookie` 的名称及相对应的值，都必须是字符串类型  如果值为 `Unicode` 字符，需要为字符编码。 如果值为二进制数据，则需要使用 `base64` 编码。                                    |
| domain     | 指定 `cookie` 所属域名，默认是当前域名                                                                                                                |
| path       | 指定 cookie 在哪个路径（路由）下生效，默认是 '/'。 如果设置为 /cym，则只有 /cym 下的路由可以访问到该 `cookie`，如：http://localhost:3000/cym/abc                             |
| maxAge     | `cookie` 的失效时间，单位毫秒。如果为正数，则该 `cookie` 在 `maxAge` 秒后实效。如果是负数，该 `cookie` 为临时 `cookie`，关闭浏览器即失效。如果为 0，表示删除该 `cookie`。默认为 -1。比 `expires` 好用 |
| expires    | 过期时间，在设置的某个时间点后该 `cookie` 就会失效。一般浏览器的 `cookie` 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 `cookie` 也就会被删除                                               |
| secure     | 该 `cookie` 是否仅被使用在安全传输协议，默认为 `false`；当 `secure` 为 `true` 时，`cookie` 在 `http` 中是无效的，必须在 `https` 请求下才有效                                   |
| httpOnly   | 该 `cookie` 是否可以被 `js` 脚本读取，如果设置为 `true` 则 `js` 将不能获取到 `cookie`，在一定程度上可以防止 `XSS` 攻击，不是绝对的安全                                              |

### 代码实现

下面是使用 express 设置一条 cookie ，来浏览器端做访问

```js
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.cookie('test', 'cookie', {
    maxAge: 1000 * 60 * 60,
    httpOnly: true,
    path: '/cym/abc',
    secure: true,
    // domain: 'baidu.com',
  });
  res.end('home');
});

app.listen(3000);
```

## Session

`cookie` 在客户端是可以被修改的，所以是不安全的，而且以明文保存

`session` 是另一种记录服务器和客户端会话状态的机制

`session` 是基于 `cookie` 实现的，`session` `存储在服务器端，sessionId` 会被存储到客户端的 `cookie` 中

`session` 是保存在服务器上的，客户端是无法获取到的

`session` 不是独立存在的，它依赖于 `cookie`

`session` 是一种特殊的 `cookie`，通常用作登录验证

### 认证流程

* 当用户第一次请求服务器的时候，服务器会根据用户提交的信息，创建对应的 `session`
* 请求返回时将此 `session` 的唯一标识信息 `sessionID` 返回给浏览器
* 浏览器接受到服务器返回的 `sessionID` 信息后，会将此信息保存到 `cookie` 中，同时 `cookie` 会记录此 `sessionID` 属于哪个域名。

- 当用户第二次访问服务器的时候，请求会自动会自动判断此域名下是否存在此 `cookie` 信息，如果存在则自动将此信息发送给服务器，服务器会从 `cookie` 中获取 `sessionID`，再根据 `sessionID` 查找对应的 `session` 信息后，如果没有找到说明用户没有登录或者 `session` 实效，如果找到说明用户已经登录继续执行以后操作

`sessionID` 是连接 `cookie` 和 `session` 的一道桥梁，大部分系统也是根据此来验证用户是否登录过的

### 代码实现

接下来我们用 `koa` 来实现一个 `session`，需求如下当用户登录之后，点击用户中心则可以跳转用户中心，然后返回到其他页面之后在再次点击用户中心也可以进去用户中心，没有登陆过则不可以跳转到用户中心，让他跳转登录页，退出后清空 `session`，使其不能进入用户中心页面。完整代码已上传 `github` [传送门](https://github.com/fecym/sesssion.git)

```js
// koa 实现如下
const Koa = require('koa');
const Router = require('koa-router');
const session = require('koa-session');
const static = require('koa-static');
const body = require('koa-parser');
const app = new Koa();

// 使用 session 需要一个秘钥，就是一些随机字符串
app.keys = ['5e04d20d-33b72', '5e04d20d-1181c', '5e04d20d-1ac51'];

// 处理post
app.use(body());

// 使用中间件设置session
app.use(
  session(
    {
      maxAge: 20 * 60 * 1000,
      renew: true,
    },
    app
  )
);

const router = new Router();

router.post('/login', async ctx => {
  const { username, password } = ctx.request.body;
  if (username === 'admin' && password === '123123') {
    console.log('登录成功');
    // 设置 session
    ctx.session.user = username;
  } else {
    console.log('登录失败');
  }
  // 没有这个前台会报404，必须返回点什么
  ctx.body = { code: 200 };
});

// 用户中心
router.get('/profile', async ctx => {
  if (!ctx.session.user) {
    ctx.body = `<a href="/">请返回登录</a>`;
  } else {
    ctx.body = '用户中心';
  }
});

// 清空 session
router.get('/logout', async ctx => {
  ctx.session.user = null;
  ctx.body = '退出成功';
});

app.use(router.routes());

app.use(static('./www'));

app.listen(3001);
```

## Cookie 和 Session 的区别

* 安全性：`session` 比 `cookie` 安全，`session` 是存在服务端的，`cookie` 是存储在客户端的
* 存储类型不同：`cookie` 只支持存储字符串，要设置其他类型的需要转为字符串，但是 `session` 可以储存任意类型数据
* 有效期不同：`cookie` 可以保存在硬盘也可以保存在内存，可以长时间保存；`session` 不行，`session` 一般失效时间都比较短
* 储存大小不同：单个 `cookie` 保存的数据不能超过 `4kb`，`session` 可储存数据远高于 `cookie`

## JWT

jwt 全称 **JSON Web Token**，是目前最流行的跨域认证解决方案。具体可查看阮一峰大大的 [`JSON Web Token 入门教程`](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)

### 认证流程

* 第一次请求服务器，客户端发送账号和密码
* 后台校验通过，生成一个有时效性的 `token`，将这个 `token` 发送给客户端
* 客户端获得 `token` 后，将此 `token` 存储在本地，一般储存在 `localstore` 或 `cookie`
* 随后每次请求都会将这个 `token` 携带到请求头里，所有的需要校验身份的接口都会被 `token` 校验，若 `token` 解析后的数据包含用户身份信息，则身份验证通过。

### 为什么要使用 jwt

* 在基于 `token` 的认证，`token` 通过请求头传输，而不是把认证信息存储在 `session` 或者 `cookie` 中。这意味着无状态。你可以从任意一种可以发送 HTTP 请求的终端向服务器发送请求。
* `session` 不利于拓展
* `session` 是存在服务器中的
* 假如服务器中使用了负载均衡，那么每次的请求不一定都会分发到同一台服务器上（ip\_hash 除外），此时就需要改变策略或者使用 `redis` 来共享 `session` 的，但是使用 jwt 就可以完全避免这个问题，因为每次请求都是携带 `token` 的，所以服务端不需要保存会话信息

### jwt 格式

一个标准 `jwt` 有三部分组成：**header**（头部）、**payload**（数据）、**signature**（签名）

中间用点分隔开，并且都会使用 `Base64` 编码

服务端生成的一个 `jwt` 格式如下，以 `.` 分隔，token 可被解密，所以千万不要存 **敏感信息**

```shell
# （头部）是 base64 加的密，可以使用 base64 进行解密
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.
# （载荷 --> 保存的数据）
eyJkYXRhIjp7InVpZCI6MiwidXNlcm5hbWUiOiJjeW0ifSwiZXhwIjoxNTc3NjMzMjQwLCJpYXQiOjE1Nzc2Mjk2NDB9.
# （签名）
Y6F6_pOyDw2FMW6s9pND4n_IJTUmDQalEIZg823-Pqli-PSrKdoO0wfZTeXJawePNcceqt-wc5s37V5ZJRt8_vcSe8D3NAE-HUou2Jf9cGBnCj5Y84PfcrM8Y4txdbivm8TKFDx7TfafIFXscaNMdYGUEzA5pejUlEuda_lNkPAooxF6KjdUW3mW3ZeJSbP2VmblS6ycg6TyTxJJx8EopV_aLfkpA-3Yqg-A3d4kfK9GcksaX-vLxUi2y0L24Z4BoA_qdc0bTf1qMmh9BFlKCy5SX7unY_PaXXdWrEhLimmQwNu-N_byOMsgncEX1mYgNPnNxXvwYYHBPwZsqSkzRA
```

### jwt 基本使用

在 `node` 中使用 `jwt` 我选择了 `jsonwebtoken` 模块，这里来介绍下基本用法

#### 1. 签发 jwt

在 `jsonwebtoken` 模块中有个 `sign` 方法，用来签发 `token`，该方法接收三个参数：`payload`（载荷）、`secret`（秘钥）、其他的配置，简单写起来可能如下代码：

**载荷：除去协议首部之外实际传输的数据**

```js
const jwt = require('jsonwebtoken');

const payload = { name: 'cym' };

// 秘钥
const secret = 'CHENGYUMING';

// 签发 token
const token = jwt.sign(payload, secret, { expiresIn: '1day' });
```

#### 2. 校验 jwt

在 `jsonwebtoken` 模块中有个 `verify` 方法，用来校验 `jwt`，接收三个参数：token、secret 和 校验之后的回调函数

```js
jwt.verify(token, secret, (err, data) => {
  if (err) {
    return void console.log(err.message);
  }
  console.log(data);
});
```

#### 3. RS256 算法

默认签发还有校验 `token` 的时候用的是 `HS256` 算法，这种算法需要一个密钥（密码）。

我们还可以使用 `RS256` 算法签发与校验 `jwt`。

这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有 **公钥的地方只能做验证**，但不能签发 `jwt`。

此时我们就需要先生成一个私钥和一个公钥：

在项目目录下新建一个文件夹用来存储生成的私钥和公钥

```sh
mkdir rsa_key && cd rsa_key
# 先生成一个私钥
openssl genrsa -out rsa_private_key.pem 2048
# 在根据这个私钥生成一个公钥
openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem
```

用 `RS256` 算法签发 `jwt` 的时候需要，从读取我们创建的秘钥文件，使用的方法还是跟之前一样的，不过需要在最后一个参数里面配置一下算法的格式 `{ algorithm: 'RS256' }`，那么整个流程如下

```js
const fs = require('fs');
const jwt = require('jsonwebtoken');
const path = require('path');

const privateKey = fs.readFileSync(path.resolve(__dirname, './rsa_key/rsa_private_key.pem'));

// 签发 token，这里使用 RS256算法
const payload = { name: 'cym' };
const tokenRS256 = jwt.sign(payload, privateKey, {
  // 这里修改算法为 RS256
  algorithm: 'RS256',
  // 使用秒或表示时间跨度 zeit / ms 的字符串表示。
  expiresIn: '1d',
});

console.log('RS256 算法：', tokenRS256);

// 校验
const publicKey = fs.readFileSync(path.resolve(__dirname, './rsa_key/rsa_public_key.pem'));

// 接受两个个参数：要校验的 token，公钥。校验 token 会得到一个对象，其中 iat 是 token 创建时间，exp 是 token 到期时间
jwt.verify(tokenRS256, publicKey, (err, data) => {
  if (err) {
    return void console.log(err.message);
  }
  console.log(data);
});
```

### 前后端交互代码实现

想了想呢，还是把代码放到 `github` 上吧，虽然是一个简单的前后端使用 `jwt` 进行交互，但是代码还是有点多，涉及到两端交互使用 `Authorization` 进行前后端校验，[代码地址](https://github.com/fecym/jwt-flow.git)

---

---
url: /docs/01.前端/02. 代码实现/api.md
---

> 使用一个 api 我们要了解它到底做了什么才可以实现我们想要的功能，不仅要会用还要知道为什么

## 实现一个 new 操作符

> 函数执行前面加个 `new` 做了哪些事情，为啥就会构造一个对象出来

* 创建了一个新对象
* 链接到了原型
* 执行函数，绑定了 this 指向新创建的对象上
* 返回一个对象，如果函数中有`return`关键字，看 return 了什么出来，如果是一个对象，那么返回这个对象，如果不是则返回我们新建的这个对象
* 实现过程如下：

```js
function New() {
  // 创建了一个新对象
  const obj = {};
  // 取得构造函数
  const F = [].shift.call(arguments);
  // 链接到了原型
  obj.__proto__ = F.prototype;
  // 绑定this，执行构造函数
  const result = F.apply(obj, arguments);
  // 看看构造函数返回了什么
  if (typeof result !== null && (typeof result === 'object' || typeof result === 'function')) {
    return result;
  }
  return obj;
}
```

## instanceof 实现

> 实现了一个 `new` 是不是也得判断一下，那我们来实现一个 `instanceof`

* `instanceof` 都做了什么事？
* `instanceof` 是拿着左边实例的 `__proto__` 与右边构造函数的 `prototype` 进行对比的
* 尝试着实现下

```js
function instance(L, R) {
  if (L.__proto__ === null) {
    return false;
  }
  if (L.__proto__ === R.prototype) {
    return true;
  }
  return instance(L.__proto__, R);
}
instance(p, Function); // false
instance(Function, Object); // true >> Function.__proto__.__proto__ === Object.prototype
```

还有种写法是直接把`L.__proto__` 直接赋值为 `L.__proto__.__proto__`，但是这样写会影响到原型，导致如果查询不到则会抛出异常，不推荐下面的写法

```js
function instance(L, R) {
  while (true) {
    if (L.__proto__ === null) {
      return false;
    }
    if (L.__proto__ === R.prototype) {
      return true;
    }
    L.__proto__ = L.__proto__.__proto__;
  }
}
```

## call 和 apply

::: tip call 和 apply
我们都知道 `js` 的函数中 `this` 是动态的，不同执行上下文会导致 `this` 执行不同的地方，总得来说 `this` 执行有四种情况

* 函数自执行，`this` 执行指向 `window`
* 谁打点调用函数，`this` 指向这个 `谁`，也就是 . 前面的那个对象
* `call` 和 `apply` 的硬绑定 `this`
* 函数加 `new` 关键字后，`this` 执行该构造函数的实例

那么第三条第四条规则为什么就会改变 `this` 执行，其实说白了函数中 `this` 应该都遵循 `1、2` 两条规则，`3、4` 其实都是在底层实现了，让其 `this` 执行了我们想要指向的地方，比如说 `new` 关键字，我们在本文的第一个 `api` 中就讲了他的实现，他是利用 `apply` 或者 `call` 来绑定上去的，这里我们来讲下 `call` 和 `apply` 的实现
:::

### 实现 call 和 apply

> `call` 和 `apply` 两者很像除了传递的参数不同，一个是传递的是值，一个传递的是一个数组

```js
// call
Function.prototype.call2 = function(context = window) {
  // example：fnA.call(obj, 1)
  context.fn = this;
  const args = [...arguments].slice(1);
  // 执行 context.fn(...args) 此时就相当于 obj.fnA(1)
  const result = context.fn(...args);
  delete context.fn;
  return result;
};
// apply
Function.prototype.apply2 = function(context = window) {
  context.fn = this;
  let result;
  // 看是否有第二个参数，也可以不传参数
  if (arguments[1]) {
    // 因为传递过来的是一个数组，所以要解构一下
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};
```

::: warning 解释 call 实现原理
举个栗子： `fnA.call(obj, 1)`&#x20;
call2 函数 第一个参数是要绑定的对象（obj）
我们根据谁打点调用函数 `this` 执行谁，我们在这个对象中新增一个属性 `fn`，给它赋值为此时的 **~~this~~**&#x20;
那么就相当于 给我们传进来的 `obj` 新增一个属性 `fn`，让他等于这个 **~~this~~**&#x20;
因为 `call2` 是定义在函数的原型的对象上的，那么此时这个 **~~this~~** 就是 调用 `call2` 方法函数的实例，也就是 **~~fnA~~**&#x20;
也就是说 `context.fn` 就相当于 给 `obj` 新增了一个属性 `fn（fnA）`然后 `obj.fn` 执行了，那么谁打点调用 `this` 执行谁，此时 `this` 指向了 这个 `obj`&#x20;
这就是 `call` 方法实现的基本思路&#x20;

注：字体加粗并且有删除的 **~~this~~** 是 在 call 函数中的 this；有背景底色的 `this` 指的是我们绑定后的 this

:::

### 一道有趣的面试题

曾看到这么一道面试题：

```js
const arrayLike = {};
[].push.call(arrayLike, 1);
console.log(arrayLike); // { 0: 1, length: 1 }
// 接下来我们改成这样
const call = [].push.call;
call(arrayLike, 1);
console.log(arrayLike);
// 此时会打印什么？
// 答案是会报错，call is not a function
// 为什么？给自己一个思考问题的机会吧
```

## bind

### bind 用法

> bind 用法和 call 很类似，但是 bind 不会立即执行函数，而是返回一个绑定了 this 的新函数

```js
const obj = { name: 'cym' };
function fn(age) {
  console.log(this.name + '今年' + age + '岁了');
}
// 如上代码，我们要让 this 指向 obj
const bindFn = fn.bind(obj);
bindFn(24); // cym今年24岁了
```

### 基本功能的实现

根据上面的用法，我们不难 `bind` 的方法不仅可以绑定 `this` 还可以绑定参数，我们来简单实现一下

```js
Function.prototype.bind2 = function(ctx = globalThis) {
  // 取到我们要绑定的参数
  const args = [...arguments].slice(1);
  // 缓存 this，因为返回一个函数 this 就会变成新的函数
  const that = this;
  // 返回一个函数
  return function() {
    // 返回函数里面的 arguments 是返回函数传入的参数哦，别搞混了
    that.apply(ctx, args.concat([...arguments]));
  };
};
```

### 返回函数作为构造函数

`bind` 方法的实现其实蛮有意思的，因为 `bind` 方法返回一个函数，那么返回的这个函数如果被当做构造函数怎么办

```js
const obj = { name: 'cym' };
function fn() {
  console.log(this);
}
// 如上代码，我们要让 this 指向 obj
const bindFn = fn.bind(obj);
const instance = new bindFn(24); // fn {}
```

根据上面的代码返回结果来看，我们发现当绑定的函数作为构造函数来用的话，`this` 指向了原来的函数的实例，那么我们来实现一下完整的 `bind` 方法

```js
Function.prototype.bind2 = function(ctx = globalThis) {
  // 取得参数
  const args = [...arguments].slice(1);
  // 取得函数
  const that = this;
  // 要返回一个函数,还要判断是否有进行实例化的操作
  function Fn() {
    const allArgs = args.concat([...arguments]);
    // 如果被实例化了
    if (this instanceof Fn) {
      that.apply(this, allArgs);
    } else {
      that.apply(ctx, allArgs);
    }
  }
  // 但是我们需要保证原型不能丢失，还得是原来函数的实例
  // 这种写法可能不雅观，因为直接让两个原型指向了同一个地址，一般情况下我们会使用一个临时性构造函数来处理一下
  // Fn.prototype = this.prototype
  Fn.prototype = Object.create(this.prototype);
  // 返回这个绑定好 this 的函数
  return Fn;
};
```

来看下用法

```js
const obj = { name: 'cym' };
function fn() {
  console.log(this);
}
// 如上代码，我们要让 this 指向 obj
const bindFn = fn.bind2(obj);
const instance = new bindFn(); // fn {}
bindFn(); // {name: 'cym'}
```

## 柯利化

柯利化的核心是：`只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数`

比如说实现一个 add 函数

```js
const addFn = (a, b, c, d, e) => {
  return a + b + c + d + e;
};
const add = curry(addFn);
add(1)(2)(3)(4, 5); // 15
add(1)(2)(3, 4, 5); // 15
add(1, 2, 3)(4, 5); // 15
```

面试要求就是实现这么一个函数

```js
function curry(fn, ...args) {
  // 如果参数大于等于了要改变函数的参数了，那么直接执行就可以了
  if (args.length >= fn.length) {
    return fn(...args);
  }
  // 否则就返回一个函数，函数把所有参数都累积到一起
  return function(...args2) {
    return curry(fn, ...args, ...args2);
  };
}
```

## Number.isNaN

`NaN` 是一个特殊值，他和自身不相等，是一个非自反值（自反，reflexive，即 x === x 不成立）的值。但是 `NaN != NaN` 为 `true`

```js
// 根据此特性我们可以实现一下 Number.isNaN
if (!Number.isNaN) {
  Number.isNaN = function(n) {
    return n !== n;
  };
}
// 也可以使用window.isNaN来实现
if (!Number.isNaN) {
  Number.isNaN = function(n) {
    // window.isNaN(n) 不判断数据类型
    return typeof n === 'number' && window.isNaN(n);
  };
}
```

对了，在 `JavaScript` 中 `1 / 0` 返回的不是 `NaN` 而是 `Infinity`，但是 `Infinity / Infinity` 返回 `NaN`

## Object.is

ES6 新增了一个工具方法，判断两个值是否绝对相等，可以用来处理 `-0` 的情况，因为 `-0 === 0`

```js
// Object.is 的实现
if (!Object.is) {
  Object.is = function(v1, v2) {
    // 判断是否为 -0，因为-0 === 0
    if (v1 === 0 && v2 === 0) {
      // 因为 1 / 0 === Infinity，1 / -0 === -Infinity
      return 1 / v1 === 1 / v2;
    }
    // 判断是否是 NaN
    if (v1 !== v1) {
      return v2 !== v2;
    }
    // 其他情况
    return v1 === v2;
  };
}
```

Object.is 主要用来处理一些特殊情况的，所以效率并不是很高，能使用 `==` 或 `===` 尽量使用。

## 防抖和节流

> scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），有两种常用的解决方法，防抖和节流。

### 防抖

> 每次触发高频事件都取消上次的延时操作

```js
function debounce(fn, delay) {
  let timer = null;
  return function() {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, arguments);
    }, delay);
  };
}
```

### 节流

> 每次执行函数先判断是否有还在等待执行的函数，若没有则执行

```js
function throttle(fn, delay) {
  let canRun = true;
  return function() {
    if (!canRun) return;
    canRun = false;
    setTimeout(() => {
      fn.apply(this, arguments);
      canRun = true;
    }, delay);
  };
}
// 测试
var a = 0;
setInterval(
  throttle(() => {
    a++;
    console.log(a);
  }, 2000),
  500
);
```

## mixins 实现

```js
function mixins() {
  const target = [].shift.call(arguments, 1);
  const args = arguments;
  for (let i = 0, len = args.length; i < len; i++) {
    if ([].toString.call(args[i]) !== '[object Object]') throw 'The argument must be an object';
    for (let key in args[i]) {
      if (!(key in target)) {
        target[key] = args[i][key];
      }
    }
  }
  return target;
}
```

## 深浅拷贝

深拷贝问题一直是面试过程中被问到频率特别高的问题

拷贝分两种，浅拷贝和深拷贝，分别来实现一下

工作中遇到深拷贝的问题的话，我们一般会选择 `lodash` 库中的 `deepClone` 来处理

### 浅拷贝

浅拷贝很简单只要第一层地址不一样便可以

```js
// 可以直接使用 Es6 的 rest 语法实现
function copy(target) {
  return { ...target };
}
// 也可以使用 for in 实现
function copy(target) {
  const result = {};
  for (let key in target) {
    result[key] = target[key];
  }
  return result;
}
```

### 深拷贝

深拷贝要求所有引用类型的地址都不是一个地址都是复制的值，那可以考虑使用递归来实现

```js
function deepClone(target) {
  if (typeof target !== 'object') return target;
  const result = Array.isArray(target) ? [] : {};
  for (let key in target) {
    result[key] = deepClone(target[key]);
  }
  return result;
}
```

### 循环引用

但是上面的方法如果对象中出现循环引用了，那么就不能用了，需要单独考虑，考虑以下对象

```js
const obj = {
  name: 'cym',
  age: 25,
  home: { name: '北京' },
  hobbies: ['抽烟', '喝酒', '打游戏'],
  sayHi: () => 'Hi',
};
// 循环引用
obj.obj = obj;

// 可以使用 Map 对象对一层比较即可处理这个问题
function clone(target, map = new Map()) {
  if (typeof target !== 'object') return target;
  if (map.get(target)) return map.get(target);
  const result = Array.isArray(target) ? [] : {};
  map.set(target, result);
  for (let key in target) {
    result[key] = clone(target[key], map);
  }
  return result;
}
```

## Emitter

* `node` 事件流基本是基于发布订阅模式来实现的监听的（观察者和发布订阅介绍，看[这里](/views/basis/issue.html#观察者与发布订阅)），尝试着实现下
* 里面有几个常用的方法，一个订阅事件，一个发布事件，一旦发布事件触发订阅者执行相应的回调

```js
class Emitter {
  handlers = {}

  on(type, fn) {
    if (!this.handlers[type]) {
      this.handlers[type] = []
    }
    this.handlers[type].push(fn)
  }

  emit(type, ...args) {
    if (!this.handlers[type]) return
    const fns = this.handlers[type]
    for (let i = 0; i < fns.length; i++) {
      fns[i](...args)
    }
  }

  off(type, fn) {
    if (!this.handlers[type]) return
    const fns = this.handlers[type]
    let res;
    // 要倒着循环, 否则会丢项
    for (let i = fns.length - 1; i >= 0; i--) {
      if (fns[i] === fn) {
        res = fns.splice(i, 1)
        break
      }
    }
  }

  rm(type) {
    if (!this.handlers[type]) return
    delete this.handlers[type]
  }

  once(type, fn) {
    const wrapper = (...args) => {
      fn(...args)
      this.off(type, wrapper)
    }
    this.on(type, wrapper)
  }
}
```

* 持续更新中....

---

---
url: /docs/02.服务端/Nginx 相关/nginx-requisite.md
---

# 反向代理与负载均衡

> **nginx**是一个高性能的 HTTP 和反向代理服务器，也是一个通用的 TCP/UDP 代理服务器，最初由俄罗斯人**Igor Sysoev**编写。**nginx**在应用程序中的作用有：
>
> * 解决跨域
> * 请求过滤
> * 配置 gzip
> * 负载均衡
> * 静态资源服务器

## 代理

>  `代理` 是在服务器和客户端之间架设的一层服务器，代理将接受客户端的请求将它转发给服务器，然后将服务端的响应转发给客户端。不管正向代理还是反向代理，都是实现此功能。 >  说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。 >  举个例子：比如说生活中的专卖店，客人到 adidas 专卖店买了一双鞋，这个专卖店就是代理，被代理角色就是 adidas 厂家，目标角色就是用户

### 正向代理

> 正向代理是一个位于 **客户端** 和 **原始服务器** 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端

* 正向代理是为我们服务的，也就是为客户端服务的。客户端可以根据正向代理访问到它本身无法访问到的服务器资源。

* 正向代理对我们是透明的，对服务端是不透明的，服务端不知道自己收到的是来自代理的访问还是真是的客户端的访问。

* 举个例子：我们经常说的翻墙就是正向代理，在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的。此时大家可能都会用一个操作 翻墙 进行访问，翻墙 的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们

* 特点

  1. 正向代理最大的特点是客户端非常明确要访问的服务器地址
  2. 服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端
  3. 正向代理模式屏蔽或者隐藏了真实客户端信息

* 用途
  1. 访问原来无法访问的资源，如 Google
  2. 可以做缓存，加速访问资源
  3. 对客户端访问授权，上网进行认证
  4. 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息

### 反向代理

> 正向代理隐藏了客户端的信息，那么反向代理正好相反，隐藏了服务端的信息，客户端反问一个台代理服务器，然后由代理服务器把请求转发到相应的服务器上

* 反向代理经常被用来隐藏服务器安全，为了安全我们的服务一般都不会对外开放，此时我们需要一台对外开放的服务器，来做各种请求的转发，接受一条来自外界的请求，代理服务器负责转发到相应的内网服务器进行处理

* 反向代理，`它代理的是服务端`，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。

* 举个栗子：在我们拨打 10086 客服电话，可能一个地区的 10086 客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，你只需要拨通了 10086 的总机号码，电话那头总会有人会回答你。那么这里的 10086 总机号码就是我们说的 **反向代理**，客户不知道真正提供服务人的是谁。

* 用途

  1. 保证内网的安全，通常将方向代理作为公网访问地址，web 服务是内网
  2. 负载均衡，通过反向代理服务器来优化网站的负载。

* 假如现在访问我的网站就是访问 www.baidu.com，配置入戏

```sh
  server {
    # 监听端口
    listen  80;
    server_name localhost;
    location /  {
      proxy_pass  http://www.baidu.com;
    }
  }
```

## 集群与负载均衡简单了解

* 集群：一组松散或紧密连接在一起工作的计算机。 由于这些计算机协同工作，在许多方面它们可以被视为单个系统。 与网格计算机不同，计算机集群将每个节点设置为执行相同的任务，由软件控制和调度。（摘自百度百科）
* 简单理解集群就是：多个服务器一起为某个服务工作；
* 负载均衡：高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。（摘自知乎）
* 简单理解负载均衡就是：
  * 我们有一堆服务器处理相同的服务，这是集群，
  * 他们可以 ip 一样端口不一样，也可以不同的服务器端口一样的，
  * 比如说有两台服务器处理相同的服务，一台端口为 8888，一台端口为 7777，
  * 这两台服务器就是一个集群，这时候会有 多种算法 使我们访问这个服务的时候到底去请求那个端口的服务，
  * 这个算法可以是一个请求发给 8888，一个发给 7777；
  * 假如 8888 性能好点十核的服务，7777 是一核的，也可以十个请求给 8888 一个请求给 7777，有不同的算法来不同的处理。那我们怎么配置呢
* 首先，简单配置如下

```sh
  # 配置都在http模块里面
  http {
    # ...省略其他配置
    # 配置集群，webserver是我们给集群起的名字
    upstream webserver {
      server localhost:8888;
      server localhost:7777;
    }
    # 配置负载均衡
    server {
      listen  80;
      server_name localhost;
      location  / {
        # 这里传入集群的名字
        proxy_pass  http://webserver;
      }
    }
  }
```

## 负载均衡调度算法

> 接下来，我们写四台简单的服务器，来进行测试，四个服务器的端口分别是 `3333、4444、5555、6666`，他们都返回自身的端口号，然后我们在进行 `nginx` 调度配置，先把四台服务器跑起来

### 轮询（默认）

* 每个请求按照时间顺序逐一分配到不同的服务器，如果服务器宕机，则自动剔除
* 简单配置一个，访问网站 `/testserver` 每次都返回不同的内容

```sh
  # 默认配置就是轮询
  http {
    # .... 省略其余配置
    # 测试集群策略
    upstream test_server {
      server localhost:3333;
      server localhost:4444;
      server localhost:5555;
      server localhost:6666;
    }

    server {
      listen  80;
      server_name localhost;
      location / {
        # 省略....
      }
      # 集群配置
      location /testserver {
        proxy_pass http://test_server;
      }
    }
  }

```

### 权重 weight

* 使用 `weight` 指定轮询几率，`weight` 和访问比率成正比，用于后端服务器性能不均的情况。
* 权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。
* 配置一个实现，访问网站 10 次，四个端口按照 1:2:3:4 的比例进行访问

```sh
  # 只需要在定义的集群服务器后面写上权重值就可以了
  upstream test_server {
    server localhost:3333 weight=1;
    server localhost:4444 weight=2;
    server localhost:5555 weight=3;
    server localhost:6666 weight=4;
  }
```

### ip\_hash 策略

* 使用 `ip_hash` 定义服务器的调度
* 每个请求按照发起客户端的 `ip` 的 `hash` 结果进行匹配，这样的算法下一个固定 `ip` 地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下 `Session` 共享的问题
* 配置也很简单，只需要在定义集群服务上面加上 `ip_hash` 即可

```sh
  # ip_hash 策略
  upstream test_server {
    # 这样做，谁访问的那个服务器，为了避免 session 不共享的问题，这个人基本上会被一直代理到他所访问到的服务器上
    ip_hash;
    server localhost:3333;
    server localhost:4444;
    server localhost:5555;
    server localhost:6666;
  }
```

### 其他策略

* 除了以上三种调度策略外，还有其他的调度算法，但是那些需要依赖第三方插件，简单介绍下
* `fair` 策略：按后端服务器的响应时间来分配请求，响应时间短的优先分配。
* `url_hash` 策略：按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。

```sh
  # fair 策略（第三方）
  upstream test_server {
    server localhost:3333;
    server localhost:4444;
    server localhost:5555;
    server localhost:6666;
    fair;
  }

  # url_hash（第三方）
  upstream test_server {
    server localhost:3333;
    server localhost:4444;
    server localhost:5555;
    server localhost:6666;
    hash $request_uri;
    hash_method crc32;
  }
```

### 定义负载均衡设备的 Ip 及设备状态

* `nginx` 支持同时设置多组的负载均衡，用来给不用的 `server` 来使用
* 配置如下：

```sh
  upstream test_server {
    ip_hash;
    server localhost:3333 down;
    server localhost:4444 weight=2;
    server localhost:5555;
    server localhost:6666 backup;
  }
```

* 设备的状态值：
  1. `down`：表示当前设备暂时不参与负载
  2. `weight`：默认为 1。`weight` 越大，负载的权重就越大
  3. `max_fails`：允许请求失败的次数默认为 1。当超过最大次数时，返回 `proxy_next_upstream` 模块定义的错误
  4. `fail_timeout:max_fails`：次失败后，暂停的时间
  5. `backup`：其它所有的非 `backup` 机器 `down` 或者忙的时候，请求 `backup` 机器。所以这台机器压力会最轻

本文章参考链接如下:

* [Nginx upstream 的几种分配方式](https://blog.51cto.com/wangwei007/1103727)
* [Nginx 相关介绍(Nginx 是什么?能干嘛?)](https://www.cnblogs.com/wcwnina/p/8728391.html)
* [nginx 反向代理和负载均衡策略实战案例](https://mp.weixin.qq.com/s?__biz=MzIyMDkwODczNw==\&mid=2247485444\&idx=1\&sn=f142dc529b3bd4ad2813cbfd5e021e07\&chksm=97c595aaa0b21cbc72b9b15d42f24a435f24b1bb10acdecb84587390f58369f4a6c7e5873eda\&mpshare=1\&scene=24\&srcid=\&sharer_sharetime=1573177641385\&sharer_shareid=173a9b33fbb44b987bd7c4d69f782a28#rd)

---

---
url: /docs/@pages/categoriesPage.md
---


---

---
url: /docs/01.前端/03. 工作技巧/issue.md
---

## 获取一个月有多少天

今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据

`new Date(year, month, date, hrs, min, sec)` ， `new Date` 可以接受这些参数创建一个时间对象
其中当我们把 `date` 设置为 `0` 的时候，可以直接通过 `getDate()` 获取到最后一天的日期然后得到我们要的最后一天

```js
new Date(2019, 12, 0).getDate(); // 31
new Date(2018, 2, 0).getDate(); // 28
// 根据这个我们可以得到一个方法
function getMonthLength(month) {
  const date = new Date(month);
  const year = date.getFullYear();
  // 月份是从 0 开始计算的
  const m = date.getMonth() + 1;
  return new Date(year, m, 0).getDate();
}
```

## void 运算符

`undefined` 是一个内置标志符，它的值为 `undefined` （除非被重新定义过），通过 `void` 运算符即可得到该值

在 `void` 之后的语句或表达式都将返回 `undefined` 。 `void` 并不会改变表达式的结果，只是让表达式不返回值

```js
void true; // undefined
void 0; // undefined
```

`void` 运算符在其他地方也可以派上用场，比如不让表达式返回任何结果。

```js
// 该函数不需要有任何返回结果
function doSomething(sign) {
  if (!sign) {
    return void setTimeout(doSomething, 100);
  }
}
// 或许你经常向下面一样这么写
function doSomething(sign) {
  if (!sign) {
    setTimeout(doSomething, 100);
    return;
  }
}
```

## 关于 JSON.stringify

`JSON.stringify` 和 `toString()` 效果基本相同，只不过序列化的结果总是字符串

```js
JSON.stringify(42); // "42"
JSON.stringify('42'); // ""42""（含有双引号的字符串）
JSON.stringify(null); // "null"
JSON.stringify(true); // "true"
```

* 不安全的 JSON 值

所有安全的 `JSON` 值都可以使用 `JSON.stringify` 序列化，不安全的 `JSON` 值有： `undefined` 、 `function` 、 `symbol` 和 `循环引用` 。 `JSON.stringify`

在对象中遇到这些不安全的 `JSON` 值的时候会自动将其忽略，在数组中遇到则会返回 `null` ，以保证数组成员位置不变

```js
JSON.stringify(undefined); // null
JSON.stringify(function() {}); // null
JSON.stringify([1, undefined, 2, function() {}, 3]); // "1, null, 2, null, 3"
JSON.stringify({
  a: 2,
  b: function() {},
}); // "{"a":2}"
```

* toJSON 方法

如果对象中定义了 `toJSON` 方法，那么在 `JSON` 序列化的时候优先调用该方法，主要是为了处理循环引用的时候，我们让其返回一个合理的值

也就是说 `toJSON` 方法应该返回一个能够被字符串安全化的 `JSON` 值

```js
const o = {
  a: 'cym',
  toJSON() {
    return {
      c: 'b',
    };
  },
};

JSON.stringify(o); // {"c":"b"}
```

* JSON.stringify 的第二个参数

我们可以向 `JSON.stringify` 中传递一个可选参数 `replacer` ，他可以书数组也可以书函数，用来指定对象序列化的时候哪些属性应该被处理，哪些应该被排除，和 `toJSON` 很像

1. 当 `replacer` 是一个数组时，那么他必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外的属性就会被忽略

```js
const obj = {
  a: 42,
  b: 30,
  c: 100,
};
JSON.stringify(obj, ['a', 'c']); // {"a":42,"c":100}
```

2. 当 `replacer` 是一个函数时，他会对对象本身调用一次，然后在对对象中的每个属性各调用一次。每次传递两个参数（对象的键和值）。如果要忽略某个键就返回 `undecided`，否则就返回指定的值

```js
const obj = {
  a: 42,
  b: 30,
  c: 100,
};
JSON.stringify(obj, (k, v) => {
  // 注意：第一次 k 是 undefined，v 是原对象
  if (k !== 'c') return v;
}); // "{"a":42,"b":30}"
```

## 一元运算符

我们都知道一个字符串转换为数字，可以使用 `+ "12"` 转换为数字 12，也可以使用 `-` ，这样的 `+、-` 是一元运算符，这样将数字转换为字符串的方法属于显示转换

`-` 运算符还有反转符号位的功能，当然不能把一元操作符连在一起写，不然会变成 `--` ，当做递减运算符号来计算了，我们可以理解为 `-` 运算符出在单数次数会转符号位，出现双次数会抵消反转，比如说 `1 - - 1 === 2`

```py
# 这是 js 代码哦，不是 python
1 + - + - + - 1   # 0
1 - - 1           # 2
1 - - - 1         # 0
```

## 字位反转操作符 ~

`~` 返回 2 的补码， `~x` 大致等同于 `-(x+1)`

```js
~42; // -(42+1) ===> -43
```

在 `-(x+1)` 中唯一能够得到 0（或者严格来说时候 -0）的 x 值是 -1，也就是说 ~ 和一些数字在一起会返回一个假值 0，其他情况下则返回真值

-1 是一个 `哨位值` ，哨位值是那些在各个类型中被赋予了特殊含义的值。在 C 语言中 -1 代表函数执行失败，大于等于 0 的值代表函数执行成功

比如在 JavaScript 中字符串的 indexOf 方法也遵循这一惯例，该方法在字符串中搜索指定的字符串，如果找到就返回该子字符串所在的位置，否则返回 -1

1. \~ 的用途

我们知道在 JavaScript 中假值有： `undefined、null、false、+0、-0、NaN、''` ，其他都为真值，所以负数也是真值，那么我们就可以拿着 `~` 和 `indexOf` 一起检结果强制类型转换为 真/假 值

```js
const str = 'hello world';
~str.indexOf('lo'); // -4，真值
if (~str.indexOf('lo')) {
  // true
  // 找到匹配
}
~str.indexOf('ol'); // 0，假值
!~str.indexOf('ol'); // true
if (!~str.indexOf('ol')) {
  // true
  // 没有找到匹配
}
```

\~ 要比 `>=0` 和 `== -1` 更简洁

2. 字位截除

我们经常使用 `~~` 来截取数字值的小数部分，以为这是和 Math.floor 效果是一样的，实际上并非如此

`~~` 中第一个 ~ 执行 ToInt32 并反转字位，然后第二个在进行一次字位反转，就是将所有的字位反转回原值，最后得到的结果仍是 ToInt32 的结果

`~~` 只适用于 32 位的数字，更重要的是他对负数的处理与 Math.floor 不同，所以使用时要多加注意

```js
Math.floor(1.9); // 1
~~1.9; // 1
// 操作负数
Math.floor(-1.9); // -2
~~-1.9; // -1
```

`~~x` 能将值截除为一个 32 位的整数， `x | 0` 也可以，而且看起来更简洁哦，不过出于对运算符优先级的考虑，我们更倾向于使用 `~~x`

```js
~~1.9; // 1
1.9 | 0; // 1

~~-1.9; // -1
-1.9 | 0; // -1
```

## 给定一组 url 实现并发请求

原题是这样的：给定一组 url，利用 js 的异步实现并发请求，并按顺序输出结果

1. Promise.all

首先我们可以想到的是利用 `Promise.all` 来实现，代码实现如下

```js
const urls = ['./1.json', './2.json', './3.json'];

function getData(url) {
  // 返回一个 Promise 利用 Promise.all 接受
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.responseType = 'json';
    xhr.onreadystatechange = () => {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(xhr.response);
        }
      }
    };
    xhr.open('GET', url, true);
    xhr.send(null);
  });
}

function getMultiData(urls) {
  // Promise.all 接受一个包含 promise 的数组，如果不是 promise 数组会被转成 promise
  Promise.all(urls.map(url => getData(url))).then(results => {
    console.log(results);
  });
}
```

2. 不用 Promise

原题是不用 `Promise` 来实现，我们可以写一个方法，加个回调函数，等数据全部回来之后，触发回调函数传入得到的数据，那么数据全部回来的就是我们要考虑的核心问题，我们可以用个数组或者对象，然后判断一下数组的 length 和传入的 url 的长度是否一样来做判断

* 使用对象做映射

```js
const urls = ['./1.json', './2.json', './3.json'];

function getAllDate(urls, cd) {
  const result = {};

  function getData(url, idx) {
    const xhr = new XMLHttpRequest();
    xhr.responseType = 'json';
    xhr.onreadystatechange = () => {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          result[idx] = xhr.response;
          // 如果两者 length 相等说明都请求完成了
          if (Object.keys(result).length === urls.length) {
            // 给对象添加length属性，方便转换数组
            result.length = urls.length;
            cd && cd(Array.from(result));
          }
        }
      }
    };
  }
  // 触发函数执行
  urls.forEach((url, idx) => getData(url, idx));
}
// 使用
getAllDate(urls, data => {
  console.log(data);
});
```

* 使用数组实现

和上面的基本思路差不多，不过这次换成了数组，也可以给个信号量来做判断

```js
function getGroupData(urls, cb) {
  const results = [];
  let count = 0;
  const getData = url => {
    const xhr = new XMLHttpRequest();
    xhr.responseType = 'json';
    xhr.onreadystatechange = _ => {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          results.push(xhr.response);
          if (++count === urls.length) {
            cb && cb(results);
          }
        }
      }
    };
    xhr.open('GET', url, true);
    xhr.send(null);
  };
  urls.forEach(url => getData(url));
}

getGroupData(urls, data => {
  console.log(data);
});
```

## 1..toString 的问题

有时候我们看到别人的代码中会写到数字调其他类型的方法的时候会写成 `1..toString()` 这样的写法

因为直接用整数型数字调方法就会报错，但是如果是一个浮点数的话就不会报错了

因为可能在 `.` 上面存在争议，一个数字后面加点，解释器他不知道你这是小数还是要调取方法，所以就跑异常了

```js
1. toString() // Uncaught SyntaxError: Invalid or unexpected token
1..toString() // '1'
1.2.toString() // '1.2'
```

## 滚动加载

开发移动端经常会遇到滚动加载，滚动加要满足 `"页面真实内容高度" 超过 "可视窗口" 的高度` ，那么说明需要加载新的数据了

此时我们就需要知道几个高度值：

1. 页面的真实高度
2. 可视区域的高度
3. 页面滚动的高度

页面的真实高度 = 可是区域的高度 + 页面的滚动高度

## 高度、滚动、位置相关的属性

每个 HTML 元素都具有 `clientHeight` 、 `offsetHeight` 、 `scrollHeight` 、 `offsetTop` 、 `scrollTop` 这 5 个和元素高度、滚动、位置相关的属性

clientHeight 和 offsetHeight 属性和元素的滚动位置没有关系，它代表着元素的高度：

* clientHeight 包括 padding 但不包括 margin、border 和水平滚动条的高度，对于 inline 的元素这个属性一直是 0，单位 px，只读属性

* offsetHeight 包括 padding、border 和水平滚动条但不包括 margin 的高度，对于 inline 的元素这个属性一直是 0，单位 px，只读属性

当父元素的子元素比父元素高且 overflow=scroll 时，父元素会滚动，此时：

* scrollHeight：因为子元素比父元素高，父元素不想被子元素撑的一样高就显示了滚动条，在滚动过程中子元素有部分隐藏被隐藏，scrollHeight 就是子元素可见高度与不可见高度的真实高度，而可见高度就是 clientHeight。也就是 `scrollHeight > clientHeight` 时会出现滚动条，没有滚动条时 `scrollHeight === clientHeight` 恒成立，只读属性

* scrollTop：代表有滚动条时，滚动条向下滚动的距离，也就是子元素被遮挡的高度，在没有滚动条时 `scrollTop === 0` 恒成立，可读可设置

* offsetTop：当前元素距离最近父元素顶部的距离，和滚动条没有关系，只读属性

* clientTop：当前元素顶部边框的宽度，不包括 padding 和 margin，只读属性

知道了上面这些概念我们就可以来实现这个滚动加载，只要满足 `页面真实高度 - 页面可见高度 - 页面滚动高度 < 0` 说明该去加载新的数据了

```js
const htmlEl = document.documentElement;
// 在不满足滚动条件的时候，如果出现横向滚动条，那么 offsetHeight 是包括横向滚动条滚动条高度的，所以会大于 scrollHeight的高度，所以我们取最大值
const pageHeight = Math.max(htmlEl.scrollHeight, htmlEl.offsetHeight);
// 滚动的高度
const scrollHeight = htmlEl.scrollTop;
const viewHeight = window.innerHeight || htmlEl.clientHeight;
// 满足触发条件
pageHeight - scrollHeight - viewHeight < 0;
// 当前一般情况下会提前去加载数据，数据是一般是异步的，所以会有一个预留高度
```

## 字符串转 txt 文件（blob）

有个要求：纯前端实现，不可以使用 `node`

实现原理也很简单，就像我们平时下载一个本地文件一样，可以动态的创建一个可以下载的 `a` 标签，给它设置 `download` 属性，然后把下载的内容转 `blob` 创建下载链接下载即可

具体实现如下：

```js
function exportTxt(text, filename) {
  const eleLink = document.createElement('a');
  eleLink.download = filename;
  eleLink.style.display = 'none';
  // 将内容转为 blob
  const blob = new Blob([text]);
  eleLink.href = URL.createObjectURL(blob);
  document.body.appendChild(eleLink);
  eleLink.click();
  document.body.removeChild(eleLink);
}
```

## 奇偶数判断

普通写法：

```js
const isEven = num => num % 2 === 0;
```

也可以使用 `&` 操作符号

```js
const isEven = num => num & (1 === 0);
```

根据按位与操作符运算，`两个数都为 1 时，结果才为 1`

而判断奇偶只要根据`最未位`是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数

所以 `n & 1` 如果为 0 就是偶数，为 1 是奇数

## 格式化金钱

项目中我们经常会遇到金钱格式化需求，或者说数字格式化一下，方便阅读（数字比较大的情况下）

比如说 `999999999` ，直接阅读很不直观，格式化后 `999, 999, 999`

通常我们会使用正则来处理

```js
function formatPrice(price) {
  return String(price).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}
```

也可以不使用正则然后优雅的处理

```js
function formatPrice(price) {
  return String(price)
    .split('')
    .reverse()
    .reduce((prev, next, index) => {
      return (index % 3 ? next : next + ',') + prev;
    });
}
```

上面是两种提到的比较常用的方案，但是 js 还有个比较牛逼的 API 可以直接实现这个需求哦，它就是 `toLocaleString` ，我们可以直接数字调用这个方法就可以实现，金额的格式化

```js
(999999999).toLocaleString(); // 999,999,999
// 当然还可以更秀一点
const options = {
  style: 'currency',
  currency: 'CNY',
};
(123456).toLocaleString('zh-CN', options); // ¥123,456.00
```

`toLocaleString` 可以接收两个可选参数： `locales` 和 `options` ，而且这个 api 在各大浏览器通用不存在兼容问题并且这个 `api` 不止存在 Number 的原型上，Array、Object、Date 原型上都有这个 api，并且格式化出来的值可以根据我们传入的参数出现各种结果

[参数及用法可以参考 MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString)

## 深度冻结对象

在 vue 项目开发中，有些不变的常量，我们不想 vue 为他做双向绑定，以减少一些性能上消耗，我们可以把使用 `Object.freeze` 将对象冻结，此时 vue 将不会对这个对象进行冻结，但是这个冻结只是冻结对象第一层，所以遇到对象层级比较深的话，我们可以写个深度冻结的 api，来对常量对象做一些冻结优化

```js
const deepFreeze = o => {
  const propNames = Object.getOwnPropertyNames(o);
  propNames.forEach(name => {
    const prop = o[name];
    if (typeof prop === 'object' && prop !== null) {
      deepFreeze(prop);
    }
  });
  return Object.freeze(o);
};
```

## 脱敏处理

在一些涉及到用户隐私情况下，可能会遇到对用户的手机号身份证号之类的信息脱敏，但是这个脱敏数据的规则是根据用户信息要脱敏字段动态的生成的，此时我们动态拼接正则来实现一个动态脱敏规则

```js
const encryptReg = (before = 3, after = 4) => {
  return new RegExp('(\\d{' + before + '})\\d*(\\d{' + after + '})');
};
// 使用：'13456789876'.replace(encryptReg(), '$1****$2') -> "134****9876"
```

## 树遍历

对于树结构的遍历一般有深度优先和广度优先

广度优先和深度优先的概念很简单，区别如下：

* 深度优先，访问完一颗子树再去访问后面的子树，而访问子树的时候，先访问根再访问根的子树，称为先序遍历；先访问子树再访问根，称为后序遍历。
* 广度优先，即访问树结构的第 n+1 层前必须先访问完第 n 层

### 深度优先

* 先序遍历

```js
const treeForEach = (tree, func) => {
  tree.forEach(data => {
    func(data);
    data.children && treeForEach(data.children, func);
  });
};
```

* 后序遍历，只需要调换一下节点遍历和子树遍历的顺序即可

```js
const treeForEach = (tree, func) => {
  tree.forEach(data => {
    data.children && treeForEach(data.children, func);
    func(data);
  });
};
```

### 广度优先

广度优先的思路是，维护一个队列，队列的初始值为树结构根节点组成的列表，重复执行以下步骤直到队列为空。取出队列中的第一个元素，进行访问相关操作，然后将其后代元素（如果有）全部追加到队列最后。

```js
const treeForEach = (tree, func) => {
  let node;
  const list = [...tree];
  while ((node = list.shift())) {
    func(node);
    node.children && list.push(...node.children);
  }
};
```

### 过滤树

工作中可能会遇到一个过滤树的需求

```js
function treeFilter(tree, func) {
  return tree.filter(node => {
    node.children = node.children && treeFilter(node.children, func);
    return func(node) || (node.children && node.children.length);
  });
}
```

## 数组分组

开发移动端的时候，遇到一个首页菜单改版的需求，首页菜单根据权限控制显隐，而菜单每页展示八个小菜单，超过八个做 swipe 滑动切换，当时项目用了 vant 做的 UI 框架，菜单那模块就选择了他的轮播插件，菜单做成了一个扁平化的 list 配置，首先根据权限过滤出所有有权限的菜单项，然后每八个一分组，处理成一个二维数据来遍历菜单

```js
const arrayGroupBySize = (arr, size = 2) => {
  const result = [];
  for (let i = 0, len = arr.length; i < len; i += size) {
    result.push(arr.slice(i, i + size));
  }
  return result;
};
```

## 下划线与驼峰

做一些数据持久化的工作的时候经常会出现下划线命名和驼峰命名的转化，因为在前端处理中规范是驼峰命名，而像 mysql 之类的规范是下划线命名，所以在处理后返回给前端的数据需要转换为驼峰命名，而对数据库的读写需要下划线命名

```js
const toHump = name => {
  return name.replace(/\_(\w)/g, function(all, letter) {
    return letter.toUpperCase();
  });
};

const toLine = name => {
  return name.replace(/([A-Z])/g, '_$1').toLowerCase();
};
```

## 校验时间格式

业务中遇到一个校验一下传入时间格式是否为一个时间格式，下面的方法可以完美校验

```js
const isDate = str => {
  return typeof str !== 'number' && str !== null && new Date(str) !== 'Invalid Date';
};
```

## 正则匹配空字符

在开发项目遇到一个校验如果输入内容则用正则校验输入值是否合法，不输入则不校验问题，Java 做法直接用注解的方式传入一个正则，然后导致前端这边不传或者传入 null 的时候校验能通过，但是传入一个空字符则校验失败，此时就需要一个既可以满足业务需求也可以为空的一个正则 `/^\s{0}$/`

```js
const emptyReg = /^\s{0}$/;
emptyReg.test(''); // true
```

## 值的映射

开发 echarts 的时候会遇到一个所有的 y 轴展示多条数据，类似于堆叠图，但是要保持每条线的高度保持统一，就是每条线的最大值和最小值在每个范围内都保持统一的比值，此时我们可以对坐标轴上的数据映射一边来保证展示出来的数据一致性（用户关注的是趋势）

```js
/**
 * 值映射
 * @param {*} from  原始值的范围 [min, max]
 * @param {*} to    映射后的范围 [min, max]
 * @param {*} arr   要映射的数据
 * @returns
 */
export function mapRange(from, to, arr) {
  const _mapRange = s => {
    return to[0] + ((s - from[0]) * (to[1] - to[0])) / (from[1] - from[0]);
  };
  return arr.map(_mapRange);
}

const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
mapRange([0, 10], [-1, 0], arr);
// [-1, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.30000000000000004, -0.19999999999999996, -0.09999999999999998, 0]
```

## 根据时间间隔生成 X 轴数据

在开发 echarts 过程中，需要快速模拟数据，我们可以快速根据时间间隔，开始时间结束时间来快速生成一组 x 轴线的数据，用到 dayjs 库

```js
export function generatorXAxisData(options) {
  options.interval = options.interval || 5 * 60 * 1000;
  options.template = options.template || 'YYYY-MM-DD HH:mm:ss';
  options.startTime =
    options.startTime ||
    dayjs()
      .startOf('d')
      .valueOf();
  options.endTime =
    options.endTime ||
    dayjs()
      .endOf('d')
      .valueOf();
  const { interval, template, startTime, endTime } = options;
  const result = [];
  const timeRange = endTime - startTime;
  const count = Math.floor(timeRange / interval); //时间间隔 （五分钟：5*60*1000）
  for (let i = 0; i <= count; i++) {
    const modTine = dayjs(startTime + interval * i).format(template);
    result.push(modTine);
  }
  if (startTime + count * interval !== endTime) {
    result.push(dayjs().format(template));
  }
  return result;
}
```

## 生成随机数据

同样开发 echarts 中需要快速生成一组数据

```js
/**
 * 随机数生成，图表模拟数据用
 * @param len
 * @param range
 * @returns {number[]}
 */
export function generatorRandomValue(len = 20, range = 50) {
  const arr = Array(len).fill(0);
  return arr.map(() => {
    return (Math.random() * range) >>> 0;
  });
}
```

## 生成随机汉字

```js
// 生成随机汉字
export function genRandomText() {
  const randomChineseUnicode = `%u${(Math.round(Math.random() * 20901) + 19968).toString(16)}`;
  return unescape(randomChineseUnicode);
}
// 生成随机汉字
export function randomString(n) {
  let s = '';
  for (let i = 0; i < n; i++) {
    s += genRandomText();
  }
  return s;
}
```

## 文件按需加载

有时候会遇到一些插件不是es module 规范开发的，没有 npm 包，想要引入就需要在 HTML 中引入，但是那种插件可能会很大，我们首屏可能不需要直接引入，在需要的时候引入就可以了，所以不能直接在HTML中直接引入

这种一般我们会做成，在需要用到插件的时候，动态创建一个 script 或者 link 标签设置到 src 属性然后插入到head 中，为此可以使用以下解决方案

```js
// LoadFiles.js
export default class LoadFiles {
  /**
   * @param {Array<string>} options.files  文件地址集合
   * @param {Boolean} options.isExternal   是否是第三方链接
   * @param {String} options.urlPrefix     文件前缀
   * @param {Boolean} options.autoloading  是否主动加载
   */
  constructor(options = {}) {
    this.headNode = null;
    this.htmlNodes = [];
    this.options = options;
    options.urlPrefix = options.urlPrefix || process.env.BASE_URL;
    options.isExternal = options.isExternal || false;
    options.autoloading = options.autoloading || false;
    const files = options.files || [];
    options.files = options.isExternal
      ? files
      : files.map(this.processFileUrl, this);
    options.autoloading = options.autoloading || false;
    options.autoloading && this.load();
  }
  getHead() {
    if (!this.headNode) {
      this.headNode = document.head;
    }
    return this.headNode;
  }
  processFileUrl(url) {
    return this.options.urlPrefix + url;
  }
  getFileExt(url) {
    return url.substr(url.lastIndexOf(".")).toLowerCase();
  }
  fileExist(url) {
    return this.htmlNodes.includes(url);
  }
  loadFile(url, callback) {
    if (this.fileExist(url)) return callback(null);
    const ext = this.getFileExt(url);
    let el = null;
    if (ext === ".js") {
      el = document.createElement("script");
      el.src = url;
      el.type = "text/javascript";
    } else {
      el = document.createElement("link");
      el.href = url;
      el.rel = "stylesheet";
      el.type = "text/css";
    }
    const self = this;
    el.onload = el.onreadystatechange = function() {
      const state = this.readyState;
      if (!state || state === "loaded" || state === "complete") {
        callback(null);
        self.htmlNodes.push(url);
      }
    };
    el.onerror = callback;
    this.getHead().appendChild(el);
  }
  load() {
    return new Promise((resolve, reject) => {
      let count = 0;
      const files = this.options.files;
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        this.loadFile(file, err => {
          if (err) return reject(err);
          if (++count === files.length) resolve(true);
        });
      }
    });
  }
}
```

## base64 转文件预览地址

base64 文件可以直接预览，但是有些三方库可能需要一个真实预览地址，我们可以把 base64 转成文件预览地址来使用

```js
/**
 * base64 转文件预览地址
 * @param base64
 * @param contentType 类型
 * @param includeHead 是否包含base64头
 * @returns {string}
 */
export function base64ToUrl(base64, contentType = 'image/png', includeHead = false) {
  if (includeHead) {
    // 如果包含 base64 头，要去掉
    base64 = base64.split(',')[1];
  }
  const bstr = window.atob(base64);
  let len = bstr.length;
  const uint8Arr = new Uint8Array(len);
  while (len--) {
    // 返回指定位置的字符的 Unicode 编码
    uint8Arr[len] = bstr.charCodeAt(len);
  }
  const blob = new Blob([uint8Arr], {
    type: contentType,
  });
  return URL.createObjectURL(blob);
}
```

## 根据 url 下载文件

```js
/**
 * 可以下载的URL包括base64
 * @param url
 * @param downloadName 可以不加后缀名
 * @param cb 下载完之后的回调函数
 */
export const downloadByUrl = (url, downloadName = '', cb) => {
  const eleLink = document.createElement('a');
  eleLink.setAttribute('download', downloadName);
  eleLink.setAttribute('href', url);
  document.body.appendChild(eleLink);
  eleLink.click();
  document.body.removeChild(eleLink);
  cb && cb();
};
```

## 打印 dom

工作中可能会遇到打印的需求，我们可以直接使用 `window.print` API，但是打印的是整个页面，并且不能是单页面应用程序，此时我们想打印某个 dom 的话，就需要利用这个 api，然后动态生成一个 iframe，在 iframe 中插入要打印的 dom 直接在内嵌的 iframe 中调用打印方法既可实现这个功能（一般用来打印图片，其他 dom 的话需要自己加上样式）

```js
/**
 * 打印dom
 * @param dom
 * @param isCenter
 */
export const printPageByDom = (dom = null, isCenter = true) => {
  if (!dom) return;
  const printFrameId = 'print-frame';
  let printFrame = document.getElementById(printFrameId);
  if (printFrame) {
    document.body.removeChild(printFrame);
  }
  printFrame = document.createElement('iframe');
  printFrame.name = printFrameId;
  printFrame.setAttribute('id', printFrameId);
  printFrame.setAttribute('width', '100%');
  printFrame.setAttribute('height', '100%');
  printFrame.setAttribute('style', 'position:absolute;width:0px;height:0px');
  if (isCenter) {
    const parentEl = document.createElement('div');
    parentEl.style.textAlign = 'center';
    // parentEl.style.height = "100vh";
    parentEl.style.display = 'flex';
    parentEl.style.alignItems = 'center';
    parentEl.style.justifyContent = 'center';
    parentEl.innerHTML = dom.outerHTML;
    printFrame.srcdoc = parentEl.outerHTML;
  } else {
    printFrame.srcdoc = dom.outerHTML;
  }
  document.body.appendChild(printFrame);
  printFrame.contentWindow.focus();
  printFrame.contentWindow.print();
};
```

持续记录中...

---

---
url: /docs/intro.md
---

## 关于博客

* 本博客现已使用 VitePress 搭建，并基于 `vitepress-theme-teek` 主题扩展
* VitePress 是一个基于 Vite 的静态站点生成器，使用 Markdown 编写并享受更快的开发体验
* Teek 在默认主题基础上增强，提供文章概览、分类/标签、归档、永久链接、卡片布局等博客能力
* 每个页面预渲染静态 HTML，加载后作为 SPA 运行
* 参考：
  * VitePress 官方文档：<https://vitepress.dev/>
  * Teek 主题文档（配置参考）：<https://vp.teek.top/>

## 快速上手

> 先看项目目录结构

### 项目基本结构

```txt
├── docs
│   ├── .vitepress/
│   │   ├── config.ts         # 站点配置，扩展 Teek
│   │   ├── teekConfig.ts     # Teek 主题配置（本项目使用）
│   │   ├── teekConfig.template.ts  # Teek 配置模板（参考用）
│   │   └── theme/            # 自定义主题增强（可选）
│   ├── @pages/               # Teek 功能页（文章总览/分类/标签/归档/登录/风险链接）
│   │   ├── archivesPage.md
│   │   ├── articleOverviewPage.md
│   │   ├── categoriesPage.md
│   │   ├── loginPage.md
│   │   ├── riskLinkPage.md
│   │   └── tagsPage.md
│   ├── index.md              # 首页（layout: home）
│   ├── intro.md              # 本页：博客说明
│   ├── personal.md           # 支持赞助页
│   └── public/               # 静态资源（favicon、图片、二维码等）
```

### 启动与构建

* 开发预览：`pnpm run docs:dev`
* 构建静态：`pnpm run docs:build`
* 本地预览构建产物：`pnpm run docs:preview`

构建输出目录：`docs/.vitepress/dist`

## 配置首页

本项目首页使用 VitePress 默认首页布局（支持 Teek 扩展样式）。在 `docs/index.md` 的 frontmatter 指定 `layout: home`，并配置 `hero` 与 `features`：

你也可以用 Teek 的 UI 能力优化首页视觉与交互（例如阅读设置按钮、动画等），示例已在 `docs/index.md` 中实现。

## 主题与站点配置

站点配置在 `docs/.vitepress/config.ts`，通过 `extends: teekConfig` 继承 Teek 主题配置，并配置导航、搜索、站点信息等：

Teek 配置在 `docs/.vitepress/teekConfig.ts`，用于控制主题增强能力：

```ts
// @ts-ignore
import { defineTeekConfig } from "vitepress-theme-teek/config";
import { version } from "vitepress-theme-teek/es/version";

export const teekConfig = defineTeekConfig({
  teekHome: false,        // 是否启用 Teek 的首页（博客风格）
  vpHome: true,           // 是否启用 VitePress 默认首页
  sidebarTrigger: true,   // 侧边栏折叠触发器
  author: { name: "fecym", link: "https://github.com/fecym" },
  footerInfo: {
    theme: { name: `Theme By Teek@${version}` },
    copyright: { createYear: 2025, suffix: "Teek" },
  },
  codeBlock: {
    copiedDone: (TkMessage) => TkMessage.success("复制成功！"),
  },
  articleShare: { enabled: true },
  vitePlugins: {
    sidebarOption: { initItems: true },
  },
});
```

更多可选配置请参考模板文件 `teekConfig.template.ts`（涵盖约 95% 的 Teek 配置项）。

## 功能页入口

* 站点已内置以下功能页（由 Teek 提供）：
  * 文章总览：`/@pages/articleOverviewPage` 或 `/articleOverview`
  * 分类页：`/@pages/categoriesPage` 或 `/categories`
  * 标签页：`/@pages/tagsPage` 或 `/tags`
  * 归档页：`/@pages/archivesPage` 或 `/archives`
  * 登录页：`/@pages/loginPage` 或 `/login`
  * 风险链接提示页：`/@pages/riskLinkPage` 或 `/risk-link?target=<链接>`

你可以在导航栏或首页中为这些页面添加入口链接。

## 注意事项

* `.vitepress/config.ts` 与主题配置修改后，通常可热更新；少数场景（比如部分路由/插件）可能需要重启开发服务
* Markdown 支持行号、容器、图片懒加载等已在配置中启用，可按需调整
* 文章/页面 frontmatter 可使用 `outline: false`、`sidebar: false`、`article: false` 控制页面行为（Teek 会对 `article` 做额外处理）

## 线上部署

* 构建：`pnpm run docs:build`，生成静态资源到 `docs/.vitepress/dist`
* 部署到任何静态服务器（Nginx/Apache/静态托管平台）都可直接使用 `dist` 内容

示例（部署到 GitHub Pages 的基本脚本）：

```sh
#!/usr/bin/env sh
set -e

pnpm run docs:build
cd docs/.vitepress/dist

git init
git add -A
git commit -m 'deploy'

# 发布到 https://<USERNAME>.github.io/<REPO>
git push -f git@github.com:<USERNAME>/<REPO>.git master:gh-pages

cd -
```

你也可以使用 GitHub Actions 进行自动化部署（推荐），参考 VitePress 官方文档的 CI/CD 指南。

## 评论与交互（可选）

* Teek 未内置评论系统，但可与社区评论服务搭配使用（如 Waline、Artalk 等），通过在页面或主题增强里加载对应客户端即可
* 建议选择兼容 Vue 3 的方案，并在文章页底部挂载评论组件
* 如果你需要，我可以按你选择的评论服务提供集成示例

:tada: :100:

---

---
url: /docs/@pages/archivesPage.md
---


---

---
url: /docs/02.服务端/service-conf.md
---

> 一年度的双十一到了，人人疯狂准备购买东西，对于我们来说心动的恐怕就是服务器了吧，这不，阿里云搞活动我顶不住了，200 多块钱 3 年，虽然我有一台还没有到期，但是我还是忍不住又购买了一台，把配置的整个过程整理下，以便下次用，毕竟记性不咋好，之前都配置过，这次配置还是遇到了各种问题...

## 安装 nginx

> 买了服务器，肯定先到控制台把服务器激活，然后重置登录密码，启动服务，然后怎么访问呢，那就先装个服务器呗，我选了 `nginx`，`nginx` 做内网转发还是挺不错的，现在也特别火，毕竟是轻量级的服务器。`nginx` 有什么好处我就不多说了，可以看看[这篇文章](https://www.cnblogs.com/wcwnina/p/8728391.html)讲解的很不错了

### 安装前检查

* 安装 `nginx` 有两种方法，一种是源码包安装一种是 `yum` 安装，`yum` 安装可能不是最新版本的，这里我们选择了`源码包`安装
* 首先由于 `nginx` 的一些模块依赖一些 `lib` 库，所以在安装 `nginx` 之前，必须先安装这些 `lib` 库，这些依赖库主要有 `g++`、`gcc`、`openssl-devel`、`pcre-devel` 和 `zlib-devel` 所以执行如下命令安装

```sh
  yum install gcc-c++
  yum install pcre pcre-devel
  yum install zlib zlib-devel
  yum install openssl openssl--devel
```

* 安装前，最好检查下是否有安装过 `nginx`，如果已经安装过先卸载

```sh
  # 检查是否安装过 nginx
  find -name nginx
  # 如果有，那么卸载掉
  yum remove nginx
```

### 下载并安装

* 我习惯在 `/usr/` 目录下新建一个 `download` 目录来保存自己下载的一些文件或者安装包之类的，所以我们新建这个文件夹，然后把下载的 `nginx` 放到这个目录下面，当然也有很多人喜欢放到 `/usr/src/` 目录下，这个看个人习惯
* 去官网下载最新的 `nginx`

```sh
  # 新建download目录
  mkdir /usr/download
  # 下载 nginx 到 download 目录，wget -P 是把文件下载到指定目录下
  wget -P /usr/download http://nginx.org/download/nginx-1.9.9.tar.gz
```

* 然后我们到 `download` 目录下解压 `nginx`

```sh
  tar -zxvf nginx-1.9.9.tar.gz
```

* 接下来我们开始安装，使用 `--prefix` 指定 `nginx` 的安装目录，`make` `make install` 安装
* `--prefix` 详细参数可参考[`这篇文章`](https://segmentfault.com/a/1190000007116797#articleHeader9)，我们就用默认的就好

```sh
  ./configure --with-http_ssl_module     # 默认安装在 /usr/local/nginx 目录下，--with-http_ssl_module 是为了以后配置 ssl
  make
  make install
```

* 如果没有报错，顺利完成后，看一下 `nginx` 的安装目录

```sh
  whereis nginx
```

* 此时我们就简单的安装完成了，然后我们把服务器跑起来，然后在浏览器中输入 `服务器的外网ip` 访问看是否成功了

```sh
  # 源码安装 nginx 的启动命令在下面的目录下
  cd /usr/local/nginx/sbin
  # 执行 nginx
  ./nginx
```

### 遇到的问题

* 在这一步我遇到了一个问题，`nginx` 报了一个错误，意思是说端口被占用了，我天，我刚买的服务器，`80` 端口就被占用了，于是我们查看下到底是谁占了我的 `80` 端口

```sh
  # 查看80端口被谁占用了
  netstat -anp | grep 80
```

* 执行以上命令后发现，`80` 端口被阿里云盾占用了，我也是第一次用阿里云的服务器，不知道会出现这种情况，杀死阿里云盾进程他还是会重启，如果再次遇到这个问题，可以看[这篇文章来解决](https://zhuanlan.zhihu.com/p/52758924)

* 解决了这个问题，`nginx` 终于跑起来了，可是后来发生的事情又是让我大跌眼睛

* 打开浏览器，输入服务器的 `ip`，正常的话，会有页面，`welcome to nginx` 我这里是浏览器访问失败了。

* 打开 `cmd`， `ping` 自己的 `ip`，可以 `ping` 通

* 使用 `curl` 却没有返回我们想要的东西，而是报 `Timed out`，很明显了，服务不通，却是想不到问题出在哪了，又重新捋了一遍，还是没有想到哪错了

* 后来想到会不会阿里云没有开放 `80` 端口，于是回到阿里控制台，才发现原来阿里云服务器，默认情况下是没有开发 `80`，我们需要手动开放这个端口，原来阿里云这里还给你防住了，于是我们开放 `80` 端口后可以访问了

* 需要在 云服务器 ECS -> 网络安全 -> 安全组 -> 配置规则 -> 添加安全组规则 -> 添加一条规则，开放我们想要开放的端口即可

### 添加环境变量

> 因为我们使用源码编译安装了 `Nginx`，管理 `Nginx` 非常的不方便，比如启动 `Nginx` 的命令就很长，所有我们把 `Nginx` 添加到环境变量来直接全局使用 `nginx` 命令，配置了环境之后更新 `nginx.conf` 后就可以直接 `nginx -s reload` 重启服务了

* Linux 添加环境变量比较简单

* 编辑 profile 文件

* 添加核心代码

* 保存退出，然后重载 profile 文件即可

```sh
  # 编辑 profile 文件
  vim /etc/profile
  # 添加以下代码
  export NGINX_HOME=/usr/local/nginx
  export PATH=$PATH:$NGINX_HOME/sbin
  # 保存退出后，重载文件
  source /etc/profile
  # 验证是否成功
  nginx -v
```

## 把 http 转成 https

> 为什么要把网站做成 https，https 和 http 有什么区别，https 和 ssl 之间的关系，这里不做任何解释，本文只记录作为一个外行人，如果搭建自己服务器的过程。

### 申请 SSL 证书

> SSL 证书是一种加密协议。大部分企业级的 SSL 证书都是需要收费的，而且对于个人开发者来说都不便宜（土豪随意）。个人使用的 SSL 证书，有一些是免费的，比如 Let's Encrypt、阿里云、腾讯云、又拍云等，都有提供免费证书的申请接口。这里说的阿里云的

* 打开 "管理控制台" --> "安全（云盾）" --> "SSL 证书"
* 点击 "购买证书" --> 选择 "免费版（个人）DV" --> "购买"
* 回到 SSL 证书 页面，我们开始验证我们购买的 免费版的 SSL，验证方法上面写的很详细，按着上面的来就可以了
* 验证完毕，等待审核成功，我们下载审核完成的证书
* 点击下载时会提醒你，选择对应的服务类型（Tomcat、Apache、Nginx、IIS 和其他）
* 这里我选择了 `Nginx`，点击下载旁边的帮助查看帮助文档，里面很详细的讲了你需要把下载的证书放到服务器的那个位置，然后如何配置 `Nginx`

### 配置 https

简单配置如下（nginx）

```sh
# 修改 nginx/conf/nginx.conf 文件
vim /usr/local/nginx/conf/nginx.conf
# 添加以下配置
# https nginx配置
server {
  listen       443;
  server_name  localhost;
  ssl on;
  # 证书的文件（绝对地址也可以）。
  ssl_certificate      xxx.pem;
  # 证书的密钥文件。
  ssl_certificate_key  xxx.key;
  ssl_session_cache    shared:SSL:1m;
  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
  ssl_session_timeout  5m;
  # ssl_ciphers  HIGH:!aNULL:!MD5;
  ssl_prefer_server_ciphers  on;
  location / {
    # 根目录地址
    root   /root/project/blog;
    index  index.html index.htm;
  }
}
# 保存并退出
:wq
# 重启nginx服务
nginx -s reload
```

* 此时发现可能还不能访问，有可能就是防火墙的问题，去阿里云官网配置一个 `443` 端口的安全组规则即可
* 如果想要服务的 `http` 自动转入 `https`，只需要在每一个 server 中加如一句话即可（慎用，因为你的其他域名可能不是 `https` 哦）

```sh
server {
  listen       80;
  server_name  localhost;
  # ...省略其他
  # 将所有 http 请求通过 rewrite 重定向到 https。
  rewrite ^(.*)$ https://$host$1 permanent;
  # ...省略其他
}
```

## 安装 node

> 为什么要安装 `node`，作为一个前端资深切图仔，我想不需要解释为什么了吧

### 安装 nvm

> `nvm` 作为 `node` 版本管理用具还是蛮好用的，我们可以先安装一个 `nvm` 再来下载不同的版本的 `node`

* 在 `nvm` 的 github 上面有讲解怎么下载，[传送门](https://github.com/nvm-sh/nvm)

```sh
  # 下载方法
  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash
```

* 下载完成之后，我们输入 `nvm list` 告诉你 nvm 命令不存在

- 解决方法：`source ~/.bashrc`
- 此时再次输入 `nvm list` 就会有打印了

### nvm 常用命令

* `nvm list` 或者 `nvm ls` 查看 `node` 的安装版本
* `nvm install 8.9.0` 安装一个 8.9.0 版本的 node
* `nvm use 8.9.0` 切换到 8.9.0 版本的 node
* `nvm uninstall 8.9.0` 删除 8.9.0 版本的 node
* `nvm ls-remote` 查看远程的 node 版本
* `nvm current` 查看当前正在使用的 node 版本
* 我们安装一个当前稳定版本 12.13.1 的 node 吧

```sh
  nvm install 12.13.1
```

## 安装 redis

> [`redis`](http://www.redis.cn/) 是一个数据库，读写特别快，我们经常把它用来做缓存，同时它支持多种数据结构，目前稳定版本是 5.0.5

### 安装

老规矩，下载解压然后安装

```sh
  # 下载 5.0.5 版本到 /usr/download 目录
  wget -P /usr/download http://download.redis.io/releases/redis-5.0.5.tar.gz
  # 解压
  cd /usr/download
  tar -zxvf redis-5.0.5.tar.gz
  # 编译
  cd redis-5.0.5
  make
  # 安装
  make install PREFIX=/usr/local/redis  # PREFIX后面是安装目录
```

### 连接 redis

此时进入 `/usr/local/redis` 目录下有个 `bin` 目录，执行 `./redis-server` 命令，看到如下图所示，说明安装成功

退出：`Ctrl + c` 退出

### 后台启动

* 把 `redis` 安装包目录下的 `redis.conf` 复制到 `/usr/local/redis/bin/` 目录下
* 然后修改 `redis.conf` 文件，把 `daemonize` 改成 yes

```sh
cp /usr/download/redis-5.0.5/redis.conf /usr/local/redis/bin/
vim /usr/local/redis/bin/redis.conf
# 把 daemonize 改成 yes，然后保存并退出
:wq
```

* 然后执行 `./redis-server redis.conf`，这样就后台启动了
* 执行 `ps aux | grep redis` 查看进程，`redis` 默认端口号是 `6379`

### 演示

* `redis` 分客户端（redis-cli）和服务端（redis-server）
* 启动 `redis` 服务端然后在启动客户端，就可以在客户端输入 `redis` 命令进行数据的存储了
* 启动客户端命令：`./redis-cli`；退出客户端命令：`quit`
* 整个启动命令如下：

```sh
  # 查看 redis 服务是否启动
  ps aux | grep redis
  # 返回进程 id 和端口号说明启动成功
  # 启动客户端
  ./redis-cli
  # 默认得到的是本机的ip:127.0.0.1:6379>
  ping
  # 返回 PONG
  # 退出进程
  quit
```

## 安装 MySQL

> `MySQL` 已经出到 8 版本了，并且 `8.0.18` 也在今年 `10-14` 号正式发布，那我们就安装这个版本的吧，之前我是用的 `5.7.20`，传说`8.0` 版本的 `MySQL` 比 `5.7` 版本的 `MySQL` 快 2 倍以上哦，那我们来爬下坑

### 安装前准备

老规矩，先把 `MySQL` 下载到 `/usr/download`，解压安装，开始安装前的准备工作

```sh
  # 8.0 的下载地址
  wget -P /usr/download https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.18-linux-glibc2.12-x86_64.tar.xz
```

* 服务器网速不好，400 多兆的东西需要下载 16h，换个方式下载吧，本地下载完传到服务器上吧
* 那样的话需要本地上传服务器，我们先安装个上传下载工具包 `rz` 及 `sz`，此时我们就可以 `rz` 进行上传文件了

```sh
  # 安装上传下载工具包
  yum install -y lrzsz
```

* 输入 rz 之后会有一个弹框提示你选择要添加的文件，只需要添加上你要上传的文件就可以了

* 我把 MySQL 的安装上传到了 `/usr/download` 文件夹下，此时我们解压到 `/usr/local` 目录下，然后重命名文件夹

* 解压过程中，发现报错了，原来我们下载了一个 `xz` 的压缩包，所以解压方式要换一下了

* 需要先把 `.xz` 结尾的文件先解压一次为 `.tar` 的打包格式，然后在用 `tar` 命令进行解压

* 好像也可以直接使用 `tar xvJf ***.tar.xz` 来解压

```sh
  # 在 /usr/download 目录下
  xz -d mysql-8.0.18-linux-glibc2.12-x86_64.tar.xz  # 运行该命令后会把源文件删除
  # 解压到 /usr/local/ 目录下
  tar -xvf mysql-8.0.18-linux-glibc2.12-x86_64.tar.xz -C /usr/local/
  # 重命名
  mv /usr/local/mysql-8.0.18-linux-glibc2.12-x86_64 /usr/local/mysql
  # 在 MySQL 根目录下新建一个文件夹 data，用于存放数据
  cd /usr/local/mysql && mkdir data
  # 创建 MySQL 用户组和 MySQL 用户
  groupadd mysql
  useradd -g mysql mysql
  # 改变 MySQL 目录权限
  chown -R mysql.mysql /usr/local/mysql/
  # 或者这么做
  # chown -R mysql .
  # chgrp -R mysql .
```

### 初始化

创建 `mysql_install_db` 安装文件，然后初始化

```sh
  # 创建 mysql_install_db 安装文件
  mkdir mysql_install_db
  chmod 777 ./mysql_install_db
  # 初始化数据库
  ./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
  # 报错了？报错了看下边
```

### 遇到的问题

* 初始化的时候报了一个错误 `./bin/mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory`
* 这个问题是缺少安装包 `libaio` 和 `libaio-devel`，安装即可

```sh
  # 自动安装这两个包
  yum install libaio*
  # 然后在执行 初始化数据库命令
  ./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
```

* 此时看到下面这句话，说明初始化成功了
* 并且为你生成了临时的 `MySQL` 登录密码，一定要记下来，我们需要登录进 `MySQL`，然后修改密码

### 配置 my.cnf

```sh
  # 接下来按照我的做
  cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
  # 修改my.cnf文件
  vim  /etc/my.cnf
  # 修改为下图所示
```

### 建立 MySQL 服务

```sh
  # 注意这里是 mysql 不是 mysqld 哦
  cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql
  # 赋予可执行权限
  chmod +x /etc/init.d/mysql
  # 添加到系统服务
  chkconfig --add mysql
  # 再来 mysqld 的
  cp -a /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
  chmod +x /etc/rc.d/init.d/mysqld
  chkconfig --add mysqld
  # 检查是否生效
  chkconfig  --list mysqld
```

### 配置环境变量

老规矩，编辑 `/etc/profile` 文件，添加两句话

```sh
  vim /etc/profile
  # 最底部添加以下两句话
  export PATH=$PATH:/usr/local/mysql/bin:/usr/local/mysql/lib
  export PATH
  # 保存并退出
  :wq
  # 重启环境变量让其立即生效
  source /etc/profile
  # 启动MySQL服务
  service mysql start
```

### 修改密码

```sh
  mysql -uroot -p
  # 提示你输入密码或者报错
```

* 报了一个错：`log-error set to '/var/log/mariadb/mariadb.log', however file don't exists. Create writable for user 'mysql'.`
* 这个是权限问题，应该是没有 `/var/log/mariadb/mariadb.log` 这个路径
* 那我们就创建, 并给 `mysql` 用户授权即可

```sh
  mkdir /var/log/mariadb
  touch /var/log/mariadb/mariadb.log
  chown -R mysql:mysql  /var/log/mariadb/
  # 然后查看 mysql 命令
  mysql --version     # 返回以下命令说明可以了
  # mysql  Ver 8.0.18 for linux-glibc2.12 on x86_64 (MySQL Community Server - GPL)
  # 此时我们再次登录
  mysql -uroot -p
  # 第一次输入临时密码，进去后修改登录密码
  # 修改登录密码，MySQL 语法都要在尾部加上 ; 哦
  set password="你的密码";
  flush privileges;
  # 返回 OK, 0 rows affected (0.00 sec) 说明语句更新成功了
```

### node 连接 MySQL8 报错

> 把 MySQL 安装完毕，把之前的数据导过来，node 项目跑起来，发现 node 连接 MySQL 的时候报错了 `Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client`

#### 出错原因：

 导致这个错误的原因是，目前，最新的 `mysql模块` 并未完全支持 `MySQL 8` 的 `caching_sha2_password` 加密方式，而 `caching_sha2_password` 在 `MySQL 8` 中是默认的加密方式。因此，下面的方式命令是默认已经使用了 `caching_sha2_password` 加密方式，该账号、密码无法在 `mysql模块` 中使用。

#### 解决方法：

 解决方法是从新修改用户 root 的密码，并指定 `mysql模块` 能够支持的加密方式：

```sql
  ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你要改的密码'
```

 上述语句，显示指定了使用 `mysql_native_password` 的加密方式。这种方式是在 `mysql模块` 能够支持。

---

---
url: /docs/03.工具/Npm 相关/npm-cli.md
---

> 之前 58 面试被问到一个问题，请你说一下做一个脚手架整个流程，当时因为自己只是为了满足工作中的需求，直接用了别人的脚手架搭建现成的项目，根本没有研究过那些脚手架是怎么做出来的，他的整个流程，思路是什么。当时那么面试官跟我说作为一个高级工程师，我们要做的不只是满足于现在的需求，而是简化整个开发流程，做出一些比较优秀的工作来方便其他人来提高整个团队的效率，那时候我才知道自己差在哪了。前段时间在自己闲的时候我也尝试着做了一个自己的脚手架，一个基于自己这个博客项目的脚手架。这里来记录下当初的整个流程。

## 思考

要开发一个脚手架需要捋清楚，脚手架是如何工作的？拿 `vue-cli` 来说，`vue-cli` 是将项目的模板放在 git 上面，执行 cli 命令的时候，再根据用户的交互选择不同的模板，然后经过模板引擎渲染出来生成项目。这样做将模板与脚手架分离，可以各自维护。

那我们先准备两套项目，一套作为自己的脚手架项目，一个作为模板

回想在使用 `vue-cli` 的时候，我们直接执行 `vue create projetcName` 然后进行一些交互便可以生成一个项目，生成的项目会拿到我们与用户交互的时候一些配置，会改变我们想要改变的一些文件。那我们就需要做完自己的脚手架后需要生成一个可以直接执行的环境变量，然后可以与用户直接交互，所以我们需要一个与用户交互的工具。我们既然有模板文件，那么就需要下载这个模板，模板一般放在 github 上，所以我们需要一个下载 github 上文件的工具

此时整理一下需要的几个核心的工具包：`commander（解析命令和参数）、inquirer（用户做交互）、download-git-repo（下载远程的模板）、handlebars（模板引擎）`

还需要一些其他工具来协助开发：`ora（提供下载动画）、chalk（给字体添加颜色）、log-symbols（在终端显示不同的图标）`

## 初始化项目

首先创建一个空项目，命名为 cym-blog（名字随便起就行），执行 `npm init -y` 生成一个 `package.json` 文件。最后安装上面需要用到的依赖。

### bin 字段

```sh
  # 为什么是 -S？因为这些依赖我们既是发布到 npm 之后也是依赖这些工具的
  npm i -S commander inquirer download-git-repo handlebars ora chalk log-symbols
```

然后我们在 package.json 文件中要加入 `bin` 字段

```json
  {
    "name": "cym-blog",
    "version": "1.0.0",
    ...
    "bin": {
      "cym-blog": "index.js"
    },
    ...
  }
```

### index.js 的写法

在项目根目录新建一个 `index.js` 文件作为主入口文件，我们需要在这个文件的第一行加入 `#!/usr/bin/env node` 指定当前脚本由 `node.js` 进行解析，不同的系统默认执行的是不一样的，比如说 Linux 默认执行就是 bash，下面是 `index.js` 的内容

```js
  #!/usr/bin/env node
  require('./src/init')
```

对了我们新建一个 src 目录来开发我们的核心逻辑

## 处理命令行

### commander

[`commander.js`](https://github.com/tj/commander.js/blob/master/Readme_zh-CN.md) 是 `github` 上一位神级人物 [`tj`](https://github.com/tj) 开发的模块，`commander.js` 可以自动的解析命令和参数，合并多选项，处理短参，等等，功能强大，上手简单。简单用法如下：

```js
program
  // 执行命令传入参数
  .command(`init <option>`)
  .action(option => {
    // 这里可以捕获到传入的参数
    console.log(option)
  })
// 可以直接执行 -v 获取当前版本号
program.version('1.0.0', '-v, --version').parse(process.argv)
```

### 命令行交互

在用户执行 `init` 命令后，向用户提出问题，接收用户的输入并作出相应的处理。命令行交互利用 `inquirer` 来实现，代码如下

```js
inquirer
  .prompt([
    {
      name: 'description',
      message: '请输入项目描述：'
    },
    {
      name: 'author',
      message: '请输入作者姓名：'
    }
  ])
  .then(answers => {
    // 得到与用户的交互逻辑
    console.log(answers)
  })
```

### 视觉美化

在用户输入之后，开始下载模板，下载过程中我们可以使用 `ora` 模块来提示用户正在下载，下载完成也提示用户

```js
const ora = require('ora')
const loading = ora('downloading template ...')

loading.start()
//download
loading.succeed() //或 loading.fail();
```

## 处理模板

`download-git-repo` 是一个可以从远程仓库下载一个项目的插件，我们可以封装这个插件来下载我们的模板文件

### 封装模板下载逻辑

`download-git-repo` 用户也挺简单，用法如下：

```js
// download.js
const downloadGit = require('download-git-repo')
const templateHerf = `https://github.com/fecym/cym-blog-template.git`

module.exports = function(projectName) {
  return new Promise((resolve, reject) => {
    downloadGit(
      `direct:${templateHerf}#master`,
      projectName,
      { clone: true },
      err => {
        if (err) reject(err)
        resolve(true)
      }
    )
  })
}
```

### 下载模板

完整的下载逻辑如下，加上 Terminal 的美化

```js
// 测试 download.js
const ora = require('ora')
const spinner = ora('downloading template ...')
const symbols = require('log-symbols')
const chalk = require('chalk')
const downloadFn = require('../src/utils/download')
// 测试下载名
const projectName = 'test-name'
// 项目开始下载
spinner.start()
downloadFn(projectName)
  .then(_ => {
    spinner.succeed()
    console.log(symbols.success, chalk.green('下载成功'))
  })
  .catch(err => {
    spinner.fail()
    console.log(symbols.error, chalk.red(err))
    process.exit(0)
  })
```

## 修改模板元信息

下载完模板之后，根据用户与命令行的交互信息，修改我们的模板文件，然后重写 package.json

```js
downloadGit(name)
  .then(_ => {
    spinner.succeed()
    // 处理元信息
    const meta = {
      name,
      description: answers.description,
      author: answers.author
    }
    // 处理模板文件
    const templateName = path.resolve(__dirname, './utils/template.json')
    // 获取到一个 buffer 需要转字符串
    const templateContent = fs.readFileSync(templateName).toString()
    // 填充模板信息
    const result = handlebars.compile(templateContent)(meta)
    // 重写 package.json
    fs.writeFileSync(`${name}/package.json`, result)
    spinner.succeed()
    console.log(symbols.success, chalk.green('项目初始化完成'))
    console.log(symbols.success, chalk.green('执行以下命令运行您的项目'))
    console.log(symbols.info, chalk.green(`cd ${name}`))
    console.log(symbols.info, chalk.green(`npm install`))
    console.log(symbols.info, chalk.green(`npm start`))
    process.exit(0)
  })
  .catch(err => {
    spinner.fail()
    console.log(symbols.error, chalk.red(err))
    process.exit(0)
  })
```

## 完整代码

整个流程基本完毕，完整代码请移步[`这里`](https://github.com/fecym/cym-blog.git)

该脚手架已发布 `npm`，包名 [`cym-blog`](https://www.npmjs.com/package/cym-blog)

## 参考链接

1. [手摸手教你撸一个脚手架](https://juejin.im/post/5d37d982e51d45108c59a635)

2. [基于 node.js 的脚手架工具开发经历](https://juejin.im/post/5a31d210f265da431a43330e)

3. [使用 Node.js 构建交互式命令行工具](https://zhuanlan.zhihu.com/p/53902095)

---

---
url: /docs/02.服务端/node/crypto.md
---

## crypto

crypto 是 node 中实现加密解密的模块，使用 OpenSSL 类库作为内部实现加密解密的手段

## 散列(哈希)算法

散列算法也叫哈希算法，用来把任意长度的输入换成固定长度的输出，常见的有 md5、sha1、sha256 等

散列算法好很多中，在 node 中可以使用 `crypto.getHashes()` 获取到 node 所支持的所有 hash 类型

### 特点

* 相同的输入会产生相同的输出
* 不同的输出会产生不同的输出
* 任意的输入长度输出长度都是相同的
* 不能从输出推算输出的值（不能反解）

### 用途

* 用来校验要下载的文件是否被改的
* 用来对数据库中保存的密码进行加密（不泄露密码）

### 语法说明

```js
const crypto = require('crypto');
// crypto.createHash 接受一个散列算法的类型，比如 md5、sha1 等
const md5 = crypto.createHash('md5');
// update 方法用来指定要加密的值，可以多次添加
md5.update('hello');
md5.update('world');
// 输出 md5 的值，可以执行类型
md5.digest('hex');
// fc5e038d38a57032085441e7fe7010b0，md5是32位的
// fc5e038d38a57032085441e7fe7010b0，sha1是40位的
```

## HMAC 算法

HMAC 算法将散列算法与一个密钥结合在一起（加盐），以阻止对签名完整性的破坏

HMAC 加密需要生成一个密钥，然后与散列算法组合，生成的密钥是随机的，就相当于一个随机字符串与你要加密的内容组合在一起在进行加密，这个被称为加盐

### 语法

hmac 用法和 hash 加密差不多

```js
const hmac = crypto.createHmac(algorithm, key);
hamc.update(data);
```

* algorithm 是一个可用的摘要算法，比如 sha1、md5、sha256 等
* key 是一个字符串，用于指定一个 pem 格式的密钥，也可以写一个随机字符串，但是一般我们会生成一个密钥，不会去写一个字符串

```js
const hmac = crypto.createHmac('sha1', 'abc');
hmac.update('123');
hmac.digest('hex');
```

### 生成私钥

```sh
  # 生成密钥命令
  openssl genrsa -out rsa_private.key 1024
```

### 示例

```js
const crypto = require('crypto');
const path = require('path');
const fs = require('fs');
const key = fs.readFileSync(path.join(__dirname, './rsa_private.key'));
// createHmac 方法接受两个参数 algorithm 和 密钥
const hmac = crypto.createHmac('sha1', key);
hmac.update('123');
const result = hmac.digest('hex');
console.log(result);
```

## 对称加密

上面所提到叫做摘要算法，摘要只能进行校验对不对，但是不可以反向解密，加密是可以解密的

blowfish 算法是一种对称加密算法，对称呢就是加密和解密使用同一个密钥

### 用法示例

对称加密可解密，加密解密对应不同的 api

* 加密：`crypto.createCipher('blowfish', key)`
* 解密：`crypto.createDecipher('blowfish', key)`
* 加密值： `cipher.update(str, 'utf8')`
* 输出值：`cipher.final('hex')`

示例：

```js
const crypto = require('crypto');
const path = require('path');
const fs = require('fs');

const key = fs.readFileSync(path.join(__dirname, './rsa_private.key'));
const str = 'cym';

// 加密
const cipher = crypto.createCipher('blowfish', key);
cipher.update(str, 'utf8');
// 输出加密后的结果
const encry = cipher.final('hex');
console.log(encry);

// 解密
const decipher = crypto.createDecipher('blowfish', key);
decipher.update(encry, 'hex');
const deEncry = decipher.final('utf8');
console.log(deEncry);
```

## 非对称加密

## 签名

---

---
url: /docs/04.经典摘录/空性与妙用.md
---

## 金刚经的那句话

> **凡所有相，皆是虚妄。**
>
> 虚妄不是说不存在，而是说太唯心。

***

> 举个例子：\
> 你面前有一个杯子——
>
> * 你喝水，它就是 **水杯**；
> * 你抽烟，它就是 **烟灰缸**；
> * 你插花，它就是 **花瓶**；
> * 你插笔，它就是 **笔筒**；
> * 你愤怒时，它就是 **一地的玻璃渣**。

***

> 杯子本身，其实它什么也不是，这叫 **空性**。
>
> 你用它来干什么，它就是什么，这叫 **妙用**。
>
> 你非要坚持，它一定就是杯子，这叫 **住相**。
>
> 为此，你不惜和别人争论抬杠，这叫 **我执**。
>
> 结果，你抬杠有了情绪和谩骂，这叫 **烦恼**。
>
> 最后，你对这个人产生了反感，这叫 **偏见**。

***

> 懂得了这些，就懂了一切 **唯心造**。
>
> 然后，也就明白了：\
> 这个世界，其实没有别人，只有你自己。
>
> 你在时，世界就跟着存在；\
> 你走后，世界就跟着消失。

***

> 那些别人、那些纠缠、那些执着、那些控制，\
> 不过都是你内心，跟自己起的各种纠缠。

***

> 于是，你就又明白了那句话：
>
> **本来无一物，何处惹尘埃。**

---

---
url: /docs/01.前端/04. 浏览器/cache.md
---

> `web` 缓存是只一个 web 资源（html、图片、js、css、数据等）存在于 web 服务器和浏览器之间的副本

缓存会根据进来的请求保存输出内容的副本；当下一个请求来临的时候，如果是相同的 `URL`，缓存会根据缓存机制决定是直接使用副本响应请求还是向源服务器再次发送请求。比较常见的。

比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 `URL` 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。至于浏览器和网站服务器是如何标识网站页面是否更新的机制，将在后面介绍。

缓存可以减少网络带宽的消耗、减低服务器的压力、减少网络延迟，加快页面打开速度

这里主要记录浏览器缓存。

## Memory Cache

`memory cache` 是内存中缓存，就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而是直接从内存中读取。从效率上来讲它是最快的，但也是存活时间最短的。

几乎所有的网络请求都会被浏览器自动加入到 `memory cache` 中，所以可能数量很多，所以注定了 `memory cache` 存活时间短；

当一个 tab 页签被关闭之后那么 `memory cache` 也就失效了，极端情况下（例如一个页面的缓存就占用了超级多的内存）那可能在 tab 页签没关闭之前，排在前面的缓存就已经失效了。

`memory cache` 是浏览器命中的第一个缓存

## Disk Cache

`disk cache` 是储存在磁盘中的缓存，从存储效率上来讲是比内存慢的，但比起网络请求还是快了不少的。绝大部分的缓存都来自 `disk cache`，他的优势在于存储容量和存储时长。

那么浏览器是如何决定将资源放进的内存还是硬盘？

* Base64 格式的图片，几乎永远可以被塞进 `memory cache`
* 比较大的 js、css 文件会被直接丢到磁盘，反之丢进 `memory cache`
* 内存使用率比较高的时候，文件优先进入 `disk cache`

## Service Worker Cache

`Service Worker` 是独立于主线程之外的一个线程，借鉴了 `Web Worker` 的思路。由于他脱离了浏览器的窗体，所以无法直接访问 `dom`。

虽然如此，但他仍然能够帮助我们完成很多有用的功能，比如离线缓存、消息推送、网络代理等。离线缓存就是 `Service Worker Cache`

在浏览器的中打开控制台 --> Application 面板 --> Cache --> Cache Storage 中可以找到存在 `Service Worker Cache` 中的数据。

出于安全问题的考虑，`Service Worker` 只能被使用在 `https` 或者 本地的 `localhost` 环境下

## HTTP Cache

`HTTP Cache` 分为强缓存和协商缓存。优先级较高的是强缓存，在命中强缓存失败的情况下才会走协商缓存，看一张图以及下面的解释来理解一下 `HTTP Cache`

## 强缓存

强缓存是利用 http 头中的 `Expires` 和 `Cache-Control` 两个字段来控制。

在强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。

### Expires

这是 `http 1.0` 的字段，表示缓存到期时间，是一个绝对的时间（当前时间 + 缓存时间）

```sh
  Expires: Mon, 23 Dec 2019 10:15:36 GMT
```

在响应消息头中设置这个字段后，就可以告诉浏览器，在未过期之前不需要再次请求。

但是，这个字段设置的时候有两个缺点：

1. 由于是绝对时间，用户可能修改自己本地时间，从而导致浏览器缓存实效。即使用户没有修改，服务器时间和浏览器时间可能时间不一致，致使缓存实效
2. 写法复杂，表示时间的字符串多个空格，少个字母，都会导致非法属性从而设置失效

### Cache-Contorl

已知 `Expires` 的缺点后，在 `http 1.1` 版本中新增了 `Cache-Control` 字段，该字段表示缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求

两者的区别就是 `Expires` 是绝对时间，而 `Cache-Control` 是相对时间。`Cache-Control` 格式如下：

```sh
  # 在 30 天内有效，max-age 后面是个秒数
  Cache-control: max-age=2592000
```

下面记录下 `Cache-Control` 字段的常用值：

* **max-age**：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与 `Expires` 相反，时间是相对于请求的时间。
* `public` 与 `private` 是针对资源是否能够被代理服务缓存而存在的一组对立概念。
  * **public**：所有内容都将被缓存（客户端和代理服务器都缓存）
  * **private**：该资源只能被浏览器缓存。`pricate` 是默认值
* `no-cache` 和 `no-store`：
  * **no-cache**：绕开了浏览器，跳过当前缓存，发送 `http` 请求，也就是直接进行协商缓存。
  * **no-store**：不使用任何缓存。

若 `Expires` 和 `Cache-Control` 同时存在，那么以 `Cache-Control` 为主

### 缓存位置

以本博客为例，看看缓存保存在了哪里，下图是第一次进来网站，然后刷新一次后的效果

其中我们可以看到状态码有 `200` 和 `304`，`200` 后 `size` 属性中有 `memory cache`（以前叫做 `from memory cache`）和 `disk cache`（以前叫做 `from disk cache`）标明了，该缓存来自内存还是硬盘，状态码 `304` 表示走了协商缓存

当我们关闭了博客再次打开之后，就会看到大部分的 `size` 字段变成了 `disk cache`，说明关闭页面后内存中保存的数据就没有了，会被放到磁盘中

第一次打开博客之后，所有的请求都是都是 `200` 但是 size 字段是文件真实的大小，说明没有走缓存，`base64` 例外，所有的 base64 格式的图片几乎永远可以被塞进 `memory cache` 中

## 协商缓存

当强缓存实效（超过超过规定时间）时，就会使用协商缓存了。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，由服务器来决定缓存是否有效。

如果服务端的提示资源未被改动（`Not Modified`），资源会被重定向到浏览器缓存，这种情况下的对应的状态码是 `304`

协商缓存判断是根据两组字段来判断：`Last-Modified & If-modified-Since` 和 `Etag & If-None-Match`

### Last-Modified 和 If-modified-Since

`Last-Modified` 是服务器相应请求时，返回资源文件在服务器最后的修改时间，如图所示

`If-Modified-Since` 则是客户端再次发送请求时，携带上上次请求返回的 `Last-Modified` 的内容，通过这个字段来告诉服务器该资源上次请求返回的最后修改的时间。

服务器收到请求后发现请求头中有 `If-Modified-Since` 字段，会根据 `If-Modified-Since` 字段值与该资源在服务器中的最后修改时间做判断，若服务器资源最后修改时间大于 `If-Modified-Since` 值，则重新返回资源，状态码为 `200`；否则，返回 `304`，表示资源未更新，资源会被重定向到浏览器缓存

但是他还是有一定缺陷的：

* 如果资源更新时间是秒以下为单位的，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
* 如果文件是服务器动态生成的，那么该方法的更新永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用

完整代码实现如下：

```js
const http = require('http')
const fs = require('fs')
const path = require('path')
const url = require('url')
const PORT = 3456

http
  .createServer((req, res) => {
    const pathname = url.parse(req.url).pathname
    if (pathname === '/') {
      const filename = path.resolve(__dirname, './files/1.txt')
      fs.stat(filename, (err, stat) => {
        if (err) {
          res.statusCode = 404
          return res.end('Not Fount')
        }
        if (stat.isFile()) {
          const timeGMT = stat.ctime.toGMTString()
          console.log(timeGMT)
          if (req.headers['if-modified-since'] === timeGMT) {
            console.log('文件未改动')
            res.statusCode = 304
            return res.end()
          }
          // 让浏览器以 utf-8 格式解析文本
          res.setHeader('Content-Type', 'text/plain; charset=utf-8')
          res.setHeader('Last-Modified', timeGMT)
          console.log('没有走缓存')
          fs.createReadStream(filename).pipe(res)
        }
      })
    }
  })
  .listen(PORT)
```

### Etag 和 If-None-Match

`Etag` 是服务器响应请求时，返回资源文件的唯一标识（由服务器生成），同时也解决了 `Last-Modified` 存在的缺陷，如图：

`If-None-Match` 是浏览器再次发送该请求时，携带上次请求返回的唯一表示（`Etag`）值，通过此字段告诉服务器该资源上次请求返回的唯一标识。

服务器收到请求后发现请求头中 `If-None-Match` 字段，会根据 `If-None-Match` 的字段值与该资源在服务器的 `Etag` 值作对比，如果一样则返回 `304`，代表资源未更新，继续使用缓存；不一样则重新返回文件，状态码 `200`

`Etag` 的优先级高于 `Last-Modified`，同时存在则取 `Etag`

完整代码实现如下：

```js
const http = require('http')
const fs = require('fs')
const path = require('path')
const url = require('url')
// hash 加密用
const crypto = require('crypto')
const PORT = 6543

http
  .createServer((req, res) => {
    const pathname = url.parse(req.url).pathname
    if (pathname === '/') {
      const filename = path.resolve(__dirname, './files/etag.txt')
      fs.stat(filename, (err, stat) => {
        if (err) {
          res.statusCode = 404
          return res.end('Not Fount')
        }
        if (stat.isFile()) {
          // Etag 的实体内容，根据文件的内容计算出一个唯一的 hash 值
          const md5 = crypto.createHash('md5')
          const rs = fs.createReadStream(filename)
          // 要先写入响应头在写入响应体
          const arr = []
          rs.on('data', chunk => {
            md5.update(chunk)
            arr.push(chunk)
          })
          rs.on('end', () => {
            const etag = md5.digest('base64')
            if (req.headers['if-none-match'] === etag) {
              console.log(req.headers['if-none-match'])
              console.log('文件未改动')
              res.statusCode = 304
              return res.end()
            }
            console.log('没有走缓存')
            // 让浏览器以 utf8 格式解析文本
            res.setHeader('Content-Type', 'text/plain; charset=utf8')
            res.setHeader('Etag', etag)
            res.end(Buffer.concat(arr))
          })
        }
      })
    }
  })
  .listen(PORT)
```

### node 实现缓存

完整代码，已上传 [`github`](https://github.com/fecym/node-cache.git)

## Push Cache

`Push Cache` 是指 HTTP2 在 `server push` 阶段的缓存

* `Push Cache` 是缓存的最后一道防线。浏览器只有在 `Memory Cache`、`HTTP Cache` 和 `Service Worker Cache` 均未命中的情况下才会去询问 `Push Cache`
* `Push Cache` 是一种存在于会话阶段的缓存，当会话结束的时候，缓存也随之释放
* 不同的页面只要共享了一个 `HTTP/2` 连接，那么它们就可以共享一个 `Push Cache`
* `Push Cache` 可以参考[这篇文章](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)

## 参考文章

1. [能不能说一说浏览器缓存?](https://juejin.im/post/5df5bcea6fb9a016091def69#heading-0)
2. [Service Worker —这应该是一个挺全面的整理](https://juejin.im/post/5b06a7b3f265da0dd8567513)
3. [彻底理解浏览器的缓存机制](https://juejin.im/entry/5ad86c16f265da505a77dca4)
4. [一文读懂前端缓存](https://juejin.im/entry/5baef5cef265da0ad13b8c01)
5. [五个维度再谈前端性能优化](https://mp.weixin.qq.com/s/eU4nLNhAdtjvLEX90qvn5w)
6. [node 实战前端缓存总结](https://juejin.im/post/5ca083eaf265da30bd3e459b)

---

---
url: /docs/01.前端/04. 浏览器/website-render.md
---

## 简单流程

> 从输入 url 到页面呈现会经过几个步骤：DNS 解析 -> TCP 连接 -> 发送 HTTP 请求 -> 服务器处理请求并返回 -> 浏览器解析渲染页面 -> TCP 断开连接

## URL

* **URL**（*Uniform Resource Locator*），统一资源定位符，用于定位互联网上资源，俗称网址
* 一个基本的**URL**由以下几部分组成
  1. 协议部分（*protocol*）：常见的协议有 *http、https、ftp、file*，其中最常见的类型是 *http*，而 *https* 则是进行加密的网络传输
  2. 域名部分（*domain*）：该 URL 的域名部分为 *www.aspxfans.com*。一个 URL 中，也可以使用 IP 地址作为域名使用，*www* 也是 *http* 的默认主机（*host*）
  3. 端口部分（*port*）：跟在域名后面的是端口，域名和端口之间使用:作为分隔符，端口省略则默认为*80*
  4. 目录部分（*pathname*）：定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）
  5. 参数部分（*search*）：从?开始到#为止之间的部分为参数部分，又称搜索部分、查询部分，参数可以允许有多个参数，参数与参数之间用&作为分隔符。

## 域名解析（DNS）

> 在浏览器输入网址后，首先要经过域名解析，因为不可能直接通过域名找到对应的服务器，而是要通过 *IP* 地址

### 什么是域名解析

> *DNS* 协议提供通过域名查找 *IP* 地址，或者逆向从 *IP* 地址反查询域名的服务。*DNS* 是一个网络服务器，我们的域名解析简单来说就是在 *DNS* 上记录一条信息
> 例如：baidu.com 220.114.23.56（服务器外网 IP 地址）80（服务器端口号）

### 浏览器如何通过域名去查询 URL 对应的 IP

* 浏览器缓存：浏览器会按照一定的频率缓存 *DNS* 记录（缓存时间比较短，大概只有 1 分钟，且只能容纳 1000 条缓存）
  * chrome 的 dns 缓存：chrome://net-internals/#dns

* 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。
  * 如果在 *Windows* 系统的**DN**S 缓存也没有找到，那么尝试读取**hosts**文件
  * 介绍下**hosts**：
  * 为了提高对经常访问的网络域名的解析效率，可以通过利用 *hosts* 文件中建立域名和 IP 的映射关系来达到目的
  * 在进行 *DNS* 请求以前，*Windows* 系统会先检查自己 *hosts* 文件中是否有这个网路域名映射关系，*hosts* 文件请求级别高于 *DNS*
  * *hosts* 文件位置：C:\Windows\System32\drivers\etc

* 路由缓存：路由器中也有 *DNS* 缓存

* **ISP**的**DNS**服务器：**ISP**是互联网服务提供商（*Internet Service Provider*）的简称，**ISP**有专门的**DNS**服务器应对**DNS**请求

* 根服务器：**ISP**的**DNS**还找不到的话，就会向根服务器发起请求，进行递归查询（*DNS* 服务器先问根域名服务器 主域(com) 名服务器的 IP 地址，然后在问子域的 IP 地址）

* 浏览器通过向**DNS**服务器发送域名，**DNS**服务器查询到与域名相对应的**IP**地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给服务器

## TCP 三次握手

> 在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。
>
> * 客户端发送一个带**SYN=1，Seq=X**的数据包到服务器（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
> * 服务器返回一个带**SYN=1，ACK=X+1，Seq=Y**的响应以表示确认信息（第二次握手，由服务器发起，告诉浏览器我准备接收了，你赶紧发送吧）
> * 客户端再回传一个带**ACK=Y+1，Seq=Z**的数据包，代表握手结束（第三次握手，由浏览器发送，告诉服务器，我马上就发送了，准备接收吧）
> * 为什么要三次握手？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

* **客户端**首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示**客户端**自己的初始序号（seq = 0 就代表这是第 0 号帧），这时候**客户端**进入 syn\_sent 状态，表示客户端等待服务器的回复
* **服务器**监听到连接请求报文后，如同意建立连接，则向**客户端**发送确认。TCP 报文首部中的 SYN 和 ACK 都置 1 ，ack = x + 1 表示期望收到对方下一个报文段的第一个数据字节序号是 x+1，同时表明 x 为止的所有数据都已正确收到（ack=1 其实是 ack=0+1,也就是期望客户端的第 1 个帧），seq = y 表示**服务器**自己的初始序号（seq=0 就代表这是服务器这边发出的第 0 号帧）。这时服务器进入 syn\_rcvd，表示服务器已经收到**客户端**的连接请求，等待**客户端**的确认。
* **客户端**收到确认后还需再次发送确认，同时携带要发送给**服务器**的数据。ACK 置 1 表示确认号 ack= y + 1 有效（代表期望收到服务器的第 1 个帧），**客户端**自己的序号 seq= x + 1（表示这就是我的第 1 个帧，相对于第 0 个帧来说的），一旦收到**客户端**的确认之后，这个 TCP 连接就进入 Established 状态，就可以发起 http 请求了。

## 发送 HTTP 请求

> TCP 三次握手结束后，开始发送**HTTP**请求报文
> 请求报文由请求行、请求头、请求体三部分组成

* 请求行包含请求方法、url、协议版本
  * 请求方法包含 8 中：*GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE*
  * url 就是请求地址：由 <协议>：//<主机>：<端口>/<路径>?<参数> 组成
  * 协议版本就是 *http* 版本号
* 请求头包含附加信息，由键值对组成，每行一对
* 请求体，就是前端的请求参数，不是所有的请求都具有请求数据的

## 服务器处理请求并返回 HTTP 报文

* 响应报文由响应行、响应头、响应主体三个部分组成
* 响应行包括：协议版本、状态码、状态描述
  * 状态码规则：
  * 1xx：指示信息--表示请求已接收，继续处理
  * 2xx：成功--表示请求已被成功接收、理解、接受
  * 3xx：重定向--要完成请求必须进行更进一步的操作
  * 4xx：客户端错误--请求有语法错误或请求无法实现
  * 5xx：服务器端错误--服务器未能实现合法的请求
* 响应头包含响应报文的附加信息，由键值对组成
* 响应体就是后台返回的数据，并不是所有响应报文都有响应数据
* 服务器端 WEB 程序接收到 http 请求以后，就开始处理该请求，处理之后就返回给浏览器 html 文件。

## 浏览器解析渲染页面

> 浏览器拿到响应后来的 **HTML** 后，就开始解析其中的 html 代码，浏览器解析渲染页面分为一下五个步骤：
>
> * 根据 HTML 解析出 DOM 树
> * 根据 CSS 解析生成 CSS 规则树
> * 根据 DOM 树和 CSS 规则树生成渲染树
> * 根据渲染树计算每个节点的信息
> * 根据计算好的信息绘制页面

### 根据 HTML 解析出 DOM 树

* 根据 HTML 的内容，讲标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即构建完当前节点的所有子节点，在构建下一个兄弟节点
* 在读取 HTML 文档，构建 DOM 树的过程中，若遇到**script**标签，则 DOM 树的构建就会暂停，直到脚本执行完毕

### 根据 CSS 解析生成 CSS 规则树

* 解析 CSS 规则树时，**js**的执行将暂停，直至 CSS 规则树就绪。[查看细节](/views/basis/css.html#css-加载会造成阻塞吗)
* 浏览器就 CSS 规则树生成之前不渲染

### 根据 DOM 树和 CSS 规则树生成渲染树

* DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。
* 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。

### 根据渲染树计算每一个节点的信息

* 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸
* 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。

### 根据计算好的信息绘制页面

* 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。
* 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。
* 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。

## 断开连接

> 当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。
>
> * 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN\_WAIT\_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)
> * 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN\_WAIT\_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)
> * 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST\_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)
> * 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME\_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)

* 断开连接端可以是客户端，也可以是**服务端**。假设**客户端**发起中断连接请求：
* 第一次挥手：**客户端**先发送 FIN 报文（第 24 帧），用来关闭主动方到被动关闭方的数据传送，也就是**客户端**告诉服务器：我已经不会再给你发数据了(当然，在 fin 包之前发送出去的数据，如果没有收到对应的 ack 确认报文，**客户端**依然会重发这些数据)，但此时**客户端**还可以接受数据。
* 第二次挥手：**服务端**接到 FIN 报文后，但是如果还有数据没有发送完成，则不必急着关闭 Socket，可以继续发送数据。所以服务器端先发送 ACK（第 25 帧），告诉**客户端**：请求已经收到了，但是我还没准备好，请继续等待停止的消息。这个时候**客户端**就进入 FIN\_WAIT 状态，继续等待**服务端**的 FIN 报文。
* 第三次挥手：当**服务端**确定数据已发送完成，则向**客户端**发送 FIN 报文（第 26 帧），告诉**客户端**：服务器这边数据发完了，准备好关闭连接了。
* 第四次挥手：**客户端**收到 FIN 报文后，就知道可以关闭连接了，但是他还是不相信网络，所以发送 ACK 后进入 TIME\_WAIT 状态（第 27 帧）， **服务端**收到 ACK 后，就知道可以断开连接了。**客户端**等待了 2MSL 后依然没有收到回复，则证明**服务端**已正常关闭，最后，**客户端**也可以关闭连接了至此，TCP 连接就已经完全关闭了！

## 参考文章

* [经典面试题：从 URL 输入到页面展现到底发生什么？](https://zhuanlan.zhihu.com/p/57895541)
* [访问 Web，tcp 传输全过程（三次握手、请求、数据传输、四次挥手）](https://blog.csdn.net/sinat_21455985/article/details/53508115)

---

---
url: /docs/01.前端/01. 基础/1. interview.md
---

## 1. 关于函数的 length 属性

360 面试过程遇到一个很有趣的问题，是关于函数的 length 属性的，题简写如下

```js
(() => 1).length === 0; // 输出什么
```

我所理解的拥有 `length` 的对象一般都是数组或者类数组对象，或者定义了 `length` 属性的对象，所以我回答说这个应该是 `false` 吧，后来面试告诉我函数是有 `length` 属性的，函数的 `length` 属性就是函数参数的个数，瞬间我恍然大悟，函数的参数就是 `arguments` ，而 `arguments` 也是一个类数组对象所以他是有 `length` 属性的

```js
// so
(() => 1).length === 0; // 输出 true
(a => a).length; // 输出 1
```

但也不完全是这样，函数的参数分为`实参`和`形参`，实参的数量是 `argument.length`，而行参的数量是`函数的length`

```js
function fn(a, b) {
  console.log(arguments.length, fn.length);
}
fn(1, 2, 3, 4) // 4，2
```

## 2. 数组中字符串键值的处理

在 JavaScript 中数组是通过数字进行索引，但是有趣的是他们也是对象，所以也可以包含 `字符串` 键值和属性，但是这些不会被计算在数组的长度（length）内

如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当做数字索引来处理

```js
const arr = [];
arr[0] = 1;
arr['1'] = '嘿嘿';
arr['cym'] = 'cym';
console.log(arr); // [1, '嘿嘿', cym: 'cym']
console.log(arr.length); // 2
```

## 3. 类型转换问题

原题：如何让 (a == 1 && a == 2 && a == 3) 的值为 true?

这个问题考查的数据类型转换， `==` 类型转换有个基本规则

* `NaN` 与任何值都不相等，包括自己本身
* `undefined` 与 `null` 相等(==)，其他都不等
* 对象与字符串类型做比较，会把对象转换成字符串然后做比较
* 其他类型比较都要转换成 `数字` 做比较

那么这个问题我们重写 `toString` 或者 `valueOf` 方法就可以了

```js
const a = {
  val: 1,
  toString() {
    return this.val++;
  },
};
if (a == 1 && a == 2 && a == 3) {
  console.log('ok');
}
```

还有一种方法实现

```js
var i = 1;
Object.defineProperty(window, 'a', {
  get() {
    return i++;
  },
});

if (a == 1 && a == 2 && a == 3) {
  console.log('OK');
}
```

### 拓展一下 \[] == !\[] 为什么是 true

上面隐式类型转换规则中提到，其他类型比较都要转换成数字做比较，这个就是对应那条规则的

* 首先 `[].toString()` 会得到一个 `''` 字符串
* `![]` 得到一个布尔值 `false`
* `''` 与 `false` 比较肯定要转换成数字比较
* 那么 `''` 转换则为 `0`， `false` 转换也是 `0`
* 所以这道题就是 `true`

## 3. 如何让 (a == 1 && a == 2 && a == 3) 的值为 true

* 这是一道经典的面试题，主要考察是数据类型转换，我们重写 toString 或者 valueOf 方法即可解决

```js
const n = {
  i: 1,
  toString() {
    return n.i++;
  },
  // 两个写一个即可
  valueOf() {
    return n.i++;
  },
};

if (n == 1 && n == 2 && n == 3) {
  console.log('通过');
}
```

* 当然也有其他解决技巧

```js
const n = 0;
!(n == 1 && n == 2 && n == 3); // true
```

* 利用数组 `toString` 方法会调用本身的 `join` 方法，这里把自己的 `join` 方法改写为 `shift` 方法，每次返回第一个元素，而且每次数组删除第一个值，正好可以使判断成立。

```js
var n = [1, 2, 3];
n.join = n.shift;
if (n == 1 && n == 2 && n == 3) {
  console.log('通过');
}
```

## 4. jsonp

当出现端口、协议、域名三者有一个不一样的时候就会出现跨域，跨域解决方案很多，这里实现一个 jsonp

`jsonp` 是利用 `script、img、iframe、link` 等带有的 `src` 属性请求可以跨域加载资源，而不受同源策略的限制。 每次加载时都会由浏览器发送一次 GET 请求，通过 `src` 属性加载的资源

```js
// callbackName 要与后端返回的一致
function jsonp(url, query, callbackName = 'getData') {
  return new Promise((resolve, reject) => {
    const scriptEl = document.createElement('script');
    const queryObj = parseQuery(query);
    const onDone = () => {
      delete window[callbackName];
      document.body.removeChild(scriptEl);
    };
    url += `?callback=${callbackName}${queryObj && '&' + queryObj}`;
    scriptEl.src = url;
    window[callbackName] = res => {
      onDone();
      if (res) {
        resolve(res);
      } else {
        reject('没有获取到数据');
      }
    };
    scriptEl.onerror = () => {
      onDone();
      reject('脚本加载失败');
    };
    document.body.appendChild(scriptEl);
  });
}

function parseQuery(query) {
  let queryStr = '';
  for (const key in query) {
    if (Object.hasOwnProperty.call(query, key)) {
      queryStr += `${key}=${query[key]}&`;
    }
  }
  return queryStr.slice(0, -1);
}

// 使用
jsonp('http://localhost:3000/getData', {
  a: 1,
  b: 2,
})
  .then(res => {
    console.log('🚀 ~ jsonp ~ res', res);
  })
  .catch(err => {
    console.log('🚀 ~ jsonp ~ err', err);
  });
```

## 5. 图片懒加载

工作中经常会用到图片，当图片过多的时候，通常会做懒加载优化加载请求，懒加载就是优先加载可视区域内的内容，其他部分等进入了可视区域内在去加载

图片懒加载的原理很简单，需要做到两点即可实现：

1. 图片是否要加载取决于它的 `src` 属性。在初始化的时候我们不给图片设置 src 属性，而给一个其他属性设置图片的真实地址，当图片需要加载时候在给图片的 `src` 设置属性，此时就可以做到懒加载

2. 当图片进入可视区域的时候，我们就需要加载图片了。可视区域就是当图片元素的相对于 `可视区域的高度` 小于 `可视区域的高度` 的时候说明元素进入视口了

### 可视区域高度

可是区域就是浏览器中我们可以看见的高度，可以使用 `window.innerHeight` 或者 `document.documentElement.clientHeight` 获取到

当元素 `顶边距离` 距离小于 `可视窗口` 时说明元素要进入可视区域了

### getBoundingClientRect

`element.getBoundingClientRect()` 返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合，就是该元素的 CSS 边框大小。返回的结果是包含完整元素的最小矩形，并且拥有 left, top, right, bottom, x, y, width, 和 height 这几个以像素为单位的只读属性用于描述整个边框。除了 width 和 height 以外的属性是 `相对于视图窗口的左上角` 来计算的。

我们可以用这个 api 来获取图片相对于可视区域左上角的高度，它永远是个相对高度，此时可以写一个是否进入可视区域的方法

```js
const viewHeight = window.innerHeight || document.documentElement.clientHeight;

function isInViewport(el) {
  const { top } = el.getBoundingClientRect;
  return top <= viewHeight;
}
```

对于滚动这种高频事件我们一般都会做防抖处理，连续触发后只执行最后一次

```js
function debounce(fn, delay = 500) {
  let timer;
  return function(...args) {
    if (timer) clearTimeout(timer);
    setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}
```

贴上完整代码

```js
const viewHeight = window.innerHeight || document.documentElement.clientHeight;
// 是否满足加载条件
function isInViewport(el) {
  const { top } = el.getBoundingClientRect();
  return top <= viewHeight;
}

// 防抖处理
function debounce(fn, delay) {
  let timer;
  return function(...args) {
    if (timer) clearTimeout(timer);
    setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 图片加载个数
let count = 0;

// 懒加载核心
function lazyLoad() {
  const imgs = document.getElementsByTagName('img');
  const len = imgs.length;
  for (let i = 0; i < len; i++) {
    const el = imgs[i];
    if (isInViewport(el)) {
      const src = el.getAttribute('data-src');
      if (src) {
        el.src = src;
        el.removeAttribute('data-src');
        if (++count === len) {
          // 图片都加载完成后移除事件
          removeEvent();
        }
      }
    }
  }
}

// 防抖处理懒加载函数，方便移除事件监听
function debounceLazyLoad() {
  return debounce(lazyLoad, 500)();
}

// 绑定事件函数
function bindEvent() {
  // 页面加载完成执行一次
  window.addEventListener('load', debounceLazyLoad);
  // 绑定滚动事件
  document.addEventListener('scroll', debounceLazyLoad);
}
// 满足条件后移除事件
function removeEvent() {
  window.removeEventListener('load', debounceLazyLoad);
  document.removeEventListener('scroll', debounceLazyLoad);
}
// 绑定事件
bindEvent();
```

## 6. Generator 问题

### 对象增加迭代器

类数组对象的特征：必须有长度、索引、能够被迭代，否则这个对象不可以使用 `...` 语法转数组，我们可以使用 Array.from 转，当然我们也可以给对象添加一个迭代器

```js
const obj = {
    0: 1,
    1: 2,
    2: 3,
    3: 4,
    length: 4,
    [Symbol.iterator]() {
        let idx = 0
        return {
            next() {
                return {
                    value: obj[idx],
                    done: idx++ >= obj.length,
                }
            }
        }
    }
}
// 此时对象就被添加了迭代器
[...obj] // 1 2 3 4
for (const val of obj) {
    console.log(val) // 1 2 3 4
}
```

上面的问题可以字节使用生成器来实现，生成器返回一个迭代器，迭代器有 next 方法，调用 next 方法可以返回 value 和 done

```js
const obj = {
        0: 1,
        1: 2,
        2: 3,
        3: 4,
        length: 4,
        [Symbol.iterator]: function*() {
            let idx = 0
            while (idx !== this.length) {
                yield this[idx++]
            }
        }
```

### 实现一个字符串的迭代器

实现一个字符串的迭代器：传入一组字符串并返回单个字符的范例。一旦更新的字符串，输出也跟着替换掉旧的

```js
function generator(str) {
  let idx = 0;
  return {
    next() {
      return {
        value: str[idx],
        done: idx++ >= str.length,
      };
    },
  };
}
// 测试
const str = 'as';
let gen = generator(str);
console.log(gen.next());
console.log(gen.next());
console.log(gen.next());
console.log(gen.next());
gen = generator('str');
console.log(gen.next());
console.log(gen.next());
console.log(gen.next());
console.log(gen.next());
// { value: 'a', done: false }
// { value: 's', done: false }
// { value: undefined, done: true }
// { value: undefined, done: true }
// { value: 's', done: false }
// { value: 't', done: false }
// { value: 'r', done: false }
// { value: undefined, done: true }
```

### 简单模拟 co

模拟一下 co 的实现

首先来看一则例子

```js
const fs = require('fs');
const path = require('path');
const { promisify } = require('util');
const readFile = promisify(fs.readFile);

function* read() {
  const name = yield readFile(path.resolve(__dirname, 'name.txt'), 'utf8');
  const age = yield readFile(path.resolve(__dirname, name), 'utf8');
  return age;
}

const it = read();

let { value, done } = it.next();
value.then(data => {
  let { value, done } = it.next(data);
  // console.log(data, '???')
  value.then(data => {
    let { value, done } = it.next(data);
    console.log(value);
  });
});
```

使用 co 库可以很容易解决这个问题

```js
const co = require('co');
// co 接受一个生成器
co(read()).then(data => {
  console.log(data);
});
// 那模拟一下
function _co(it) {
  // 首先返回一个 promise
  return new Promise((resolve, reject) => {
    // 因为可以传值的原因，不可以直接使用循环实现，需要使用 递归
    function next(data) {
      const { value, done } = it.next(data);
      if (done) return resolve(value);
      // 保证值是一个 promise
      Promise.resolve(value).then(data => {
        next(data);
      }, reject);
    }
    next();
  });
}
```

## 7. 斐波那契数列

* 今天新东方的面试还提到了斐波那契数列，其实这个东西蛮很有趣，简单介绍一下
* 1、1、2、3、5、8、13、21、34 ....
* 这道题有个规律，第一项加上第二项永远等于第三项：1 + 1 = 2；1 + 2 = 3；2 + 3 = 5；3 + 5 = 8 ....
* 要求是传入第几项，得到该值，根据这个规律来实现一下

### 经典写法

```js
function fibonacci(n) {
  // 第一项和第二项都返回1
  if (n === 1 || n === 2) return 1;
  // 我们只要返回 n - 1（n的前一项）与 n - 2（n的前两项）的和便是我们要的值
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

### 缓存写法

上面的写法，求 20 次以内的总和运行会很快，50 次以上特别慢，100 次 以上可能就爆栈了，所以我们需要优化写法，缓存每次计算后的值

```js
function feibo(n, sum1 = 1, sum2 = 1) {
  if (n === 1 || n === 2) return sum2;
  return feibo(n - 1, sum2, sum1 + sum2);
}
```

这种写法缓存了，每次计算后的值，执行效率会很高，100 次以上也会秒返回结果，这个也叫作尾递归优化

### 缓存写法

这中写法就有动态规划的意思了，利用 `dp[n] = dp[n - 1] + dp[n - 2]` 的递推公式，把所有计算结果缓存在 memo 里面，最后返回 memo\[n] 即可

```js
function memory(n, memo = []) {
  if (n === 1 || n === 2) {
    return 1;
  } else if (!memo[n]) {
    memo[n] = memory(n - 1) + memory(n - 2);
  }
  return memo[n];
}
```

### 动态规划

动态规划直接根据递推公式 `dp[n] = dp[n - 1] + dp[n - 2]` 写就可以

```js
function dibDp(n) {
  const dp = [];
  dp[0] = 1;
  dp[1] = 1;
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n - 1];
}
```

## 8. 观察者与发布订阅

> 一直以来，我以为发布订阅和观察者是一个思路，一次偶然的机会我发现他们是两种不同的设计思路

虽然他们都是 `实现了对象的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得倒通知，然后自动更新` 。但是他们之间是有一定区别的。

### 观察者模式

观察者模式会有 `观察者` 与 `被观察者(观察目标)` 两个对象存在，观察者可以有多个，观察目标可以添加多个观察者，可以通知观察者。观察者模式是面向与目标和观察者编程的，耦合目标和观察者

```js
// 被观察者
class Subject {
  constructor() {
    this.observes = [];
  }
  add(ob) {
    this.observes.push(ob);
    return this;
  }
  notify(...args) {
    this.observes.forEach(ob => ob.update(...args));
    return this;
  }
}
// 观察者
let id = 0;
class Observer {
  constructor(name) {
    this.name = name || ++id;
  }
  update(...args) {
    console.log(`${this.name} 收到了通知：${args}`);
  }
}

// 使用
const o1 = new Observer('fecym');
const o2 = new Observer('ys');
const o3 = new Observer();
const o4 = new Observer();

const s = new Subject();
// 添加观察者
s.add(o1)
  .add(o2)
  .add(o3)
  .add(o4);
// 通知观察者
s.notify('你好');
```

### 发布订阅模式

发布订阅模式会有一个调度中心的概念。是面向调度中心编程的，对发布者与订阅者解耦，例如 node 中的 emitter

```js
class Emitter {
  constructor() {
    this.callbacks = {};
  }
  on(type, fn) {
    if (!this.callbacks[type]) {
      this.callbacks[type] = [];
    }
    this.callbacks[type].push(fn);
    return this;
  }
  emit(type, ...args) {
    if (!this.callbacks[type]) return;
    this.callbacks[type].forEach(fn => fn(...args));
    return this;
  }
  off(type, fn) {
    if (!this.callbacks[type]) return;
    this.callbacks[type].find((handler, idx) => {
      if (fn === handler) {
        this.callbacks[type].splice(idx, 1);
      }
    });
    return this;
  }
  once(type, fn) {
    const wrapFn = (...args) => {
      fn(...args);
      this.off(type, fn);
    };
    this.on(type, wrapFn);
  }
}
const em = new Emitter();

const fn1 = (a, b) => console.log('哈哈哈哈哈第一次', a, b);
const fn2 = a => console.log('哈哈哈哈哈第二次', a);
const fn3 = a => console.log('测试 once', a);
em.on('fecym', fn1);
em.on('fecym', fn2);
em.emit('fecym', 1, 2);
em.off('fecym', fn2);
em.emit('fecym', 1, 132);
em.once('aaa', fn3(1));
```

## 9. 下面代码输出什么，为什么

```js
var obj = {
  '2': 3,
  '3': 4,
  length: 2,
  splice: Array.prototype.splice,
  push: Array.prototype.push,
};
obj.push(1);
obj.push(2);
console.log(obj);
```

结果：输出 obj 是 `[empty × 2, 1, 2, splice: ƒ, push: ƒ]`

* 一个对象如果有 length 属性，length 属性可以告诉我们对象的元素个数，基本上就满足一个类数组对象了

* 当对象带有数组的 `splice` 方法并且 `length` 属性的值可以转为数值时，对象将会被当做数组打印。

* obj 调用数组的 push 方法自身的 length 属性就会 ++，此时调用两次，length 就变成了 4

  1. 第一次 push：`obj[2] = 1; obj.length += 1`
  2. 第二次 push：`obj[3] = 2; obj.length += 1`
  3. 使用 console.log 输出的时候，因为 obj 具有 length 属性和 `splice` 方法，故将其作为数组进行打印，没有 `splice` 还是以对象形式打印
  4. 打印时因为数组未设置下标为 0 1 处的值，故打印为 empty，主动 obj\[0] 获取为 undefined

## 10. 输出以下代码的执行结果并解释为什么

```js
var a = {
  n: 1,
};
var b = a;
a.x = a = {
  n: 2,
};

console.log(a.x);
console.log(b.x);
```

结果： `a.x 为 undefined；b.x 为 { n: 2 }`

1. 首先 `.` 的优先级要比 `=` 优先级要高，所以 a.x 要先执行；
2. 相当于为 a（或者 b）所指向的 `{ n: 1 }` 对象新增了一个属性 x，即此时对象将变为 `{ n: 1, x: undefined}` 。
3. 随后按照正常赋值从右往左进行赋值，在执行 `a = { n: 2 }` 时，a 的引用发生改变，指向了新对象，而不会对 b 造成影响
4. 接着执行 `a.x = { n：2 }`的时候，并不会重新解析一遍 a，而是沿用最初解析 a.x 时候的 a，所以此时旧对象的 x 的值为 `{ n：2 }`，旧对象为 `{ n: 1, x: { n：2 } }`，它被 b 引用着。
5. 所以最终打印结果：`a.x 为 undefined；b.x 为 { n: 2 }`

参考: [优先级和结合性](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#precedence_and_associativity)

## 11. 打印出 1 - 10000 之间的所有对称数

对称数：121，1331 之类的，只要数字反转后等于原来值，就满足我们要的结果

```js
let i = 10000;
const res = [];
const reverse = x =>
  Number(
    x
      .toString()
      .split('')
      .reverse()
      .join('')
  );
while (i >= 0) {
  if (i === reverse(i)) {
    res.push(i);
  }
  i--;
}
```

---

---
url: /docs/03.工具/Npm 相关/command.md
---

## 命令行

不管在 windows 还是 Mac、Linux 系统都会有很多命令来提供一些便捷的操作，比如在 window 中 打开 cmd 输入 `start snippingtool` 就可以打开绘图工具，cmd 里面执行的其实就是一个以 .bat 执行脚本，你也可以直接新建一个文件，然后在文件内部写入 `start snippingtool`，然后保存为 .bat 结尾的文件即可直接双击执行这个文件。在 Mac 和 Linux 中可以直接写内容，不需要后缀名，以 .sh 结尾也可以，但是 Mac 和 Linux 默认新建的脚本是没有执行权限的，需要 执行 `chmod +x 文件名` 给文件可执行权限

## 命令行参数

大部分命令是可以传递一个参数，然后来做不同的事情，比如说 `npm --version` 查看 npm 的版本号，人家定义了在命令后面输入 `--xxx` 来做什么处理，那这个是怎么实现的？

## 获取命令参数

在 node 中获取命令行参数是使用 `process.argv`，`process.argv` 返回一个数组，第一项是 node 所在的目录，第二个是该程序所在的目录(在项目里面使用)，第三项开始是我们传递的参数

我们新建一个 hello.js，里面就打印命令行参数，然后新建一个 hello.bat

```js
// hello.js
console.log('hello');
console.log(process.argv);
```

此时我们直接执行 `node hello.js --name=cym` 就可以看到打印的参数了。

也可以在 window 中需要新建一个 .bat 脚本，让他们帮我们执行

```bat
:: %1 %2 就是在命令行中输入参数
node hello.js %1 %2
```

此时我们在控制台中输入 `hello --name=cym`，同样我们打印出来了命令行参数

## 惊叹有病

一般像上面的 hello.js 文件需要在第一行写入一句话 `#! /usr/bin/env node` 就是声明该文件的执行环境是哪个，比如我们要执行的是 node 环境后面指定环境为 node 就可以，如果是 bash 就写 bash，这个有个好的记忆方法就是 `惊叹有病`。

此时执行这个文件的时候就不需要用 `node 文件名`，只需要 `./ 文件名` 就可以执行（windows 系统不可以），当然你需要给执行权限

## yargs

`yargs` 工具可以帮我解析命令行参数，然后把它变成一个对象，可以方便我们开发

```js
  const yargs = require('yargs)
  console.log(yargs.argv)
```

此时我们在控制台中打印就可以看到 `yargs` 把我们传入的参数解析成了一个对象

## 制作一个命令行

`yargs` 功能不止这么简单，还有很多更有趣的用法，这个工具是专门用来解析命令行参数，而且用法超简单，下面来制作一个简单的命令行工具来使用一下 `yargs`

### 新建项目

```sh
# 创建一个文件夹并且打开它
mkdir hello && cd hello
# 初始化一个项目
npm init -y
# 安装 yargs
npm i yargs -s
# 新建主入口文件
touch index.js
# 新建命令入口文件
mkdir bin && cd bin && touch www
```

最终目录结构如下

```sh
├── bin
│   └── www             命令入口，核心命令文件
├── node_modules        文件需要的依赖目录
├── index.js            主入口文件
├── package-lock.json   npm 依赖锁文件
└── package.json        项目配置文件
```

### 主文件

此时我们在 index.js 目录下写一个简单的 Hello 方法

```js
// hello.js
class Hello {
  constructor(argv) {
    console.log(argv);
  }
  start() {
    console.log('此处省略一万行代码...');
  }
}

module.exports = Hello;
```

### 命令文件

在 www 中写入以下代码，为什么要放在 `bin/www` 里面，这算一个约定俗成吧

```js
#! /usr/bin/env node
const yargs = require('yargs');
const Hello = require('./index');

const argv = yargs
  .option('n', {
    alias: 'name',
    demand: true,
    // default: 'cym',
    description: '请输入您的姓名',
  })
  .usage('hello [options]')
  // 示例
  .example('hello --name cym', '执行 hello 命令，然后传入 name 参数为 cym')
  // 版本号，不传任何值会默认从 package.json 中获取版本号
  .version()
  // 版本号别名
  .alias('v', 'version')
  // 帮助信息
  .help('h')
  .alias('h', 'help').argv;

const hello = new Hello(argv);
hello.start();
```

### 配置 bin

然后我们修改 `package.json` 文件，新增 `bin` 字段， `bin` 字段中配置的东西，npm 会自动给你匹配到全局中

```json
  {
    ...
    "bin": {
      "hello": "bin/www"
    },
    ...
  }
```

### npm link

配置完之后，我们可以执行 `npm link` 命令，我们会得到以下的输出，此时我们命令行工具就可以使用了，直接输入 `hello --name=xxx` 便可以测试

如果你想让别人也用到你的这个工具，你可以把它发布到 npm 中，直接在控住台中登录 npm 然后，`npm publish` 就发布上去了

### 源码地址

完整代码已开源，[地址](https://github.com/fecym/hello-command.git)

---

---
url: /docs/03.工具/Npm 相关/npm-init.md
---

## npm init

初始化一个项目的时候，我们会在控制台输入 `npm init` 执行该命令后终端会依次询问 `name, version, description` 等字段，最后会为你生成一个 `package.json` 文件

如果想偷懒省去一路回车，可以在命令后面加 `--yes` 或者 `-y` 参数，这样会快速生成一个 `package.json` 文件

```sh
  npm init -y
```

这样生成出来的 `package.json` 是默认的配置，如果想要改变其默认配置怎么办？

## 修改 npm 配置

初始化 `package.json` 时的字段默认值是可以自己配置的，可以用下面的命令去修改默认配置：

```sh
  npm config set init.author.email "yumingtarget@gmail.com"
  npm config set init.author.name "chengyuming"
  npm config set init.author.url "https://github.com/fecym"
  npm config set init.license "MIT"
  # 默认版本是 0.0.1
  npm config set init.version "1.0.0"
```

此时我们在控制台输入 `npm init -y` 就可以得到一个以下的 `package.json`

```json
{
  "name": "npm-name",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "chengyuming <yumingtarget@gmail.com> (https://github.com/fecym)",
  "license": "MIT"
}
```

## npm run

使用 `npm init` 创建的 `package.json` 文件中有 `scripts` 字段，这个字段是可以定义脚本命令的

### 1. 执行命令

比如说我们跑项目经常执行的命令 `npm start` 或者 `npm run dev` 其实都是在这个字段里面配置的，比如我们新建一个 `index.js` 文件，然后修改 `scripts` 字段为以下内容：

```js
  "scripts": {
    "start": "node index",
    "dev": "node index"
  }
```

此时执行 `npm start` 或者 `npm run dev` 都可以执行到 `index.js` 文件中的内容了

### 2. 执行 node\_modules/.bin 的命令

在 scripts 字段中也是可以获取到 `node_modules/.bin` 文件中的一些命令的，比如说没有全局安装 `webpack`（也不推荐你全局安装），本地安装了 `webpack` 之后，是可以直接在 `scripts` 下面使用的，

```sh {3}
  "scripts": {
    # 此时会默认去 node_modules/.bin 文件下面找 webpack 命令
    "start": "webpack",
    "dev": "node index"
  }
```

执行 `npm start` 之后，会自动创建一个 **shell** 脚本，这个 **shell** 脚本会将当前目录的 `node_modules/.bin` 子目录加入 PATH 变量，执行结束后，再将 `PATH` 变量恢复原样。
这意味着，当前目录的 `node_modules/.bin` 子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。

### 3. 通配符 \*

`*` 表示任意文件名，`**` 表示任意一层子目录。

当我们安装了 `eslit` 我们需要用 eslint 来校验代码是否合法的时候

```js
  "scripts": {
    "eslint": "eslint *.js",
    // 或者这么写，就不注释了
    "eslint": "eslint **/*.js",
  }
```

如果我们执行不带任何参数的 `npm run` 会列出所有可执行的命令

### 4. 脚本传参 --

有些脚本是可以传递参数的，此时我们可以使用 `--` 传参符号来传递参数，比如 `webpack-dev-server` 传递参数

```js
  "scripts": {
    // 启动项目的时候 mode=development，自动打开浏览器，显示滚动条
    "start": "webpack-dev-server --mode=development --open --progress",
    // 构建项目的时候 mode=production
    "build": "webpack --mode=production"
  },
```

## cross-env

这是一款可以跨平台设置和使用环境变量的插件，比如说项目中我们可能在项目中设置多个环境变量来区分是什么环境的，假如说设置了 `PROXY_EVN` 有三个值分别是 `dev、uat、prod` 来代表开发、UAT 和生产三个环境的请求地址，直接在 `package.json` 中写 `PROXY_EVN=prod yarn start` 这种情况在 `window` 下可能会报错，但是使用 `cross-env` 之后可以让这一切做到兼容

```js
  "scripts": {
    "start": "node index",
    "dev": "cross-env PROXY_ENV=dev yarn start",
    "uat": "cross-env PROXY_ENV=uat yarn start",
    "prod": "cross-env PROXY_ENV=prod yarn start",
  },
```

## 下载依赖 -D 和 -S 的区别

当我们下载一个项目依赖包的时候，会在下载的时候加一些参数 `-D` 或 `-S`，这样会把依赖添加到 `package.json` 中的 `devDependencies` 或 `dependencies` 字段中

* `devDependencies` 主要是存放用于本地开发的
* `dependencies` 会在我们开发的时候带到线上
* `-D` 会添加到 `devDependencies` 里面，`-S` 会添加到 `dependencies`
* `--save-dev` 也会添加到 `devDependencies`
* `--save` 会添加到 `dependencies`
* 如果什么参数都不带，那么默认添加到 `dependencies` 中

```sh
  # 添加到 devDependencies
  npm install -D xxxx
  # 添加到 dependencies
  npm install -S xxxx
```

## npx

> 在 `npm v5.2.0` 引入了一个新的命令 `npx`，是 `npm` 的一个包执行器。`npm` 和 `npx` 的区别在于 `npm` 会把包下载到本地，而 `npx` 只是零时安装，用完就删除。而且 `npx` 可以帮我们执行 依赖包里面的二进制文件。在下面的例子中我们来体验下 `npx` 这款神器。

### 1. 执行远程依赖包

```sh
  # npm
  npm install -g create-react-app
  create-react-app my-app
  # npx
  npm create-react-app my-app
```

### 2. 使用不同版本的 node 执行命令

```sh
  npx node@4 -e 'console.log(process.version)'
  npx node@6 -e 'console.log(process.version)'
```

## package.json

> `package.json` 文件是执行 `npm init` 之后生成的一个文件，该文件定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。`npm install` 命令根据这个配置文件，自动下载所需的模块。这里来记录一下每个字段代表的含义。

### 1. scripts

`scripts` 字段在上面也提到过，这是用来指定脚本运行命令的缩写，比如下面的 start 代替了 `node index.js`

```json
  "scripts": {
    "start": "node index.js",
    "dev": "cross-env PROXY_ENV=dev yarn start",
    "uat": "cross-env PROXY_ENV=uat yarn start",
    "prod": "cross-env PROXY_ENV=prod yarn start"
  }
```

### 2. dependencies，devDependencies

`dependencies，devDependencies` 在上面也提到过了，是项目依赖管理的，指定项目开发所需要的模块和项目运行时所需要的依赖以及版本号

```json
  "dependencies": {
    "axios": "^0.18.0",
    "babel-plugin-component": "^1.1.1",
    "compression-webpack-plugin": "^3.0.0",
    "js-cookie": "^2.2.0",
    "normalize.css": "^8.0.1",
  },
  "devDependencies": {
    "@types/echarts": "^4.1.10",
    "@types/jest": "^24.0.11",
    "@types/js-cookie": "^2.2.1",
    "@types/nprogress": "^0.0.29",
    "@types/webpack-env": "^1.13.9"
  }
```

### 3. bin

`bin` 字段指定了各个内部命令对应的可执行文件的位置。添加了这个命令之后，我们把 npm 包传到 npm，别人下载下来之后会自动添加到 `node_modules/.bin` 下面此时，我们就可以直接执行 我们暴露出来的命令

```json
  "bin": {
    "cym-blog": "./index.js"
  }
```

此时安装 `cym-blog` 这个模块之后，可以看到 `node_modules/.bin` 就有了 `cym-blog` 环境变量

此时我们就可以执行 `cym-blog init my-blog` 来创建一个博客项目

当然需要在 主入口文件下面 加入一句话 `#!/usr/bin/env node` 指定执行环境为 node

最后生成的 `cym-blog` 内容如下

* bash 脚本

```sh
  #!/bin/sh
  basedir=$(dirname "$(echo "$0" | sed -e 's,\\,/,g')")

  case `uname` in
      *CYGWIN*) basedir=`cygpath -w "$basedir"`;;
  esac

  if [ -x "$basedir/node" ]; then
    "$basedir/node"  "$basedir/../cym-blog/bin/index.js" "$@"
    ret=$?
  else
    node  "$basedir/../cym-blog/bin/index.js" "$@"
    ret=$?
  fi
  exit $ret
```

* cmd 脚本

```batch
  @IF EXIST "%~dp0\node.exe" (
    "%~dp0\node.exe"  "%~dp0\..\cym-blog\bin\index.js" %*
  ) ELSE (
    @SETLOCAL
    @SET PATHEXT=%PATHEXT:;.JS;=;%
    node  "%~dp0\..\cym-blog\bin\index.js" %*
  )
```

### 4. main

`main` 很重要，它记录了项目的主要入口文件，`require('moduleName')` 就会加载这个文件。默认为 `index.js`，会在根目录下面寻找这个文件作为主入口文件

### 5. config

`config` 字段用于添加命令行的环境变量。

```json
{
  "name": "foo",
  "config": { "port": "8080" },
  "scripts": { "start": "node server.js" }
}
```

然后，在 `server.js` 脚本就可以引用 `config` 字段的值。

```js
  http
    .createServer(...)
    .listen(process.env.npm_package_config_port)
```

执行 `npm start` 命令时，这个脚本就可以得到值。

也可以更改这个值

```sh
  npm config set foo:port 80
```

## package-lock.json

`package-lock.json` 是在 `npm v5` 之后增加的一个依赖锁文件，用来锁定依赖的安装结构。如果查看这个 `json` 的结构，会发现与 `node_modules` 目录的文件层级结构是一一对应的。
以依赖关系为: `app{webpack}` 的 'app' 项目为例, 其 `package-lock` 文件包含了这样的片段。

```json
{
  "name": "app",
  "version": "0.1.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    // ... 其他依赖包
    "webpack": {
      "version": "1.8.11",
      "resolved": "https://registry.npmjs.org/webpack/-/webpack-1.8.11.tgz",
      "integrity": "sha1-Yu0hnstBy/qcKuanu6laSYtgkcI=",
      "requires": {
        "async": "0.9.2",
        "clone": "0.1.19",
        "enhanced-resolve": "0.8.6",
        "esprima": "1.2.5",
        "interpret": "0.5.2",
        "memory-fs": "0.2.0",
        "mkdirp": "0.5.1",
        "node-libs-browser": "0.4.3",
        "optimist": "0.6.1",
        "supports-color": "1.3.1",
        "tapable": "0.1.10",
        "uglify-js": "2.4.24",
        "watchpack": "0.2.9",
        "webpack-core": "0.6.9"
      }
    },
    "webpack-core": {
      "version": "0.6.9",
      "resolved": "https://registry.npmjs.org/webpack-core/-/webpack-core-0.6.9.tgz",
      "integrity": "sha1-/FcViMhVjad76e+23r3Fo7FyvcI=",
      "requires": {
        "source-list-map": "0.1.8",
        "source-map": "0.4.4"
      },
      "dependencies": {
        "source-map": {
          "version": "0.4.4",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.4.4.tgz",
          "integrity": "sha1-66T12pwNyZneaAMti092FzZSA2s=",
          "requires": {
            "amdefine": "1.0.1"
          }
        }
      }
    }
    //... 其他依赖包
  }
}
```

看懂 `package-lock` 文件并不难，其结构是同样类型的几个字段嵌套起来的，主要是`version, resolved, integrity, requires, dependencies` 这几个字段而已。

* `version, resolved, integrity` 用来记录包的准确版本号、内容 hash、安装源的，决定了要安装的包的准确 "身份" 信息
* 假设盖住其他字段，只关注文件中的 `dependencies: {}` 我们会发现，整个文件的 `JSON` 配置里的 `dependencies` 层次结构与文件系统中 `node_modules` 的文件夹层次结构是完全对照的
* 只关注 `requires: {}` 字段又会发现，除最外层的 `requires` 属性为 `true` 以外, 其他层的 `requires` 属性都对应着这个包的 `package.json` 里记录的自己的依赖项

本段内容摘自 [2018 年了，你还是只会 npm install 吗？](https://juejin.im/post/5ab3f77df265da2392364341#heading-6)，具体详情可查看这里

## package.json 的变量

比如最初我们执行 `npm init -y` 之后生成的 `package.json` 文件，我们可以使用 `process.env.npm_package_xxx` 来获取到在 `package.json` 定义的变量

```js
console.log(process.env.npm_package_name); // npm-name
console.log(process.env.npm_package_version); // 1.0.0
console.log(process.env.npm_package_description); //
console.log(process.env.npm_package_main); // index.js
console.log(process.env.npm_package_license); // MIT
```

## npm 发布包

### 登录发布包

`npm` 发布包其实蛮简单，首先你需要有一个 `npm` 账号，然后你需要在控制台登录你的 `npm` 账号，然后直接 `npm publish` 即可发布

```sh
  # 登录 npm，根据提示输入账号、密码和邮箱即可登录
  npm login
  # 发布包
  npm publish
  # 更新包
  npm version patch
  npm publish
```

介绍几个可能用到的命令，推荐先使用：

```sh
# 查看当前登录的npm用户，如果已经登录了且是我们要发包的账号，就不需要登录了
npm whoami

# 发包可能失败，有可能是源不对
# 查看当前源地址
npm config get registry
# 如果不是 npm 源需要切换到 npm 的源
npm config set registry https://registry.npmjs.org
```

### npm version 说明

`npm version` 后面可以跟三个参数：

* `patch`：小变动，比如 bug 修复等，版本号变动 **v1.0.0 -> v1.0.1**
* `minor`：增加新功能，不影响现有功能，版本号变动 **v1.0.0 -> v1.1.0**
* `major`：模块大改动，可能不向后兼容，版本号变动 **v1.0.0 -> v2.0.0**

## 参考链接

1. [你真的懂 package.json 吗](https://juejin.im/post/5dea1095e51d4558083322e2)
2. [package.json 文件](https://javascript.ruanyifeng.com/nodejs/packagejson.html)
3. [2018 年了，你还是只会 npm install 吗？](https://juejin.im/post/5ab3f77df265da2392364341)
4. [用 npm script 打造超溜的前端工作流](https://www.kancloud.cn/sllyli/npm-script/1243450)

---

---
url: /docs/01.前端/03. 工作技巧/getport.md
---

## 一个问题

前段时间，公司项目改版登录，所有管理后台、大屏可视化或者说电脑 web 端的登录做成了一个模块统一授权登录，登录的域名是配置出来的，等他们联调完之后，我发现我本地项目跑起来后登录不了啦，找相关开发人员了解情况后才知道后端限制了 `localhost` 的访问(就离谱)

他们推荐前端开发人员本地安装 nginx，配置本机 hosts，用 nginx 做跳转，后端可访问域名白名单中添加有我们 hosts 中配置的域名

我是习惯了项目跑完后点击项目启动完成后的提示信息跳转页面进行开发(主要我不想本地配 nginx)，继续与他们交谈我了解到后端允许 127.0.0.1 进行接口访问，只需要在公共开发平台配置一下即可，于是我有了一个想法，[更改终端提示信息](#更改终端提示信息)

既然他们支持在开发平台里面配置一个访问接口域名，那把 `127.0.0.1:port` 配置上去，然后在项目跑完后终端的提示信息里面加上 127.0.0.1:port 不就可以了

## vue-cli 是怎么做的

翻了下 vue-cli 的源码，它是在跑完项目后用 console.log 打印出来最终的访问项目地址，代码在 `@vue/cli-service/lib/commands/serve.js` 第 261 行

但我们已经不能直接像 vue-cli 这样直接打印我们的要使用的，我们得换个方法

记得 vue-cli 终端错误提示信息用的好像是 `friendly-errors-webpack-plugin` 插件进行更改提示的，不自信的我又进入了 `@vue/cli-service` 里面看代码，终于在 `@vue/cli-service/lib/config/base.js` 中找到了，cli 定义了 `friendly-errors` 使用了 `@soda/friendly-errors-webpack-plugin` 插件，并传入 vue 自定义的格式化和转换器来解析错误信息

## 更改终端提示信息

那就修改 `vue.config.js` 把 `127.0.0.1:port` 提示加上

```js
const port = 8080;
const publicPath = '/admin';
module.exports = {
  // 省略其他配置
  chainWebpack: config => {
    // 获取到 friendly-errors 的配置
    const friendErrorConf = config.plugin('friendly-errors').store.get('args')[0];
    const developRun = `http://127.0.0.1:${port}${publicPath}`;
    // 为编译成功信息添加一个 notes
    friendErrorConf.compilationSuccessInfo = {
      notes: [
        `Local development, click here: ${chalk.hex('#ee776d')(developRun)}`,
        // 把项目文件夹也贴上去吧，省得每次新开终端都要一层层进入打开项目
        `Project Directory: ${chalk.hex('#66d9ef')(process.cwd())}`,
      ],
    };
    // 最后在添加到这个配置上面就可以了
    config.plugin('friendly-errors').use(require('@soda/friendly-errors-webpack-plugin'), [friendErrorConf]);
  },
};
```

这下终于还可以保持之前的操作习惯，每次项目编译完成之后，直接点击提示信息进行项目的访问了，而且对新人也比较友好，新来的同学也不需要进行一大堆配置才可以访问本地跑起来的项目了

这就完了嘛？不，还没正式开始呢！因为这根本没考虑到端口被占用情况，端口如果被占用了，cli 的提示端口会自增 1，而我们提示的还是项目配置的端口，这可不是我们想要的

## portfinder

接下来我们正式进入主题：如何优雅的解决端口被占用的问题。vue-cli 使用 [portfinder](https://github.com/http-party/node-portfinder) 做端口检测，若发现端口被占用则端口自增 1，webpack 默认也是支持的(不配置 devServer.port 的情况下)，貌似也是用了 portfinder

代码在 `@vue/cli-service/lib/commands/serve.js` 中第 107 行，这里使用了 portfinder 去查找了可用端口

于是我兴冲冲的把代码改了一下加上了一句 `await getPortPromise({ port })`，结果发现加的那个提示没出来，这下我才知道事情远远没有我想的那么简单

## 预执行插件

查了一下资料发现原来 `vue.config.js` 里面并不支持异步代码，或者说异步代码是不会生效的，但查找端口是一个异步操作，那怎样才能在 vue.config 的 chainWebpack 里面支持异步呢，最后在一个 [issues](https://github.com/vuejs/vue-cli/issues/3328) 里找到了相关问题，虽然作者没有直接解决，但是也给出了一个解决方法：那就是给 npm run serve 添加一层 wrap

思路：

1. 在外面拿到数据，外层 wrap 函数是我们自定义的，所以可以支持异步，所以我们就等异步回来之后在跑项目
2. 首先新建一个 `serve.prehandle.js` 用于 wrap，先异步的拿到可用的 port

```js
// serve.prehandle.js
const portfinder = require('portfinder');
const isDevEnv = process.env.NODE_ENV !== 'production';

module.exports = (api, options) => {
  api.registerCommand('serve:prehandle', async args => {
    if (isDevEnv) {
      portfinder.basePort = process.env.PORT || 8080;
      // 把获取到的可用端口存到 process 对象上
      process.finderPort = await portfinder.getPortPromise();
    }
    await api.service.run('serve', args);
  });
};

module.exports.defaultModes = {
  'serve:prehandle': 'development',
};
```

3. 修改 `package.json`

* `scripts.serve` 修改为 `vue-cli-service serve:prehandle`
* 增加 `vuePlugins`，对应上面的 `serve:prehandle` 命令，为这条命令指定处理文件

```json
// package.json 更改
{
  "scripts": {
    "serve": "vue-cli-service serve:prehandle"
  },
  "vuePlugins": {
    "service": ["serve.prehandle.js"]
  }
}
```

4. 修改 `vue.config.js` 接收数据，上面我们存在了 process 对象里面 `process.finderPort`，最后执行 `npm run serve` 即可生效

```js
module.exports = {
  // 省略其他配置
  chainWebpack: config => {
    const friendErrorConf = config.plugin('friendly-errors').store.get('args')[0];
    // 把之前写死的 port 换成 process.finderPort
    const developRun = `http://127.0.0.1:${process.finderPort}${publicPath}`;
    friendErrorConf.compilationSuccessInfo = {
      notes: [
        `Local development, click here: ${chalk.hex('#ee776d')(developRun)}`,
        // 把项目文件夹也贴上去吧，省得每次新开终端都需要一层层进入打开项目
        `Project Directory: ${chalk.hex('#66d9ef')(process.cwd())}`,
      ],
    };
    config.plugin('friendly-errors').use(require('@soda/friendly-errors-webpack-plugin'), [friendErrorConf]);
  },
};
```

此时我们就成功的解决了这个问题，每次运行完成项目，上下两个端口是保持一致的，即使端口被占用了也是一样

## portfinder 源码分析

做完了上面这些工作后，我突然就对 [portfinder](https://github.com/http-party/node-portfinder) 很感兴趣，打算去研究一下他是怎么做到 port 被占用后自增 1 的，于是就看了一下源码，他的源码还是比较容易阅读和理解的，总共不到 500 行代码

### 核心代码

1. 利用 net 模块创建一个 server
2. 用这个 server 去监听 error 和 listening 事件
3. 如果监听成功 listening，则返回 port；触发 error 事件则判断 errorCode 是被占用或者没权限时则让端口自增 1 后重复上述操作

```js
const net = require('net');
const server = net.createServer();

const highestPort = 65535;

const nextPort = port => port + 1;

function testPort(port, callback) {
  port = +port;
  function onListen() {
    callback(null, port);
    server.removeListener('error', onError);
    server.close();
  }

  function onError(err) {
    server.removeListener('listening', onListen);
    // 如果端口不是被占用或者没权限则抛出异常等待后续程序处理，1024 以下的端口普通用户是没有权限的
    if (!(err.code == 'EADDRINUSE' || err.code == 'EACCES')) {
      return callback(err);
    }
    const _nextPort = nextPort(port);
    if (_nextPort > highestPort) {
      return callback(new Error('No open ports available'));
    }
    testPort(_nextPort);
  }
  server.once('error', onError);
  server.once('listening', onListen);
  server.listen(port);
}
```

科普一下：

1. `EADDRINUSE`怎么就知道端口被占用了呢，拆开来翻译 `E ADDR IN USE`，完整的单词就是 `error address in use`
2. `EACCES` 也一样就是没有访问权限呗

### 获取所有主机

当然上面的代码不能确定某个端口就被占用了，因为没传递 host 呀，没传递 host 的话服务器将监听来自于任何客户端的连接。所以我们需要保证 host+port 都没有被占用才算找到一个合适端口

所以我们需要先利用 `os` 模块去获取本机所有 host 存到一个队列里，然后循环这个队列利用上面的 testPort 把 host+port 一起带过去检测端口是否被占用，如果都没有被占用，才算找到一个合适的端口

```js
// 获取所有主机
const defaultHosts = (function() {
  const interfaces = os.networkInterfaces();
  const interfaceNames = Object.keys(interfaces);
  const results = ['0.0.0.0'];
  for (let i = 0; i < interfaceNames.length; i++) {
    const _interface = interfaces[interfaceNames[i]];
    for (let j = 0; j < _interface.length; j++) {
      const cur = _interface[j];
      results.push(cur.address);
    }
  }
  results.push(null);
  return results;
})();
```

### 遍历主机拼上端口去查询

源码里面使用了 [async](https://github.com/caolan/async) 模块遍历获取到的 host，然后去调用 testPort 方法，传入 host 和 port，判断 testPort 返回结果

1. 如果正常，换下一个 host 重复调用，并把当前的 `port` 存到一个`新的队列里`

2) 如果中途代码异常了：

* 判断错误码是不是 `EADDRNOTAVAIL` 或者 `EINVAL`，地址无效或者不合法的时候就需要在 host 队列里面删掉这个 host，然后继续执行
* 否则就是真的出错了，结束程序抛出异常（在 testPort 里面已经判断过地址被占用了）

3. 重复执行上面的操作，直到遍历完所有合法的 host

4. 遍历完所有 host 后，对成功的 port 队列进行一次排序，然后判断第一个和最后一个端口是否一样

* 如果一样则说明随便一个端口都是可用的返回其中一个端口即可
* 如果不一样则拿出最后一个端口再次执行该方法

科普一下：Async 是一个很实用的模块，它为异步 JavaScript 提供了简单而强大的功能。虽然最初设计是为了与 Node.js 一起使用，但它也可以直接在浏览器中使用。

## 实现一个 portfinder

已经知道 portfinder 的大体思路了，我们来实现一下 portfinder 的 getPort 和 getPortPromise 两个方法

```js
const net = require('net');
const os = require('os');
const highestPort = 65535;

// 记录所有成功的端口
let openPorts = [];

const nextPort = port => port + 1;

const defaultHosts = (function() {
  const interfaces = os.networkInterfaces();
  const interfaceNames = Object.keys(interfaces);
  const results = ['0.0.0.0'];
  for (let i = 0; i < interfaceNames.length; i++) {
    const _interface = interfaces[interfaceNames[i]];
    for (let j = 0; j < _interface.length; j++) {
      const cur = _interface[j];
      results.push(cur.address);
    }
  }
  results.push(null);
  return results;
})();

function testPort({ port, host, server }, callback) {
  server = server || net.createServer();
  port = +port;
  function onListen() {
    server.removeListener('error', onError);
    server.close();
    callback(null, port);
  }

  function onError(err) {
    server.removeListener('listening', onListen);

    if (!(err.code === 'EADDRINUSE' || err.code === 'EACCES')) {
      // 地址被占用（E ADDR IN USE）或者没有访问权限
      return callback(err);
    }
    const _nextPort = nextPort(port);
    if (_nextPort > highestPort) {
      return callback(new Error('No open ports available'));
    }
    testPort({ port: _nextPort, host, server }, callback);
  }
  server.once('error', onError);
  server.once('listening', onListen);
  if (host) {
    server.listen(port, host);
  } else {
    server.listen(port);
  }
}

function getPortCore(options, callback, execIndex) {
  const port = options.port;
  // 处理 host
  if (options.host) {
    let hasUserGivenHost;
    for (let i = 0; i < defaultHosts.length; i++) {
      if (defaultHosts[i] === options.host) {
        hasUserGivenHost = true;
        break;
      }
    }
    if (!hasUserGivenHost) {
      defaultHosts.push(options.host);
    }
  }
  exec();
  function exec(index) {
    index = index || execIndex || 0;
    if (index > defaultHosts.length) return callback(null, port);
    const host = defaultHosts[index];
    testPort({ port, host }, (err, data) => {
      if (!err) {
        openPorts.push(data);
        return exec(index + 1);
      }
      if (err.code === 'EADDRNOTAVAIL' || err.code === 'EINVAL') {
        // 如果得到EADDRNOTAVAIL，它意味着主机是不可绑定的，所以删除它，EINVAL也一样
        const idx = defaultHosts.indexOf(host);
        defaultHosts.splice(idx, 1);
        getPortCore({ port, host: defaultHosts[index] }, callback, index);
      } else {
        return callback(err);
      }
    });
  }
}

function getPort(options, callback) {
  getPortCore(options, err => {
    if (err) return callback(err);
    openPorts = openPorts.sort((a, b) => a - b);
    if (openPorts[0] === openPorts[openPorts.length - 1]) {
      // 说明都一样，返回随便返回一个都能用
      return callback(null, openPorts[0]);
    } else {
      // 拿着最大的端口再查询一次
      return getPortCore({ port: openPorts.pop(), host: options.host }, callback);
    }
  });
}

function getPortPromise(options) {
  return new Promise((resolve, reject) => {
    getPort(options, (err, data) => {
      if (err) return reject(err);
      return resolve(data);
    });
  });
}

module.exports = { getPort, getPortPromise };

// getPortPromise({ port: 8084 }).then(res => {
//   console.log(res, "final");
// });
```

## 参考链接

* [vue.config.js 中 chainWebpack 支持异步数据](https://segmentfault.com/a/1190000039661767)

---

---
url: /docs/01.前端/02. 代码实现/promise.md
---

> 曾面试自己心仪的公司，要求手写一个 `Promise`，当时未能解出，很是遗憾，如今整理一下这个异步的解决方案。

`promise` 的出现改变了以前 js 的回调风格。`promise` 核心是三种状态，`pending、resolve、reject`，状态一旦从 `pending` 变成其他状态则不可逆，其他用法细节将在实现 `promise` 的过程中一步步记录

## 简单版 promise

* 首先我们实现函数异步函数执行的问题

```js
// 首先是三种状态
const PENDING = 'pending';
const RESOLVED = 'resolve';
const REJECTED = 'reject';

function Promise(execute) {
  this.status = PENDING;
  // 存放成功时传递的值和失败传递的原因
  this.value = null;
  this.reason = null;
  // 回调队列
  this.onResolvedCallbacks = [];
  this.onRejectedCallbacks = [];
  const resolve = value => {
    // 状态不可逆，只有在 pending 的时候才可以改变自身的状态
    if (this.status === PENDING) {
      this.status = RESOLVED;
      this.value = value;
      // 状态发生改变的时候查看异步队列里面是否有函数，如果有就执行
      this.onResolvedCallbacks.forEach(fn => fn());
    }
  };
  const reject = reason => {
    if ((this.status = PENDING)) {
      this.status = REJECTED;
      this.reason = reason;
      this.onRejectedCallbacks.forEach(fn => fn());
    }
  };
  // Promise 内部的默认执行函数
  execute(resolve, reject);
}

Promise.prototype.then = function(onFulfilled, onRejected) {
  const self = this;
  if (self.status === RESOLVED) {
    onFulfilled(self.value);
  }
  if (self.status === REJECTED) {
    onRejected(self.reason);
  }
  if (self.status === PENDING) {
    this.onResolvedCallbacks.push(function() {
      onFulfilled(self.value);
    });
    this.onRejectedCallbacks.push(function() {
      onRejected(self.reason);
    });
  }
};
// 返回 Promise 便于测试
module.exports = Promise;
```

测试基本版的 `promise`

```js
// 测试基础版本的 promise
const Promise = require('./promise');
const p = new Promise((resolve, reject) => {
  // 测试异步
  setTimeout(() => {
    reject(1000);
  }, 2000);
  // 测试同步
  // reject('异常')
  // resolve('正常')
});
p.then(
  data => console.log(data),
  err => {
    console.log(err, '出错了');
  }
);
// 测试第二次 then
p.then(
  data => console.log(data),
  err => {
    console.log(err, '出错了');
  }
);
```

## then 方法补充

* promise 中的 then 方法必须返回一个 promise，Promise A+ 规范上 2.2.7 中有提到
* 所以再次调用 then 后需要返回一个全新的 promise
* 所以我们需要拿到 then 方法成功或者失败后的返回值
* 修改基础代码，把 then 方法补充完整

```js
const PENDING = 'pending';
const RESOLVED = 'resolve';
const REJECTED = 'reject';

function Promise(execute) {
  this.status = PENDING;
  // 存放成功时传递的值和失败传递的原因
  this.value = null;
  this.reason = null;
  // 回调队列
  this.onResolvedCallbacks = [];
  this.onRejectedCallbacks = [];
  const resolve = value => {
    // 状态不可逆，只有在 pending 的时候才可以改变自身的状态
    if (this.status === PENDING) {
      // 如果 resolve 里面值还是一个 promise 的话，那就递归处理一下
      if (value instanceof Promise) {
        return value.then(resolve, reject);
      }
      this.status = RESOLVED;
      this.value = value;
      // 状态发生改变的时候查看异步队列里面是否有函数，如果有就执行
      this.onResolvedCallbacks.forEach(fn => fn());
    }
  };
  const reject = reason => {
    if ((this.status = PENDING)) {
      this.status = REJECTED;
      this.reason = reason;
      this.onRejectedCallbacks.forEach(fn => fn());
    }
  };
  execute(resolve, reject);
}

/**
 * 判断 x 和 promise 的关系，如果 x 和 promise 是一样的，那么抛出异常，不可以让自己等待自己完成，规范 2.3.1 提到
 * 如果 x 是普通值的话，直接调 resolve 即可
 * 如果 x 是一个引用类型的话，要考虑是不是 promise 函数
 * 如果不是函数的话，直接当做普通值 resolve 即可
 * 如果是函数的话那么就认为他是一个 promise 函数
 * 那么此时就让这个 函数的 then 的执行并且绑定这个 x，传入两个函数，不同的函数中执行不同的结果
 * @param {*} promise2
 * @param {*} x
 * @param {*} resolve
 * @param {*} reject
 */
function resolvePromise(promise2, x, resolve, reject) {
  if (x === promise2) return reject(new TypeError('循环引用了'));
  // 判断是不是引用类型或者普通值，普通直接返回
  // 引用类型在做处理
  if ((typeof x === 'object' && x !== null) || typeof x === 'function') {
    try {
      const then = x.then;
      // 如果 x 中有 then，那么就认为这个 then 是一个 promise，规范 2.3.3.3
      if (typeof then === 'function') {
        then.call(
          x,
          y => {
            // 此时 y 还可能是一个 promise，所以需要递归处理一下
            resolvePromise(promise2, y, resolve, reject);
          },
          r => reject(r)
        );
      } else {
        resolve(x);
      }
    } catch (e) {
      reject(e);
    }
  } else {
    resolve(x);
  }
}

Promise.prototype.then = function(onFulfilled, onRejected) {
  // 参数的可选性
  // 如果没有传递成功的值，那么我们给自动传递过去，这个叫做值得穿透，保证可以在后面捕获到异常
  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val;
  // 如果错误没有传递，那我们手动传递过去
  onRejected = typeof onRejected === 'function' ? onRejected : err => throw err;

  const self = this;
  // then方法必须返回一个新的 promise
  const _promise = new Promise((resolve, reject) => {
    if (self.status === RESOLVED) {
      setTimeout(() => {
        try {
          // then 方法中可能直接出现异常，所以 try catch 下
          const x = onFulfilled(self.value);
          // 需要一个方法处理 promise 中 then 方法
          // 我们要在自身中使用自身，自身还没有创建完毕了，所以我们需要异常处理一下才可以取到 _promise
          // 在 Notes 3.1 中提到，这种情况我们可以使用 setTimeout 来实现
          resolvePromise(_promise, x, resolve, reject);
        } catch (e) {
          reject(e);
        }
      });
    }
    if (self.status === REJECTED) {
      setTimeout(() => {
        try {
          const x = onRejected(self.reason);
          resolvePromise(_promise, x, resolve, reject);
        } catch (e) {
          reject(e);
        }
      });
    }
    if (self.status === PENDING) {
      this.onResolvedCallbacks.push(function() {
        setTimeout(() => {
          try {
            const x = onFulfilled(self.value);
            resolvePromise(_promise, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        });
      });
      this.onRejectedCallbacks.push(function() {
        setTimeout(() => {
          try {
            const x = onRejected(self.reason);
            resolvePromise(_promise, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        });
      });
    }
  });
  return _promise;
};

module.exports = Promise;
```

测试 `promise`

```js
// 测试代码
const Promise = require('./promise');

const p = new Promise((resolve, reject) => {
  // setTimeout(() => {
  //   // resolve('情人节到了')
  //   // resolve(1000)
  //   reject(1000)
  // }, 2000)
  // reject('情人节到了')
  resolve('情人节到了');
});
p.then(
  data => console.log(data),
  err => console.log(err, '出错了');
);
// p.then(data => console.log(data))

// let p2 = p.then(data => {
//   // return data
//   // throw data
//   // 如果自己返回自己，自己等待着自己完成，那么当前就应该走向失败
//   // return p2
//   return new Promise((resolve, reject) => {
//     setTimeout(function() {
//       // reject(1000)
//       resolve(10000)
//     }, 2000)
//   })
// })

const p2 = p.then(data => {
  // 可能有人会这么做
  return new Promise((resolve, reject) => {
    setTimeout(function() {
      resolve(
        new Promise((resolve, reject) => {
          setTimeout(function() {
            resolve(
              new Promise((resolve, reject) => {
                resolve(3000);
              })
            );
          }, 1000);
        })
      );
    }, 1000);
  });
});

p2.then(
  data => {
    console.log(data, '???');
  },
  err => {
    console.log(err, '失败？？？');
  }
);
```

## catch 方法

其实 `catch` 方法就是 是一个 `p.then(null, err => console.log(err)` 的语法糖，所以 `catch` 的实现也很简单

```js
Promise.prototype.catch = function(errCallback) {
  return this.then(null, errCallback);
};
```

## 静态方法

在 `Promise` 的构造函数中提供了几个静态函数，可以直接来处理值，实现如下

### resolve

```js
Promise.resolve = function(value) {
  return new Promise((resolve, reject) => {
    resolve(value);
  });
};
```

### reject

```js
Promise.reject = function(reason) {
  return new Promise((resolve, reject) => {
    reject(reason);
  });
};
```

### all

Promise.all 方法的可处理并发问题，而且返回值会保证代码的传入值的顺序，所以要处理好这个问题

```js
Promise.all = function(prs) {
  return new Promise((resolve, reject) => {
    const result = [];
    let count = 0;
    const processData = (idx, val) => {
      result[idx] = val;
      if (++count === prs.length) resolve(result);
    };
    prs.forEach((p, i) => {
      const then = p.then;
      if (then && typeof then === 'function') {
        then.call(p, y => processData(i, y), reject);
      } else {
        processData(i, p);
      }
    });
  });
};
```

```js
// 也可以这么写
Promise.all = function(prs) {
  let counter = 0,
    result = [];
  return new Promise2((resolve, reject) => {
    prs.forEach((p, idx) => {
      // 直接封装成 promise 然后执行
      Promise.resolve(p).then(val => {
        result[idx] = val;
        if (++counter === prs.length) {
          resolve(result);
        }
      }, reject);
    });
  });
};
```

### race

`race` 是一个赛跑方法，在 `promise` 中被称为竞态，谁先有结果要谁，不管成功还是失败只要第一个有结果的

传入值如果是一个空数组的话，`promise` 永远不会有结果，而不是立刻就有结果

```js
Promise.race = function(prs) {
  return new Promise((resolve, reject) => {
    prs.forEach(pr => {
      const then = pr.then;
      if (then && typeof then === 'function') {
        then.call(pr, y => resolve(y), reject);
      } else {
        resolve(pr);
      }
    });
  });
};
```

## deferred

有个测试 `promise` 的库 `promises-aplus-tests`，需要我们提供这么一个方法，然后用来测试 `promise` 是否符合规范

```js
Promise.deferred = function() {
  const dfd = {};
  dfd.promise = new Promise((resolve, reject) => {
    dfd.resolve = resolve;
    dfd.reject = reject;
  });
  return dfd;
};
```

这个方法有什么用？其实这个方法可以用来做延迟函数

```js
// deferred 的使用
function read(url) {
  const defer = Promise.deferred();
  fs.readFile(url, 'utf8', (err, data) => {
    if (err) return defer.reject(err);
    defer.resolve(data);
  });
  return defer.promise;
}

const url = path.resolve(__dirname, './name.txt');
read(url).then(
  data => {
    console.log(data);
  },
  err => {
    console.log(err);
  }
);
```

## promise 拓展方法

虽然 `Promise` 中提供了 `all` 和 `race` 两个模式，但是很可以拓展其他的变体

### first

只要第一个 `Promise` 完成，它就会忽略后续的任何拒绝和完成

```js
// first 的实现
if (!Promise.first) {
  Promise.first = function(prs) {
    return new Promise((resolve, reject) => {
      prs.forEach(pr => {
        Promise.resolve(pr)
          // first 只取第一次执行成功的方法
          .then(resolve);
      });
    });
  };
}
```

### last

`last` 类似于 `first`，但是是取最后一个完成的结果

```js
// last 的实现
if (!Promise.last) {
  Promise.last = function(prs) {
    return new Promise((resolve, reject) => {
      const len = prs.length;
      let num = 0;
      prs.forEach(pr => {
        Promise.resolve(pr).then(res => {
          num++;
          if (num === len) {
            // 如果是最后一项，则执行最后一下的结果
            resolve(res);
          }
        });
      });
    });
  };
}
```

```js
// 测试
Promise.first([Promise.reject(1), Promise.resolve(2)]).then(res => {
  console.log(res, 'first');
});
Promise.last([1, Promise.resolve(2)]).then(res => {
  console.log(res, 'last');
});
// 测试结果：
// 2 'first'
// 2 'last'
```

### map

有时候需要在一列 `Promise` 中迭代，并对所有的 `Promise` 都执行某个任务，非常类似于数组可以做的那样（比如 forEach、map 等），如果这些任务是同步的那这些任务就可以做，但是从根本上上来说 `Promise` 任务是异步的，所以我们需要一个类似的工具方法

```js
// Promise.map 的实现
if (!Promise.map) {
  Promise.map = function(vals, cb) {
    return Promise.all(
      vals.map(val => {
        return new Promise((resolve, reject) => {
          cb(val, resolve, reject);
        });
      })
    );
  };
}

// 测试
const p1 = Promise.resolve(21);
const p2 = 42;
// const p3 = Promise.reject('failed')
Promise.map([p1, p2], function(val, done, failed) {
  // 保证 val 是 Promise，统一格式
  Promise.resolve(val).then(res => {
    done(res * 2);
    //  捕获失败的情况
  }, failed);
})
  .then(result => {
    console.log(result, 'result');
  })
  .catch(e => {
    console.log(e, 'e');
  });

// 最终输出结果是，如果加上一个失败的 promise 该函数也是可以捕获的哦
// [42, 84]
```

## promisify

在 `node` 中，所有方法都是错误优先，所以在核心模块 `util` 中有个 `promisify` 方法，来把 `node` 中的异步方法处理成 `promise`

比如有以下场景：我不可能每次写一个方法都这么封装一次 `promise`，太麻烦了，所以出现了一个把函数 `promise` 化

```js
function read(url) {
  return new Promise((resolve, reject) => {
    fs.readFile(url, 'utf8', (err, data) => {
      if (err) return reject(err);
      resolve(data);
    });
  });
}
```

模拟以下实现过程：

1. 首先 `promisify` 是把一个函数 `promise` 化，那么肯定接受一个函数为参数
2. 然后 `promise` 化之后应该首先返回一个函数，然后可以调 `then` 方法
3. 也就是说应该先返回一个函数，然后函数中返回一个 `promise`

```js
function promisify(fn) {
  return function() {
    return new Promise((resolve, reject) => {
      fn(...arguments, (err, data) => {
        if (err) reject(err);
        resolve(data);
      });
    });
  };
}
```

## promisifyAll

如上的 promisify 我们可以把一个对象里面的所有方法转换成 promise，所以可以写一个 promisifyAll 方法来处理

```js
// 不常用
function promisifyAll(obj) {
  if (typeof obj[key] === 'function') {
    obj[key + 'Async'] = promisify(obj[key]);
  }
}

// 使用
promisifyAll(fs);
fs.readFileAsync(url, 'utf8').then(res => {
  console.log(res, 'promisifyAll');
});
```

## 参考文献

* 珠峰培训架构课程
* 《你不知道的 JavaScript》中卷

---

---
url: /docs/01.前端/03. 工作技巧/tree.md
---

## 前言

在工作中我们经常见到用树的场景，比如说写前端页面时，每个页面就有对应的 DOM 树、CSSOM 树、渲染树等，或者开发过程中的写的级联选择器、菜单树、权限树、人员树等

面试的时候会被问到算法相关的知识，而刷树相关的题，是特别培养算法思维的，回溯、动规、分治算法其实都是树的问题

本文将汇总一些工作中常用的一些树的操作以及面试可能会问到二叉树相关的问题

## 文章导览

## 树（工作）

一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及 0 个或多个子节点：

* 节点：树中的每个元素都叫作节点
* 根节点：位于树顶部的节点叫作根节点
* 内部节点/分支节点：至少有一个子节点的节点称为内部节点或
* 外部节点/叶节点：没有子元素的节点称为外部节点或叶节点
* 子女节点：B 和 C 为 A 的子女节点
* 父节点：D 为 H 和 I 的父节点
* 兄弟节点：同一个父节点的子女节点互称为兄弟；F 和 G 互为兄弟节点
* 祖先节点：从根节点到该节点所经过分支上的所有节点；如节点 H 的祖先节点为 D，B，A
* 子孙节点：以某一节点构成的子树，其下所有节点均为其子孙节点；如 H 和 I 为 D 的子孙节点
* 节点所在层次：根节点为 1 层，依次向下
* 树的深度：树中距离根节点最远的节点所处的层次就是树的深度；图中，树的深度是 4
* 节点的度：结点拥有子结点的数量
* 树的度：树中节点的度的最大值

本节将会拿着 `elementUI` 级联选择器里面的[原始数据](https://chengyuming.cn/file/tree.json)，一步步的为这棵树增加 id、level 和 parentId，以及各种查找这棵树，彻底搞懂工作中用到树的各种套路

### 遍历树

1. 树的遍历分为 `广度优先` 遍历和 `深度优先` 遍历两种。

2. 深度优先是用 `递归` 来实现的，广度优先是 `循环` 来实现。

3. 深度优先是利用 `栈` 结构来处理的，广度优先是 `队列` 结构

4. 深度优先遍历又分为先序遍历、后序遍历，二叉树还有中序遍历，实现方法可以是递归，也可以是循环。

5. 深度优先：访问完一棵子树再去访问后面的子树，而访问子树的时候，先访问根再访问根的子树，称为先序遍历；先访问子树再访问根，称为后序遍历。

6. 广度优先：访问树结构的第 n+1 层前必须先访问完第 n 层

7. 树的操作基本上都是 O(n) 的，我们只访问一次节点即可，不管是递归还是循环，有人说递归的性能低于循环，其实他们的时间复杂度是一样的，唯一的差距我感觉是递归的时候调用栈会占用一些性能

8. 遍历的时候我们就偷偷的把 id 给他加上了，最外层开始从 1 自增

#### 广度优先

广度优先遍历的思路是维护一个队列，队列初始值是这棵树的根节点， `取出队列第一个元素，进行访问操作，然后将孩子节点追加到队列最后` ，重复执行该操作

```js
let id = 1;
// 接受一个回调函数，来进行访问操作
function bfs(tree, cb) {
  if (!tree) return;
  const queue = [...tree];
  while (queue.length) {
    const node = queue.shift();
    // 遍历的时候给树增加个 id，方便后面的使用
    node.id = id++;
    cb && cb(node);
    node.children && queue.push(...node.children);
  }
}
```

#### 深度优先

深度优先遍历又分为先序遍历和后序遍历

* 先序遍历

```js
function dfs(tree, cb) {
  if (!tree) return;
  for (let i = 0; i < tree.length; i++) {
    const node = tree[i];
    cb && cb(node);
    node.children && dfs(node.children, cb);
  }
}
```

* 后序遍历

后序遍历只需要调换一下节点遍历和子树遍历的顺序即可

```js
function dfs(tree, cb) {
  if (!tree) return;
  for (let i = 0; i < tree.length; i++) {
    const node = tree[i];
    node.children && dfs(node.children, cb);
    cb && cb(node);
  }
}
```

### 过滤树

过滤树就跟深度优先遍历树差不多，只要不停地满足过滤函数即可过滤出我们想要的节点

```js
function filterTree(tree, cb) {
  if (!tree) return [];
  return tree.filter(node => {
    node.children = filterTree(node.children, cb);
    return cb(node) || (node.children && node.children.length);
  });
}
```

### 树的查找

树的查找其实就是也是一个遍历的过程，遍历到满足条件的节点则返回该节点，遍历完成未找到则返回 null

#### 根据 id 查找节点

```js
function getNodeById(tree, id) {
  if (!tree || !tree.length) return null;
  for (let i = 0; i < tree.length; i++) {
    const node = tree[i];
    if (+node.id === +id) return node;
    return node.children && getNodeById(node.children, id);
  }
  return null;
}
```

#### 根据回调查找节点

思路基本一致

```js
function treeFind(tree, cb) {
  if (!tree || !tree.length) return null;
  if (!cb || typeof cb !== 'function') return null;
  for (let i = 0; i < tree.length; i++) {
    const node = tree[i];
    if (cb(node)) return node;
    return node.children && treeFind(node.children, cb);
  }
  return null;
}
```

#### 查找节点路径

思路是一致的，但是这个要额外记录一下访问过的节点，最终返回所有访问过的节点

```js
function treeFindPath(tree, cb, path = []) {
  if (!tree || !tree.length) return null;
  if (!cb || typeof cb !== 'function') return null;
  for (let i = 0; i < tree.length; i++) {
    const node = tree[i];
    path.push(node.id);
    if (cb(node)) return path;
    if (node.children) {
      return treeFindPath(node.children, cb, path);
    } else {
      path.pop();
    }
  }
  return [];
}
```

#### 查找多条节点路径

```js
function treeFindPath2(tree, cb, path = [], res = []) {
  if (!tree || !tree.length) return null;
  if (!cb || typeof cb !== 'function') return null;
  for (let i = 0; i < tree.length; i++) {
    const node = tree[i];
    path.push(node.id);
    cb(node) && res.push([...path]);
    node.children && treeFindPath2(node.children, cb, path, res);
    path.pop();
  }
  return res;
}
```

### 给树增加 level

遍历树是很基础的操作，树操作大部分都是基于遍历来实现的，前几个是用深度优先来实现的，给树增加层级更适合用广度优先来实现

```js
function treeAddLevel(tree) {
  const queue = [...tree];
  let level = 1;
  while (queue.length) {
    const len = queue.length;
    for (let i = 0; i < len; i++) {
      const node = queue.shift();
      node.level = level;
      if (node.children) {
        queue.push(...node.children);
      }
    }
    level++;
  }
}
```

处理完之后的[数据看这里](https://chengyuming.cn/file/treeLevel.json)，数据太长就不截图放到文章里了

### 给树增加 parentId

给树增加父级 id 又得用到深度优先。给一棵没有父级 id 的树增加 parentId，也是为了方便下面的[`树转数组`](#树转数组)的使用

```js
function addParentId(tree) {
  if (!tree || !tree.length) return;
  const root = tree[0];
  root.parentId = -1;
  add(tree[0].children, root.id);
  function add(tree, parentId) {
    if (!tree || !tree.length) return;
    for (let i = 0; i < tree.length; i++) {
      const node = tree[i];
      node.parentId = parentId;
      node.children && add(node.children, node.id);
    }
  }
  return tree;
}
```

处理完之后的[数据地址](https://chengyuming.cn/file/treeParentId.json)，到此这棵树就处理的差不多了，下面我们进行转成数组，然后在数组转成树的操作实践一下，这个操作工作面试的时候都容易出现

### 树转数组

树转数组就比较简单了，直接一个遍历即可，深度优先广度优先都行

```js
function tree2List(tree) {
  if (!tree || !tree.length) return [];
  const res = [];
  const queue = [...tree];
  while (queue.length) {
    for (let i = 0; i < queue.length; i++) {
      const node = queue.shift();
      const children = node.children;
      delete node.children;
      res.push(node);
      children && queue.push(...children);
    }
  }
  return res;
}
```

处理完之后的[数据地址](https://chengyuming.cn/file/treeArray.json)，下面我们要用这个数据在转成树

### 数组转树

工作中可能有这种数组转成树的需求，其实也比简单，遍历两次树，第一次把所有的 id 存到一个 map 中，第二次遍历处理这个数组

```js
function array2Tree(array) {
  const map = {};
  const root = [];
  array.forEach(x => (map[x.id] = x));
  array.forEach(node => {
    const parent = map[node.parentId];
    if (parent) {
      parent.children = parent.children || [];
      parent.children.push(node);
    } else {
      root.push(node); // 根据 parentId 找不到的节点就是根节点
    }
  });
  return root;
}
```

## 二叉树（面试）

二叉树（binary tree）是指树中节点的度不大于 2 的有序树，它是一种最简单且最重要的树。二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树（摘自百度百科）

说白了就是：二叉树是每个节点最多有两个子树的树结构，通常子树被称作 左子树 和 右子树。

二叉树在前端业务开发中不常见，但理解二叉树，对于学习算法是一个很重要的开始。有位大佬讲过所有回溯、动规、分治算法其实都是树的问题，而树的问题就永远逃不开树的递归遍历那几行代码

```js
function traverse(root) {
  // 前序遍历
  traverse(root.left);
  // 中序遍历
  traverse(root.right);
  // 后序遍历
}
```

### 二叉树遍历

遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有节点，使每一个节点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个节点转换成为一个线性序列来表示

二叉树遍历有前序遍历、中序遍历、后序遍历

1. 前序(pre-order)： 根-左-右
2. 中序(in-order)： 左-根-右
3. 后序(post-order)： 左-右-根

三种遍历对应代码如下：

```js
// 前序遍历
function preOrder(root) {
  const result = [];
  helper(root, result);
  function helper(root, result) {
    if (!root) return;
    result.push(root.val);
    helper(root.left, result);
    helper(root.right, result);
  }
  return result;
}
// 中序遍历
function inOrder(root) {
  const result = [];
  helper(root, result);
  function helper(root, result) {
    if (!root) return;
    helper(root.left, result);
    result.push(root.val);
    helper(root.right, result);
  }
  return result;
}
// 后序遍历
function postOrder(root) {
  const result = [];
  helper(root, result);
  function helper(root, result) {
    if (!root) return;
    helper(root.left, result);
    helper(root.right, result);
    result.push(root.val);
  }
  return result;
}
```

其实就是套用上面说到的遍历模板

### 二叉树按层遍历

二叉树遍历还有深度优先和广度优先遍历，有道经典面试题，就是按层遍历一棵二叉树，我们对下面这棵二叉树做遍历

```js
const root = {
  val: 'A',
  left: {
    val: 'B',
    left: {
      val: 'D',
      left: {
        val: 'G',
      },
      right: {
        val: 'H',
      },
    },
    right: {
      val: 'E',
    },
  },
  right: {
    val: 'C',
    left: {
      val: 'F',
      left: {
        val: 'I',
      },
    },
  },
};
// [ [ 'A' ], [ 'B', 'C' ], [ 'D', 'E', 'F' ], [ 'G', 'H', 'I' ] ]
```

1. 广度优先

按层遍历二叉树，首先想到广度优先容易实现

```js
function levelOrder(root) {
  if (!root) return [];
  const res = [];
  const queue = [root];
  while (queue.length) {
    const len = queue.length;
    const curLevel = [];
    for (let i = 0; i < len; i++) {
      const node = queue.shift();
      curLevel.push(node.val);
      node.left && queue.push(node.left);
      node.right && queue.push(node.right);
    }
    res.push(curLevel);
  }
  return res;
}
```

2. 深度优先

深度优先其实也是可以实现的，记录当前递归处理的层，开辟好空间即可

```js
function levelOrder(root) {
  if (!root) return;
  const res = [];
  dfs(root, 0);
  function dfs(node, level) {
    if (!node) return;
    if (res.length < level + 1) res[level] = [];
    res[level].push(node.val);
    dfs(node.left, level + 1);
    dfs(node.right, level + 1);
  }
  return res;
}
```

### 二叉树之字遍历

二叉树按照之字遍历，跟上面的二叉树按层遍历类似，按层遍历是每一层都是按照从左到右的顺序进行遍历

之字遍历是第一层按从左到右的顺序遍历，第二层反过来按照从右到左的顺序遍历，第三次正着，第四层反着...，以此类推

其实就是偶数层从左到右，奇数层从右到左(从 0 开始数数哦)，所以只需要维护一个自增变量即可

```js
function levelOrder(root) {
  if (!root) return [];
  const res = [];
  const queue = [root];
  let index = 0;
  while (queue.length) {
    const len = queue.length;
    const curLevel = [];
    for (let i = 0; i < len; i++) {
      const node = queue.shift();
      if (index % 2 === 0) {
        curLevel.push(node.val);
      } else {
        curLevel.unshift(node.val);
      }
      node.left && queue.push(node.left);
      node.right && queue.push(node.right);
    }
    res.push(curLevel);
    index++;
  }
  return res;
}
// [ [ 'A' ], [ 'C', 'B' ], [ 'D', 'E', 'F' ], [ 'I', 'H', 'G' ] ]
```

### 二叉树搜索树

二叉搜索树也叫有序二叉树、排序二叉树，是指一棵空树或者具有下列性质的二叉树：

1. 左子树上所有节点值均小于它的根节点的值
2. 右子树上所有节点值均大于他的根节点的值
3. 递归的左、右子树也分别为二叉查找树

上图便是一个二叉搜索树

### 二叉搜索树转有序数组

根据二叉搜索树的定义，可以知道我们只需要中序遍历一次，便可以实现这个功能

```js
function BST2Array(root) {
  if (!root) return [];
  return BST2Array(root.left).concat(root.val, BST2Array(root.right));
}
```

### 有序数组转二叉搜索树

用到二叉树就要有个生成二叉树的方法，二叉搜索树是可以与有序数组互转的，那就从它开始吧

思路：拿有序数组中间值创建当前节点，它的左子树取数组 0 到 mid 的地方，右子树取 mid + 1 到数组长度的地方，递归创建子树即可

```js
function TreeNode(val = 0, left = null, right = null) {
  this.val = val;
  this.left = left;
  this.right = right;
}
function array2BST(array) {
  const len = arr.length;
  if (!len) return null;
  const mid = parseInt(len / 2);
  const root = new TreeNode(arr[mid]);
  root.left = array2BST(arr.slice(0, mid));
  root.right = array2BST(arr.slice(mid + 1, len));
  return root;
}
```

### 验证二叉搜索树

1. 验证二叉搜索树首先想到中序遍历，中序遍历是按照 左->中->右 的顺序遍历树，如果结果是一个有序数组，那么说明这是一个二叉搜索树，可以参考上面的`中序遍历`或者`二叉搜索树转有序数组`，最终得到结果在跟预想的结果比较一次，需要对数组进行排序(O(logn))，所以时间复杂度会相对高一点

2. 第二种方法是我们记录上一次访问的节点，去和这次访问的节点进行比较，如果是一个递增的关系则说明是一个二叉搜索树

```js
function isValid(root) {
  if (!root) return true;
  let prev = null;
  function helper(root) {
    if (!root) return true;
    if (!helper(root.left)) return false;
    if (prev && prev.val >= root.val) return false;
    prev = root;
    return helper(root.right);
  }
  return helper(root);
}
```

3. 另一种方法是记录最大值和最小值，然后与当前值进行比较，只要在 min 和 max 之间就是合法的，否则就不是一个二叉搜索树

```js
function isValid(root, min, max) {
  if (!root) return true;
  if (min != null && root.val <= min) return false;
  if (max != null && root.val >= max) return false;
  return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);
}
```

### 最大深度最小深度

最大深度直接用 Math.max 取左子树和右子树两者深度的最大值即可

```js
function maxDepth(root) {
  if (!root) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
```

最小深度需要考虑没有左右子树的情况，所以不能直接用 Math.min 取值

```js
function minDepth(root) {
  if (!root) return 0;
  // 考虑没有左子树或者右子树的情况
  if (!root.left) return 1 + minDepth(root.right);
  if (!root.right) return 1 + minDepth(root.left);
  const left = minDepth(root.left);
  const right = minDepth(root.right);
  return 1 + Math.min(left, right);
}
```

或者也可以更简洁一点

```js
function minDepth(root) {
  if (!root) return 0;
  const left = minDepth(root.left);
  const right = minDepth(root.right);
  return left === 0 || right === 0 ? left + right + 1 : Math.min(left, right) + 1;
}
```

### 最近公共祖先

这道题只要当前访问的节点值是 p 或者 q 的话就可以返回当前节点

然后递归的访问左子树和右子树，如果左子树返回为空那么就不用在继续查下去了直接查右子树就可以了，如果右子树返回为空也是如此，递归的重复这个步骤，当发现左子树和右子树都可以查得到的时候就找到公共祖先了，如果最后都没找到那么根节点就是公共祖先

```js
function lowestCommonAncestor(root, p, q) {
  if (!root) return null;
  if (root.val === p || root.val === q) return root;
  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);
  if (!left) return right;
  if (!right) return left;
  return root;
}
```

如果是一棵二叉搜索树的话就比较简单了，只需要判断当前的值和 p、q 的大小即可

如果同时小于 p 和 q，说明公共祖先在右子树里面那就去右子树里面找，如果同时大于 p 和 q，就去左子树里面找

```js
function lowestCommonAncestor(root, p, q) {
  if (!root) return null;
  if (root.val > p && root.val > q) {
    return lowestCommonAncestor(root.left, p, q);
  }
  if (root.val < p && root.val < q) {
    return lowestCommonAncestor(root.right, p, q);
  }
  return root;
}
```

### 左右子树互换

这道题只需要直接交换左右子树即可

```js
function invertTree(root) {
  if (!root) return [];
  const temp = root.left;
  root.left = root.right;
  root.right = temp;
  invertTree(root.left);
  invertTree(root.right);
  return root;
}
```

当然也可以使用循环来解决这个问题

```js
function invertTree(root) {
  if (!root) return [];
  const stack = [root];
  while (stack.length) {
    const node = stack.pop();
    // 这里用个 js 的新语法，交换值，比上面那个交换值更方便
    [node.left, node.right] = [node.right, node.left];
    node.left && stack.push(node.left);
    node.right && stack.push(node.right);
  }
  return root;
}
```

### 镜像二叉树

或者说叫对称二叉树，检查这棵二叉树是否是镜像对称的。

解题思路：

1. 左子树和右子树同时存在
2. 左子树和右子树的根节点相同
3. 左子树的左节点和右子树的右节点镜像相同
4. 左子树的右结点和右子树的左结点镜像相同

```js
function isSymmetric(root) {
  if (!root) return true;
  function isMirror(left, right) {
    if (!left && !right) return true;
    if (left && right && left.val === right.val && isMirror(left.left, right.right) && isMirror(left.right, right.left)) {
      return true;
    }
    return false;
  }
  return isMirror(root.left, root.right);
}
```

## 参考链接

1. 极客时间覃超老师的算法课
2. [JS 树结构操作:查找、遍历、筛选、树结构和列表结构相互转换](https://juejin.cn/post/6899267681959018510)

---

---
url: /docs/01.前端/02. 代码实现/array.md
---

在日常开发中，我们经常使用数组的 API。本文将详细介绍一些常用的数组操作方法，并提供其实现代码。

## 任意位置插入单个成员

数组任意位置插入单个成员，这个 api 几乎可以作为数组插入的一个最基本的方法来处理，实现如下

按照数组 api 的规则，我们为数组增加了成员，那么要返回数组的长度

```js
function insert(arr, idx, item) {
  // 循环为什么要倒着写？看下面解释
  for (let i = arr.length - 1; i > idx - 1; i--) {
    arr[i + 1] = arr[i];
  }
  arr[idx] = item;
  return arr.length;
}
```

## 任意位置移除单个成员

移除元素跟插入元素应该是一组对应的 api，同理要返回被删除的元素

删除的核心思想就是：从删除项开始，数组所有成员左移一位，最后长度减一即可

```js
function remove(arr, idx) {
  const r = arr[idx];
  for (let i = idx; i < arr.length; i++) {
    arr[i] = arr[i + 1];
  }
  arr.length--;
  return r;
}
```

## 转字符串 join

转字符其实就是做一个字符串拼接

```js
function join(arr, symbol = '') {
  // 核心思想是拼接字符串
  let r = arr[0];
  for (let i = 1, len = arr.length; i < len; i++) {
    r += symbol + arr[i];
  }
  return r;
}
```

## 数组截取 slice

`slice` 截取数组，不改变原数组，返回一个新的数组，是一个浅复制，要创建一个新的数组，所以就可以用到前面写的 `insert` 了

```js
function slice(arr, start = 0, end = arr.length) {
  end = end > arr.length ? arr.length : end;
  const r = [];
  for (let i = start; i < end; i++) {
    insert(r, r.length, arr[i]);
  }
  return r;
}
```

## 栈、队列操作

JavaScript 中的数组可以很好的模拟栈和队列的数据操作

### push

`push` 向数组末尾添加一个或多个元素，并返回新数组的长度

```js
function push(arr, ...item) {
  const len = arr.length;
  // const args = [].slice.call(arguments, 1)
  for (let i = 0; i < item.length; i++) {
    arr[len + i] = item[i];
  }
  return arr.length;
}
```

### pop

`pop` 删除数组最后一个元素，并返回该元素

```js
function pop(arr) {
  const len = arr.length;
  if (!len) return void 0;
  const r = arr[len - 1];
  arr.length--;
  return r;
}
```

### unshift

`unshift` 在数组头部添加一个或多个元素，并返回新数组的长度

```js
function unshift(arr, item) {
  for (let i = arr.length; i > 0; i--) {
    arr[i] = arr[i - 1];
  }
  arr[0] = item;
  return arr.length;
}
```

`unshift` 可以像 `push` 那样传递多个参数，所以要考虑这个情况，要保证数据插入的正确性，具体实现如下

```js
function unshift(arr) {
  const args = [].slice.call(arguments, 1);
  const argsLen = args.length;
  const len = arr.length + argsLen;
  for (let i = len - 1; i > argsLen - 1; i--) {
    arr[i] = arr[i - argsLen];
  }
  // for (let i = arr.length - 1; i >= 0; i--) {
  //   arr[i + args.length] = arr[i];
  // }
  for (let i = 0; i < args.length; i++) {
    arr[i] = args[i];
  }
  return arr.length;
}
```

### shift

`shift` 删除数组的第一个元素，并返回该元素

```js
function shift(arr) {
  const r = arr[0];
  for (let i = 1; i < arr.length; i++) {
    arr[i - 1] = arr[i];
  }
  arr.length--;
  return r;
}
```

## 数组反转

数组反转 reverse 也是一个会让原数组发生改变的 api，返回改变后的数组

```js
function reverse(arr) {
  const len = arr.length;
  const lenHalf = len / 2;
  for (let i = 0; i < lenHalf; i++) {
    const temp = arr[i];
    arr[i] = arr[len - 1 - i];
    arr[len - i - 1] = temp;
  }
  return arr;
}
```

## 遍历数组

数组遍历是很常用的 api，有直接遍历数组的，有对数组进行处理返回对应结果的，有筛选数据的，不会改变原数组（对引用类型的数组成员进行修改还是会改变的），属于纯函数常用的 `forEach、map、filter、find、some、every、reduce` 等

### forEach

遍历数组中的每个元素，执行提供的回调函数

```js
function forEach(arr, cb, ctx = null) {
  for (let i = 0; i < arr.length; i++) {
    cb.call(ctx, arr[i], i, arr);
  }
}
```

在 `forEach` 中用 `return` 是不会返回任何结果的，函数还会继续执行

中断方法：

* 使用 `try` 监视代码，在需要中断的地方抛出已成
* 官方推荐方法：用 `every` 和 `some` 替换 `forEach`
  * `every` 在碰到 `return false` 的时候，中止循环
  * `some` 在碰到 `return true` 的时候，中止循环
* 接下来我们看看 `some` 和 `every` 的实现

### some

`some` 函数是一个很好用的函数，判断数组成员有任意一项满足条件则返回 true

```js
function some(arr, cb, ctx = null) {
  for (let i = 0; i < arr.length; i++) {
    if (cb.call(ctx, arr[i], i, arr)) {
      return true;
    }
  }
  return false;
}
```

### every

`every` 与 `some` 正好相反，数组成员都满足条件返回 true，否则返回 false

```js
function every(arr, cb, ctx = null) {
  for (let i = 0; i < arr.length; i++) {
    if (!cb.call(ctx, arr[i], i, arr)) {
      return false;
    }
  }
  return true;
}
```

### map

`map` 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。如果使用中没有返回结果则与 forEach 的效果一致

```js
function map(arr, cb, ctx = null) {
  const r = [];
  for (let i = 0; i < arr.length; i++) {
    r.push(cb.call(ctx, arr[i], i, arr));
  }
  return r;
}
```

### filter

`filter` 会对返回一组满足条件的数组成员，所以接受的函数中需要返回一个布尔值

```js
function filter(arr, cb, ctx = null) {
  const r = [];
  for (let i = 0; i < arr.length; i++) {
    const ret = cb.call(ctx, arr[i], i, arr);
    if (ret) {
      r.push(arr[i]);
    }
  }
  return r;
}
```

### find

`find` 查找数组中满足条件的第一个成员

```js
function find(arr, cb, ctx = null) {
  for (let i = 0; i < arr.length; i++) {
    if (cb.call(ctx, arr[i], i, arr)) {
      return arr[i];
    }
  }
  return void 0;
}
```

`findIndex` 跟 `find` 一样，只不过返回结果一个是返回数组成员，一个是数组下标

```js
function findIndex(arr, cb, ctx = null) {
  for (let i = 0; i < arr.length; i++) {
    if (cb.call(ctx, arr[i], i, arr)) {
      return i;
    }
  }
  return -1;
}
```

### reduce

`reduce` 有个初始值的概念，初始值定了，返回结果就是在初始值上进行处理，返回每次对数组成员计算后的结果

```js
function reduce(arr, cb, init, ctx = null) {
  let r = init;
  for (let i = 0; i < arr.length; i++) {
    r = cb.call(ctx, r, arr[i], i, arr);
  }
  return r;
}
```

## 合并数组 concat

`concat` 合并一个数组，返回一个新的数组，也不会对原数发生改变，需要注意的是，参数可以是多个，可以是数组也可以是单个成员

```js
function concat(arr, ...target) {
  // const target = [].slice.call(arguments, 1)
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    insert(result, result.length, arr[i]);
  }
  for (let i = 0; i < target.length; i++) {
    const item = target[i];
    if (Array.isArray(item)) {
      for (let j = 0; j < item.length; j++) {
        insert(result, result.length, item[j]);
      }
    } else {
      insert(result, result.length, item);
    }
  }
  return result;
}
```

## 扁平化数组 flat

如下：一个多维数组，要求把数组扁平化成一个一维数组

```js
const arr = [1, 2, [21, 45, 88], 3, 4, [5, 6, [7, 8, [9, 11]]]];
// 结果：[ 1, 2, 21, 45, 88, 3, 4, 5, 6, 7, 8, 9, 11 ]
```

* 扁平化有多种思路，我们可以直接暴力一点，直接用正则匹配所有的中括号然后替换为空

```js
function flatUseRegExp(arr) {
  const str = JSON.stringify(arr).replace(/\[|\]/g, '');
  return str.split(',').map(i => +i);
}
```

* 也可以更直接一点，利用数组 toString 之后会去掉所有括号直接处理

```js
function flatUseToString(arr) {
  return arr
          .toString()
          .split(',')
          .map(i => +i);
}
```

* 当然我们也可以规规矩矩的写递归，来解决这个问题

```js
function flat(arr) {
  let r = [];
  arr.forEach(item => {
    if (Array.isArray(item)) {
      r = r.concat(flat(item));
    } else {
      r.push(item);
    }
  });
  return r;
}
```

* 当然循环要比递归性能更好

```js
function flat(arr) {
  while (arr.some(item => Array.isArray(item))) {
    arr = [].concat(...arr);
  }
  return arr;
}
```

## 数组 at 方法

根据索引值获取数组中的元素，支持正向和反向索引

```js
function at(arr, n) {
  n = Math.trunc(n) || 0;
  if (n < 0) n += arr.length;
  if (n < 0 || n >= arr.length) return undefined;
  return arr[n];
}
```

## 将一维数组按指定长度拆分为二维数组：

之前面试遇到一道题，有一个一维数组，我想要写个方法，方法接收两个参数，该数组和一个数字，然后得到一个根据这个数字而拆分成的多维数组，比如说我传递一个 3，那就数组中的成员就每三个成员组成一个新的数组

```js
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
// 结果：[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ], [ 0 ] ]

const addAxis = (arr, offset) => {
  const len = arr.length;
  // 偏移量计算如果正好能被整除那么就取传入的偏移量，否则就向下取整后加1
  const offsetNum = len % offset === 0 ? offset : ~~(len / offset + 1);
  const result = [];
  for (let i = 0; i < offsetNum; i++) {
    result.push(arr.slice(i * offset, i * offset + offset));
  }
  return result;
};
```

## 数组原型上的实现

根据上面的思路，这里直接给数组原型实现一波常用 api，代码较长，比较完整，细细评阅

```js
function insert(arr, index, item) {
  for (let i = arr.length - 1; i > index - 1; i--) {
    arr[i + 1] = arr[i];
  }
  arr[index] = item;
  return arr.length;
}

Array.prototype.insert = function(index, item) {
  return insert(this, index, item);
};

Array.prototype.remove = function(index) {
  const removeItem = this[index];
  for (let i = index; i < this.length; i++) {
    this[i] = this[i + 1];
  }
  this.length--;
  return removeItem;
};

Array.prototype.join2 = function(symbol = ',') {
  let str = this[0] || '';
  for (let i = 1; i < this.length; i++) {
    str += symbol + this[i];
  }
  return str;
};

Array.prototype.slice2 = function(start = 0, end = this.length) {
  end = end > this.length ? end : this.length;
  let r = [];
  for (let i = start; i < end; i++) {
    insert(r, r.length, this[i]);
  }
  return r;
};

Array.prototype.push2 = function(...args) {
  const len = this.length;
  for (let i = 0; i < args.length; i++) {
    insert(this, len + i, args[i]);
  }
  return this.length;
};

Array.prototype.pop2 = function() {
  const len = this.length;
  if (!len) return void 0;
  const popValue = this[len - 1];
  this.length--;
  return popValue;
};

Array.prototype.unshift2 = function() {
  const argsLen = arguments.length;
  const len = this.length + argsLen;
  for (let i = len - 1; i > argsLen - 1; i--) {
    this[i] = this[i - argsLen];
  }
  for (let i = 0; i < argsLen; i++) {
    this[i] = arguments[i];
  }
  return this.length;
};

Array.prototype.shift2 = function() {
  const r = this[0];
  for (let i = 1; i < this.length; i++) {
    this[i - 1] = this[i];
  }
  this.length--;
  return r;
};

Array.prototype.reverse2 = function() {
  const len = this.length;
  for (let i = 0; i < len / 2; i++) {
    const temp = this[i];
    this[i] = this[len - i - 1];
    this[len - i - 1] = temp;
  }
  return this;
};

Array.prototype.forEach2 = function(callback, ctx = null) {
  for (let i = 0; i < this.length; i++) {
    callback.call(ctx, this[i], i, this);
  }
};

Array.prototype.map2 = function(callback, ctx = null) {
  const r = [];
  for (let i = 0; i < this.length; i++) {
    r.push(callback.call(ctx, this[i], i, this));
  }
  return r;
};

Array.prototype.filter2 = function(callback, ctx = null) {
  const r = [];
  for (let i = 0; i < this.length; i++) {
    if (callback.call(ctx, this[i], i, this)) {
      r.push(this[i]);
    }
  }
  return r;
};

Array.prototype.some2 = function(callback, ctx = null) {
  for (let i = 0; i < this.length; i++) {
    if (callback.call(ctx, this[i], i, this)) {
      return true;
    }
  }
  return false;
};

Array.prototype.every2 = function(callback, ctx = null) {
  for (let i = 0; i < this.length; i++) {
    if (!callback.call(ctx, this[i], i, this)) {
      return false;
    }
  }
  return true;
};

Array.prototype.reduce2 = function(callback, init, ctx = null) {
  // 初始值的初始化??
  let r = init;
  for (let i = 0; i < this.length; i++) {
    r = callback.call(ctx, r, this[i], i, this);
  }
  return r;
};

Array.prototype.find2 = function(callback, ctx = null) {
  for (let i = 0; i < this.length; i++) {
    if (callback.call(ctx, this[i], i, this)) {
      return this[i];
    }
  }
};

Array.prototype.concat2 = function(...target) {
  // 不改变原数组
  const r = [];
  for (let i = 0; i < this.length; i++) {
    insert(r, r.length, this[i]);
  }
  for (let i = 0; i < target.length; i++) {
    const item = target[i];
    if (Array.isArray(item)) {
      for (let j = 0; j < item.length; j++) {
        insert(r, r.length, item[j]);
      }
    } else {
      insert(r, r.length, item);
    }
  }
  return r;
};

Array.prototype.flat2 = function() {
  // 不改变原数组
  let r = [];
  for (let i = 0; i < this.length; i++) {
    const item = this[i];
    if (Array.isArray(item)) {
      r = r.concat([].flat2.apply(item));
    } else {
      r.push(item);
    }
  }
  return r;
};

Array.prototype.at2 = function(n) {
  n = Math.trunc(n) || 0;
  if (n < 0) n += this.length;
  if (n < 0 || n >= this.length) return undefined;
  return this[n];
};

const arr = [1, 2, 3, 4, 5];

const len = arr.insert(3, '你好');
console.log(len, arr);

const removeItem = arr.remove(3);
console.log(removeItem, arr);

console.log(arr.join2());
console.log(arr.slice2(2, 4));
console.log(arr.push2('你好', '不好'), arr, 'push');
console.log(arr.pop2(), arr, 'pop');
console.log(arr.pop2(), arr, 'pop');
console.log(arr.unshift2('unshift1', 'unshift2'), arr, 'unshift');
console.log(arr.shift2(), arr, 'shift');
console.log(arr.shift2(), arr, 'shift');
// console.log(arr.pop2(), arr, 'pop');

arr.forEach2(console.log);

console.log(arr.map2(x => x * 2), 'map');

console.log(arr.filter2(x => x > 3), 'filter');

console.log(arr.some2(x => x === 2), 'some');
console.log(arr.every2(x => x > 2), 'every');

console.log(arr.reduce2((x, y) => x + y, 0), 'reduce');
console.log(arr.find2(x => x === 1), 'find');

console.log(arr.concat2(6, 7, 8, [9, 10]), 'concat');

const arr2 = [1, 2, [3, 4, [5, 6]]];

console.log(arr2.flat2(), 'flat');
```

## 结束语

本文介绍了常用数组 API 的实现方法，包括插入和删除元素、字符串转换、截取、栈和队列操作、反转、遍历、过滤、查找、归并、合并、扁平化等操作。通过这些基础实现，能够深入理解 JavaScript 数组的工作机制，并在实际开发中灵活运用，提升编码效率和代码质量。希望这些示例和代码能够帮助你更好地掌握数组操作，写出更高效、更优雅的代码。

---

---
url: /docs/@pages/articleOverviewPage.md
---


---

---
url: /docs/02.服务端/vmware-undone.md
---

## 系统启动

计算机通电后，第一件事情就是读取输入 ROM 芯片的开机程序，这个程序叫做基本输入输出系统 `BIOS`（Basic Input/Output System）

`BIOS` 程序首先检查计算机硬件是否满足运行的基本条件，这个叫做硬件自检（Power-On Self-Test）

如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止，如果没有问题，屏幕会显示出 CPU、内存、硬盘等信息

硬件自检完成后，BIOS 会把控制权交给下一阶段的启动程序；这时候 BIOS 要知道下一阶段的启动程序具体存放在哪一个设备，BIOS 需要有一个外部存储设备的排序，排在前面的设备就是优先转交控制权的设备，这种排序叫做启动顺序（Boot Sequence）BIOS 按照启动顺序，把控制权交给排在第一位的存储设备

记得当时还是 xp 的系统的时候装系统的时候流行这么一句话，开机就按 delete，然后再找小 boot，进去之后把第一启动设备改成 CDROM 或者 USB，使用光盘或者 u 盘来装系统

## 镜像下载

[centos7](http://mirrors.aliyun.com/centos/7/isos/x86_64/)

---

---
url: /docs/03.工具/Webpack 相关/lint.md
---

## 简介

本项目使用 express 脚手架初始化，并对其进行改造，从而实现一套完整的 eslint 工作流的 node 项目。本项目将全程使用 `pnpm` 作为包管理工具

本文将从以下几个方面过一遍 eslint 工作流

## 初始化项目

```sh
npx express-generator --view=pug express-template
```

也可以下全局下载 `express-generator` ，然后执行 `express --view=pug express-template` 初始化项目

## 开启 debug

```shell
# 在 MacOS 或 Linux 中，通过如下命令启动此应用：
DEBUG=myapp:\* npm start
# 在 Windows 命令行中，使用如下命令：
set DEBUG=myapp:\* & npm start
# 在 Windows 的 PowerShell 中，使用如下命令：
env: DEBUG='myapp:\*'; npm start
```

为了兼容其他系统，安装 cross-env 工具来处理

```shell
pnpm add cross-env -D
```

## 安装 nodemon

nodemon 用来监视 node.js 应用程序中的任何更改并自动重启服务, 非常适合用在开发环境中。

nodemon 不需要对代码或开发方法进行任何额外的更改。 nodemon 是 node 的替代包装器。

nodemon 可全局设置也可以项目设置，我们为项目设置即可

```shell
pmpm add nodemon -D
touch nodemon.json
```

nodemon.json 各配置项含义，也可以 nodemon --\[options] 使用

* restartable：重启模式
* verbose：日志输出模式，true 为详细
* watch：需要监听的文件
* ignore：忽略的文件
* delay：设置延迟时间
* exec：执行的命令
* ext：文件后缀名

```json nodemon.json
{
  "ignore": [".git", "node_modules/**/node_modules", "package-lock.json", "npm-debug.log*"]
}
```

## 安装 babel

安装 babel 来支持 es6 语法，需要用到的包 `@babel/core、@babel/node、@babel/preset-env` ，如果用到命令行的话还需要用到 `@babel/cli`

```shell
pnpm add @babel/core @babel/node @babel/preset-env @babel/cli -D
# 增加 babel 配置文件
touch .babelrc
```

.babelrc 文件配置，一般用到 `@babel/preset-env` 就够用了， `preset-env` 是官方提供的预设用于编译 es2015+ 的语法， `preset-env` 是一套插件包的集合

当我们配置了 `presets` 中有 `@babel/preset-env` ，那么 `@babel/core` 就会去找 `preset-env` 预设的插件

babel 核心包并不会去转换代码，核心包只提供一些核心 API，真正的代码转换工作由插件或者预设来完成，比如要转换箭头函数，会用到个 plugin `@babel/plugin-transform-arrow-functions` ，当需要转换的要求增加时，我们不可能去一一配置相应的 plugin，这个时候就可以用到预设了，也就是 presets。presets 是 plugins 的集合，一个 presets 内部包含了很多 plugin。

```json .babelrc
{
  "presets": ["@babel/preset-env"]
}
```

### 改造项目

增加配置后就可以把项目用到的 var 和 require 换成为 es6 语法

更改项目目录，创建 src 目录，把要开发的文件都放到 src 目录下，方便编译文件（public 和 views 不需要）

在 package.json 增加启动和打包脚本

```json package.json
{
  "scripts": {
    "dev": "node ./src/app",
    "start": "cross-env NODE_ENV=development debug=express-template:* nodemon ./src/app --exec babel-node",
    "clean": "rm -rf dist",
    "babel": "babel ./src --out-dir dist",
    "build": "cross-env NODE_ENV=production npm run clean && npm run babel"
  }
}
```

增加一个项目启动后提示启动 IP 端口展示

使用 chalk 优化终端展示颜色，不要下载 5 版本

```shell
pnpm add chalk@^4.1.2
```

```js
// 获取 IP
const interfaces = require('os').networkInterfaces();

function getIp() {
  let IpAddress = '';
  for (let devName in interfaces) {
    interfaces[devName].forEach(ip => {
      if (ip.family === 'IPv4' && ip.address !== '127.0.0.1' && !ip.internal) {
        IpAddress = ip.address;
      }
    });
  }
  return IpAddress;
}

// 更新 onListening
function onListening() {
  const addr = server.address();
  const bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;
  debug('Listening on ' + bind);
  console.log(`
    Server running at:
    - Local:   ${chalk.hex('#66D9EF')('http://localhost:' + port)}
    - Network: ${chalk.hex('#66D9EF')('http://' + getIp() + ':' + port)}
  `);
}
```

最终效果如下：

## eslint 和 prettier

### eslint

> 问：为什么要使用 eslint?
>
> 答：由于 js 的动态弱类型语言特性，导致在开发中如果不加以约束会容易出错，也正是因为这种特性导致当程序出现错误的时候，我们需要花费更多的时间在执行的过程中不断去调试，eslint 的出现就是为了让开发人员可以在开发的过程中就发现错误而非在执行过程中

下载依赖并且创建 `.eslintrc.js` 或者 `.eslintrc.json` 文件

```shell
pnpm i eslint @babel/eslint-parser -D
touch .eslintrc.js
```

```js .eslintrc.js
module.exports = {
  extends: ['eslint:recommended'],
  env: {
    node: true,
    es6: true,
  },
  globals: {},
  rules: {},
  parser: '@babel/eslint-parser',
  parserOptions: {
    sourceType: 'module',
    ecmaVersion: 'latest',
  },
};
```

package.json 增加 lint 脚本，即可对代码进行检测以及格式化

```json package.json
{
  "scripts": {
    "lint": "eslint src/**/*.js",
    "lint:fix": "eslint src/**/*.js --fix"
  }
}
```

### eslint 配置简介

下面是 eslint 配置文件的常见字段：

```js
module.exports = {
  root: true,
  extends: ['eslint:recommended', 'prettier'],
  plugins: ['prettier'],
  env: {
    node: true,
    es6: true,
  },
  globals: {
    jQuery: 'readonly',
    defineProps: 'readonly',
  },
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
  },
  parser: '@babel/eslint-parser',
  parserOptions: {
    sourceType: 'module',
    ecmaVersion: 'latest',
  },
};
```

* root: 使用配置文件时 eslint 将自动在要检测的文件目录里(`.eslintrc.* 和 package.json`)寻找它们，紧接着是父级目录，一直到文件系统的根目录，eslint 一旦发现配置文件中有 "root": true，它就会停止在父级目录中寻找。

* extends: 用于开启一系列预设的规则。可以添加两类预设：

  1. 配置包: 配置包用于专门导出共享的配置内容。配置 extends 时名称包含 `eslint-config-` 可省略，比如 `prettier` 即为 `eslint-config-prettier`
  2. 插件包: 插件包通常输出一系列规则，但同时还能导出一个或多个命名配置供用户选择，这些配置与配置包的导出内容一致。配置到 extends 时格式为 `plugin:包名/配置名称` ，包名可省略 eslint-plugin- 前缀，比如 `plugin:prettier/recommended`

* plugins: 插件，可省略插件名称中的 `eslint-plugin-` 前缀，但 @scope 不能省略(extends 同样适用)。添加插件后即可以在 rules 字段配置对应规则

```js
module.exports = {
  extends: ['@vue/standard'], // @vue/eslint-config-standard
  plugins: [
    '@typescript-eslint', // @typescript-eslint/eslint-plugin
    '@byted/check-css-modules', // @byted/eslint-plugin-check-css-modules
  ],
};
```

* env: env 预定义了一组的全局变量，下面列举一些常见的，全部的可参考[ Specifying Environments ](https://eslint.bootcss.com/docs/user-guide/configuring#specifying-environments)

```js
module.exports = {
  env: {
    browser: true, // 浏览器环境中的全局变量。window、document 就可以使用
    node: true, // Node.js 全局变量和 Node.js 作用域。process 等可以使用
    commonjs: true, // CommonJS 全局变量和 CommonJS 作用域 (用于 Browserify/WebPack 打包的只在浏览器中运行的代码)。
    'shared-node-browser': true, // Node.js 和 Browser 通用全局变量。
    es6: true, // 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 ecmaVersion 解析器选项为 6）。
    worker: true, // Web Workers 全局变量。
    amd: true, // 将 require() 和 define() 定义为像 amd 一样的全局变量。
  },
};
```

* globals: 设置脚本在执行期间访问的额外的全局变量，当访问当前源文件内未定义的变量时，no-undef 规则将发出警告，比如 vue 升级 2.7 之后可以使用 vue3 的语法，但是 `defineProps` 之类的 eslint 校验不通过，此时可以配置这个，对应值有 `writable` 和 `readonly`

```js
module.exports = {
  globals: {
    defineProps: 'readonly',
    defineEmits: 'readonly',
    defineExpose: 'readonly',
  },
};
```

* rules: 启用的规则及其各自的错误级别。eslint 附带有大量规则，可以使用注释或配置文件修改你项目中要使用的规则，要改变一个规则设置，必须将规则 ID 设置为下列值之一：

  1. off 或 0 - 关闭规则
  2. warn 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)
  3. error 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)

* parser: eslint 默认使用 Espree 作为其解析器，我们可以配置其他不同的解析器，官方目前给出了三个 [Esprima](https://www.npmjs.com/package/esprima)、[@babel/eslint-parser](https://www.npmjs.com/package/@babel/eslint-parser)、[@typescript-eslint/parser](https://www.npmjs.com/package/@typescript-eslint/parser)

* parserOptions：设置解析器选项，可用选项有：
  1. ecmaVersion: es 版本，默认为 3，5，可以使用 6、7、8、9 或 10 来指定，也可以使用 2015、2016 等基于年份的命名，还可以直接用 `latest` 声明最新版本
  2. sourceType: 默认为 `script`，如果代码是 ECMAScript 模块可以设置为 `module`
  3. ecmaFeatures: 是个对象，表示你想使用的额外的语言特性

```js
module.exports = {
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    ecmaFeatures: {
      globalReturn: true, // 允许在全局作用域下使用 return 语句
      impliedStrict: true, // 启用全局 strict mode (如果 ecmaVersion 是 5 或更高)
      jsx: true, // 启用 JSX
    },
  },
};
```

缺少配置遇到的错误：

* `The keyword 'const' is reserved`：遇到这个错误需要把 `env.es6` 打开即可解决
* `'import' and 'export' may appear only with 'sourceType: module'`：把 `parserOptions.sourceType` 设置为 `module` 即可解决

### prettier

> 问：用了 eslint 为什么还要用 prettier?
>
> 答：prettier 是一个代码风格的约束工具，对于代码可能产生的 Bug 等并不关心，虽然说 eslint 其实也具备一定的代码风格的格式化能力，但是在实践中，我们一般采用 eslint 来做代码质量的约束，用 prettier 来做代码风格的约束。

安装脚本

```shell
pnpm add prettier eslint-config-prettier -D
```

使用 `eslint-config-prettier` 是为了解决 eslint 和 prettier 的规则冲突，本质上这个工具其实就是禁用掉了一些不必要的以及和 prettier 相冲突的 eslint 规则

eslint 给 extends 增加 'prettier'

```js
module.exports = {
  extends: ['eslint:recommended', 'prettier'],
};
```

创建配置文件 `.prettierrc` 或者 `prettier.config.js` 进行一些简单配置，配置项不多，可参考[ prettier options ](https://prettier.io/docs/en/options.html)

prettier 格式化代码也很简单，只需要执行 `npx prettier --write src.` ，如果只是检测执行 `npx prettier --check src/.`

## git hook

执行 git init 的时候会生成一个 `.git` 文件夹，或者从 github、gitlab 中 download 下来的代码都会有这么一个文件夹，git hook 就是这个文件夹的 hooks 下的一些钩子函数，特定时期他们将会被调用，完整钩子参考[ git hooks ](https://git-scm.com/docs/githooks)

里面的文件分为以 .sample 结尾的文件和没有这个结尾的文件

.sample 为各个钩子的案例脚本，可以把 sample 去掉，直接编写 shell 脚本来执行

我们可以利用插件 husky 和 pre-commit 来使钩子生效

### husky

git hooks 保存在 `.git` 文件夹中。git 是一个多人协作工具，那按理说 git 仓库中的所有文件都应该被跟踪并且上传至远程仓库的。但是有个例外， `.git` 文件夹不会，这就导致一个问题，我们在本地配置好 git hooks 后，怎么分享给其他小伙伴儿呢？copy 吗？那未免太 low 了，都用 git 了还 copy，也太不优雅了。这时候我们可以用 [husky](https://www.npmjs.com/package/husky)

husky 是一个让配置 git 钩子变得更简单的工具。husky 的原理是让我们在项目根目录中写一个配置文件，然后在安装 husky 的时候把配置文件和 git hooks 关联起来，这样我们就能在团队中使用 git hooks 了。也可以直接执行 `husky install` 来生成 git hooks

根据官网配置走一遭

```shell
pnpm add husky -D
npm set-script prepare "husky install"
npm run prepare
# 添加一个 hook
npx husky add .husky/pre-commit "npm run prettier"
# husky@9.x 以上用 npx husky init
git commit -m "Keep calm and commit"
# `npm run prettier` will run
```

husky 在 version@5.x 之后已经不自动生成 git hooks 了

使用 husky 4 之前，会在 install 的时候自动安装 git hooks。使用 husky 5 之后，可以选择，而且很明确。

Husky 5 更接近 Git，并且抽象更少。它不仅使它更易于理解，而且非常快速和小，零依赖。具体信息可参考[ What's new in husky 5 ](https://dev.to/typicode/what-s-new-in-husky-5-32g5)

至于 husky 为什么要抛弃传统的 JS 配置，husky 作者专门写了一篇解释，可参考[ Why husky has dropped conventional JS config ](https://blog.typicode.com/husky-git-hooks-javascript-config/)

### npm 钩子 prepare

上面我们用到了一些 npm 的钩子函数， `npm set-script prepare "husky install"` ，这句话的意思是说给 npm 设置一个执行脚本 `prepare` 它要执行的命令是 `husky install` ，这时 package.json 的 scripts 中就会多一个脚本

相当于我们手动在 package.json 中写入 `"prepare": "husky install"` ，其中 `prepare` 是 npm 的一个钩子函数，是 npm 4 引入的一个新的钩子，行为等同于 `prepublish`

`prepublish` 这个钩子不仅会在 `npm publish` 命令之前运行，还会在 `npm install（不带任何参数）` 命令之前运行。这种行为很容易让用户感到困惑，所以在 npm 4 的时候引入了这个钩子，从 npm 5 开始， `prepublish` 将只在 `npm publish` 命令之前运行。

所以这个钩子 `只会在 npm install 命令之前运行` ，每次在 install 的时候安装 husky (确保别人拉下代码后项目中有 git hooks)

```json
{
  "scripts": {
    "prepare": "husky install"
  }
}
```

### npm 钩子

npm 脚本有 `pre` 和 `post` 两个钩子。举例来说，build 脚本命令的钩子就是 prebuild 和 postbuild

```json
{
  "scripts": {
    "prebuild": "echo I run before the build script",
    "build": "babel ./src --out-dir dist",
    "postbuild": "echo I run after the build script"
  }
}
```

用户执行 npm run build 的时候，会自动按照下面的顺序执行。

`npm run prebuild && npm run build && npm run postbuild`

因此，可以在这两个钩子里面，完成一些准备工作和清理工作。

```json
{
  "scripts": {
    "clean": "rm -rf dist",
    "prebuild": "cross-env NODE_ENV=production npm run clean",
    "build": "babel ./src --out-dir dist"
  }
}
```

npm 默认提供下面这些钩子

```txt
prepublish，postpublish
preinstall，postinstall
preuninstall，postuninstall
preversion，postversion
pretest，posttest
prestop，poststop
prestart，poststart
prerestart，postrestart
```

自定义的脚本命令也可以加上 pre 和 post 钩子。比如，myscript 这个脚本命令，也有 premyscript 和 postmyscript 钩子。不过，双重的 pre 和 post 无效，比如 prepretest 和 postposttest 是无效的。

npm 提供一个 `npm_lifecycle_event` 变量，返回当前正在运行的脚本名称，比如 pretest、test、posttest 等等。

那么最终我们 package.json 的 scripts 就改造成了这个

```json package.json
{
  "scripts": {
    "prestart": "cross-env NODE_ENV=development debug=express-template:*",
    "start": "nodemon ./src/app --exec babel-node",
    "clean": "rm -rf dist",
    "prebuild": "cross-env NODE_ENV=production npm run clean",
    "build": "babel ./src --out-dir dist",
    "prelint": "eslint src/**/*.js --fix",
    "lint": "prettier --write src/**/*.js",
    "prepare": "husky install"
  }
}
```

### lint-stage

上面执行的 lint 命令会格式化整个项目，比较耗资源，其实我们只需要格式化本次修改的代码就行，此时我们就可以用到 lint-stage

官网有句话叫 Run linters against staged git files and don't let 💩 slip into your code base!

使用也很简单，下载 lint-staged 包

```shell
pnpm add lint-staged -D
```

在 package.json 中增加 lint-staged 配置，或者单独创建 .lintstagedrc 之类的配置文件也可以

.lintstagedrc 文件

```json .lintstagedrc
{
  "src/**/*.js": "npm run lint"
}
```

然后修改 `.husky/pre-commit` 文件，把里面的 `npm run prettier` 修改为 `npx lint-staged`

```shell
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx lint-staged
```

此时项目就改造完成了

小技巧：因这个项目是第一次提交，要不断地撤回然后在次 commit 来调试代码格式化的结果，所以这里可以用 `git update-ref -d HEAD` 命令来撤销第一次提交

## 增加 pm2

说起项目自动重启，就不得不在介绍一下 pm2，pm2 是开源的基于 Nodejs 的进程管理器，包括守护进程、监控、日志的一整套完整的功能

pm2 全称 `Process Manager 2` 是 node.js 和 io.js 应用程序的生产进程管理器，具有内置的负载均衡器。它允许您永远保持应用程序的活性，在不停机的情况下重新加载它们，并促进常见的系统管理任务。

【io.js 黑暗史】曾与 node.js 有冲突，核心开发者自立门户建立了分支 io.js 并行一段时间后与 node.js 合并

在生产模式下使用只需要执行 `pm2 start app.js` 就行

对于线上项目，如果直接通过 node app 来启动，如果报错了可能直接停止导致整个服务崩溃，而 pm2 带有负载均衡功能，可以保持 node 应用进程永远运行在后台

pm2 需要全局安装，然后本地直接使用即可

```shell
npm i -g pm2
# 到项目根目录下执行
pm2 init
# 此时会生成 ecosystem.config.js 文件，可以在里面提供一些配置
```

常用配置项说明:

* apps: apps 是一个数组，每一个数组成员就是对应一个 pm2 中运行的应用
* name: 应用程序名称，默认为不带扩展名的脚本文件名
* cwd: 应用程序所在目录
* script: 应用程序脚本路径，相对于 pm2 start 的脚本路径
* args: 包含通过 CLI 传递给脚本的所有参数的字符串
* log\_date\_format: 日志日期格式
* error\_file: 错误文件路径 (默认为：$HOME/.pm2/logs/xxxerr.log)
* out\_file: 输出文件路径 (默认为：$HOME/.pm2/logs/xxxout.log)

详细配置可查看 [Configuration File](https://pm2.keymetrics.io/docs/usage/application-declaration/)

pm2 常用命令

* `pm2 start xxx`: 启动应用程序，不仅可以启动 js 脚本，同时还可以启动其他类型的应用程序，如 bash 命令、脚本、二进制文件，例如 `pm2 start "ls -la"`
* `pm2 restart [xxx|all]`: 重启
* `pm2 show [id|name]`: 查看应用程序数据
* `pm2 [list|ls|l|status]`: 列出所有正在运行的应用程序
* `pm2 delete [id|name|all]`: 删除某个启动的服务
* `pm2 monit`: 打开监控面板，查看内存和 CPU

为 package.json 增加一个执行脚本

```json
{
  "scripts": {
    "pm2": "pm2 start ecosystem.config.js"
  }
}
```

至此我们项目就搭建完了，为 node 项目支持了 es6，并增加了一套代码规范以及 git 提交时自动格式化代码，本地开发使用 `npm start` 部署到服务器上后则执行 `npm run pm2` 即可

## 源码地址

<https://github.com/fecym/express-template>

## 参考链接

1. [npm scripts 使用指南](https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html)
2. [What's new in husky 5](https://dev.to/typicode/what-s-new-in-husky-5-32g5)
3. [Configuring ESLint](https://eslint.bootcss.com/docs/user-guide/configuring)
4. [ESLint 插件开发基础](https://juejin.cn/post/7078137861039456264)

---

---
url: /docs/01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.md
---

## 问题背景

在某项目初上线优化代码的时候，打包后看到了类似的结果

```txt
dist/assets/index-CMe6Kk4E.js       0.63 kB │ gzip:   0.38 kB
dist/assets/index-DbyJIfZt.js     104.19 kB │ gzip:  40.96 kB
dist/assets/index-BN6vN86v.js     874.79 kB │ gzip: 282.58 kB
dist/assets/index-zD3tofSk.js   1,128.82 kB │ gzip: 375.52 kB
```

这些文件的名称几乎相同，只是 hash 不同，导致：

* **调试困难**：无法直观判断某个 chunk 对应哪个页面。
* **分析不便**：某些文件体积过大，无法快速定位到具体页面。
* **命名重复**：多个页面都会产出 `index-[hash].js`，不够直观。

Vite 打包后的代码会自动把名字和 hash 加上的，类似于在 webpack 项目中我们手动添加的 `webpackChunkName`，但为什么会出现这种情况，都是 `index-[hash]` 的格式呢

后来才意识到，代码结构是这样的

```txt
src/views/
├── PageA/
│   ├── index.vue
│   └── components/
│       ├── Header.vue
│       └── Footer.vue
├── PageB/
│   ├── index.vue
│   ├── composables/
│   │    └── useLog.js
│   └── components/
│       ├── Header.vue
│       └── Footer.vue
| ...
```

这种按页面的代码组织结构，会导致每个业务页面都有一个 `index.vue`，vite 打包后就会生成多个 `index-[hash].js` 文件，导致文件名重复，无法区分

接下来，我们将按照以下文章导览来解决这个问题

## 解决思路

面对这个问题，第一反应是："一定有办法让 Vite 给这些文件起不同的名字"。其实 Vite 提供了 `manualChunks` 配置，可以手动指定 chunk 的分组和命名。

让我们逐步尝试几种可能的解决方案。

### 手动配置

最直接的方法是手动指定每个页面的文件列表：

```js
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          "page-pagea": ["./src/views/PageA/index.vue", "./src/views/PageA/components/Footer.vue", "./src/views/PageA/components/Header.vue"],
          "page-pageb": ["./src/views/PageB/index.vue", "./src/views/PageB/components/Footer.vue", "./src/views/PageB/components/Header.vue", "./src/views/PageB/composables/useLog.js"],
          "page-pagec": ["./src/views/PageC/index.vue", "./src/views/PageC/components/Footer.vue", "./src/views/PageC/components/Header.vue"]
        }
      }
    }
  }
})
```

打包结果没问题，这种方法在组件较少时可行，但随着项目增长，手动维护变得极其繁琐，需要一个更智能的方案。

### 函数式配置

Vite 允许 `manualChunks` 是一个函数，这给了我们更多的灵活性。咱们可以编写一个函数，根据文件路径动态决定它应该属于哪个 chunk：

```js
manualChunks: (id) => {
  // 提取页面路径
  const pageMatch = id.match(/\/views\/([^/]+)\/components\/([^/]+)\.vue$/)
  if (pageMatch) {
    const [, pageName, componentName] = pageMatch
    return `page-${pageName.toLowerCase()}-${componentName.toLowerCase()}`
  }
}
```

这种方法在打包结果也没问题，使用正则表达式匹配页面路径，并生成对应的 chunk 名称，但是也有对应的局限性

* 需要精确的路径匹配规则
* 对多层目录和特殊结构不够友好。
* 与用户已有配置不易整合。

> **注意**：将组件名转为小写是为了避免不同操作系统间的大小写敏感性问题（Windows 不区分大小写，而 Linux/macOS 区分大小写）

### 插件化

手动和函数式配置都有各自的局限性，这让我意识到，一个"一劳永逸"的解决方案必须是自动化的、可配置的。于是，开发一个 Vite 插件的想法应运而生。目标很明确：插件需要能自动扫描目录，生成 `manualChunks` 配置，并能和用户现有的配置进行合并。

那么我们要做的就是

1. **自动扫描**：遍历 `src/views` 下的目录。
2. **智能分组**：将页面与其 `components`、`composables`、`utils` 文件聚合。
3. **统一命名**：chunk 名称统一加 `page-` 前缀。
4. **合并配置**：将生成的 `manualChunks` 与用户已有的配置进行合并

## 实现过程

既然思路有了, 那我们就按照上面的思路来实现

### 扫描目录构建 chunks

首先，我们需要扫描项目目录，找出所有页面及其相关文件。目标是生成这样的配置：

```json
   {
  "page-pagea": [
    "./src/views/PageA/index.vue",
    "./src/views/PageA/components/Footer.vue",
    "./src/views/PageA/components/Header.vue"
  ],
  "page-pageb": [
    "./src/views/PageB/index.vue",
    "./src/views/PageB/components/Footer.vue",
    "./src/views/PageB/components/Header.vue",
    "./src/views/PageB/composables/useLog.js"
  ],
  "page-pagec": [
    "./src/views/PageC/index.vue",
    "./src/views/PageC/components/Footer.vue",
    "./src/views/PageC/components/Header.vue"
  ]
}
```

那我们要做的是扫描文件夹生成一个关系映射表

```js
function scanPageChunks(viewsDir) {
  // 添加的前缀
  const chunkPrefix = options.chunkPrefix || 'page-'
  const chunks = {}
  const viewsPath = resolve(process.cwd(), viewsDir)

  try {
    const dirs = readdirSync(viewsPath)
    dirs.forEach(dir => {
      const dirPath = resolve(viewsPath, dir)
      // 只处理目录
      if (!statSync(dirPath).isDirectory()) return
      // 查找目录中的页面文件
      const files = readdirSync(dirPath)
      if (files.length > 0) {
        const chunkName = `${chunkPrefix}${dir.toLowerCase()}`
        chunks[chunkName] = files.map(file =>
          `./${viewsDir}/${dir}/${file}`.replace(/\\/g, '/')
        )
        // 同时包含该页面目录下的所有组件和 composables
        const subDirs = ['components', 'composables', 'utils']
        subDirs.forEach(subDir => {
          const subDirPath = resolve(dirPath, subDir)
          try {
            if (statSync(subDirPath).isDirectory()) {
              const subFiles = getAllVueFiles(subDirPath)
              subFiles.forEach(subFile => {
                const relativePath = relative(process.cwd(), subFile).replace(/\\/g, '/')
                chunks[chunkName].push(`./${relativePath}`)
              })
            }
          } catch (e) {
            // 子目录不存在，跳过
          }
        })
      }
    })
  } catch (error) {
    console.warn(`⚠️ 无法扫描目录 ${viewsDir}:`, error.message)
  }
  console.log(`最后的 chunks: ${JSON.stringify(chunks)}`)
  return chunks
}

function getAllVueFiles(dir) {
  // 递归获取目录下所有Vue文件 ...
}

```

这个函数做了几件事：

1. 扫描指定目录（默认是 `src/views`）下的所有子目录
2. 为每个子目录创建一个 chunk，名称为 `page-{目录名}`
3. 收集该目录下的所有文件，以及 `components`、`composables`、`utils` 子目录下的文件
4. 处理路径，确保使用正斜杠（`/`），以兼容不同操作系统

### 合并生成的配置

拿到了 chunks 之后，我们需要将它们与现有的 `manualChunks` 进行合并，`manualChunks` 配置存在函数和对象两种写法，需要判断一下

#### 对象处理

如果是对象处理就很简单，直接合并即可

```js
// 拿到的 chunks
const chunks = scanPageChunks('src/views')
const existingChunks = config.build.rollupOptions.output.manualChunks || {}
// 合并
config.build.rollupOptions.output.manualChunks = {...existingChunks, ...chunks}
```

#### 函数处理

如果是函数，则需要处理一下

```js
// 拿到的 chunks
const chunks = scanPageChunks('src/views')
const originalFn = config.build.rollupOptions.output.manualChunks
 // 合并
config.build.rollupOptions.output.manualChunks = (id) => {
  // 转为相对路径匹配
  const relativePath = `./${relative(process.cwd(), id).replace(/\\/g, '/')}`;
  // 遍历chunks对象，检查文件是否在某个chunk的文件列表中
  for (const [chunkName, files] of Object.entries(chunks)) {
    if (files.includes(relativePath)) {
      return chunkName;
    }
  }
  // 不是页面组件，使用用户函数
  return originalFn(id);
}
```

#### 优先级处理

如果用户配置和我们生成的配置有同名的 chunk，谁的优先级更高？

在上面的代码中，我们的配置会覆盖用户的配置。这可能不是所有用户期望的行为。更灵活的做法是提供一个选项，让用户决定优先级：

```js
  // 用户传入的选项，默认插件优先
  const pluginPriority = options.pluginPriority || true;
  const existingChunks = config.build.rollupOptions.output.manualChunks || {}
  if (typeof existingChunks === 'function') {
    // 提取检查文件是否匹配页面组件的函数
    const getPageChunkName = (id) => {
      // 获取相对于项目根目录的路径
      const relativePath = `./${relative(process.cwd(), id).replace(/\\/g, '/')}`;
      // 遍历chunks对象，检查文件是否在某个chunk的文件列表中
      for (const [chunkName, files] of Object.entries(chunks)) {
        if (files.includes(relativePath)) {
          return chunkName;
        }
      }
      return null;
    };
    config.build.rollupOptions.output.manualChunks = (id) => {
      if (pluginPriority) {
        // 先检查是否匹配页面组件
        return getPageChunkName(id) || existingChunks(id);
      } else {
        // 先让用户函数处理
        return existingChunks(id) || getPageChunkName(id);
      }
    }
  } else {
    // 如果现有配置是对象，则直接合并
    config.build.rollupOptions.output.manualChunks = pluginPriority
      ? {...existingChunks, ...chunks}  // 插件优先
      : {...chunks, ...existingChunks};
  }
```

### 封装插件

核心代码都有了，我们只需要把核心代码封装成插件就行了

Vite 插件的开发非常简单，只需要返回一个对象，对象中包含 name 和各种钩子函数

[Vite 官网](https://cn.vite.dev/guide/api-plugin.html)有钩子说明，咱们用到的是 `config` 钩子

> **config 钩子**：在解析 Vite 配置前调用。钩子接收原始用户配置（命令行选项指定的会与配置文件合并）和一个描述配置环境的变量，包含正在使用的 mode 和 command。它可以返回一个将被深度合并到现有配置中的部分配置对象，或者直接改变配置（如果默认的合并不能达到预期的结果）。

```js
export function uniquePageChunks(options = {}) {
  const { viewsDir = 'src/views' } = options
  return {
    name: 'vite-plugin-unique-page-chunks',
    config(config, {command}) {
      if (command !== 'build') return
      // 扫描views目录，自动生成manualChunks配置
      const chunks = scanPageChunks(viewsDir, chunkPrefix, include, exclude)

      // 考虑用户没有配置manualChunks，则创建一个空对象
      if (!config.build) config.build = {}
      if (!config.build.rollupOptions) config.build.rollupOptions = {}
      if (!config.build.rollupOptions.output) config.build.rollupOptions.output = {}

      // 合并现有的manualChunks配置
      const existingChunks = config.build.rollupOptions.output.manualChunks || {}
      // ... 刚才扫描合并的代码
    }
  }
}

export default uniquePageChunks
```

### 使用

该插件已经发布为 [npm 包](https://www.npmjs.com/package/vite-plugin-unique-page-chunks)，使用非常简单：

```bash
# 安装插件
npm install vite-plugin-unique-page-chunks -D
# 或使用 yarn
yarn add vite-plugin-unique-page-chunks -D
# 或使用 pnpm
pnpm add vite-plugin-unique-page-chunks -D
```

```js
// vite.config.js
import {defineConfig} from 'vite'
import vue from '@vitejs/plugin-vue'
import {uniquePageChunks} from 'docs/views/01.前端/vite-plugin-unique-page-chunks'

export default defineConfig({
  plugins: [
    vue(),
    uniquePageChunks({
      // 自定义配置（可选）
      viewsDir: 'src/views',  // 页面目录
      userConfigPriority: false,  // 用户配置是否优先
      chunkPrefix: 'page-',  // chunk 名称前缀
      // ... 其他配置
    })
  ]
})
```

就这么简单！插件会自动扫描你的页面目录，为每个页面生成唯一的 chunk 名称。

### 效果对比

让我们看看使用插件前后的打包结果对比：

* **未使用插件**:

```txt
dist/index.html                      0.61 kB │ gzip:  0.34 kB
dist/assets/index-DKGUJypo.css       1.33 kB │ gzip:  0.65 kB
dist/assets/index-CrgKdBOY.js        0.59 kB │ gzip:  0.34 kB
dist/assets/index-C0yr_JV0.js        0.60 kB │ gzip:  0.34 kB
dist/assets/index-B6ERQaqp.js        0.69 kB │ gzip:  0.41 kB
dist/assets/index-BVuMxtNe.js        3.17 kB │ gzip:  1.53 kB
dist/assets/vue-router-CjvkPhmh.js  23.40 kB │ gzip:  9.56 kB
dist/assets/vue-ChRYQ9yf.js         59.00 kB │ gzip: 23.59 kB
8 chunks of 85.53 KB (gzip: 36.76 KB | map: 723.96 KB)
```

* **使用插件后**:

```txt
dist/index.html                               0.71 kB │ gzip:  0.36 kB
dist/assets/index-DKGUJypo.css                1.33 kB │ gzip:  0.65 kB
dist/assets/js/pages/page-pagec-CtzcrMEm.js   0.57 kB │ gzip:  0.33 kB
dist/assets/js/pages/page-pageb-DfrsPmWZ.js   0.67 kB │ gzip:  0.40 kB
dist/assets/js/pages/page-pagea-BU739MsJ.js   0.70 kB │ gzip:  0.41 kB
dist/assets/index-4smknmsE.js                 3.21 kB │ gzip:  1.51 kB
dist/assets/js/vue-router-fXkg86Ng.js        23.40 kB │ gzip:  9.56 kB
dist/assets/js/vue-7AMx9e1m.js               59.00 kB │ gzip: 23.59 kB
8 chunks of 85.76 KB (gzip: 36.86 KB | map: 724.07 KB)
```

✅ 结果：文件名更加直观，能快速定位到对应页面。

> 使用插件后打包结果略微增大了一点（85.76 KB vs 85.53 KB，增加了约 0.23 KB）。这种情况应该是文件路径变长导致的：使用插件后，文件路径变成了 assets/js/pages/page-xxx-xxx.js 而不是简单的 assets/index-xxx.js ，路径字符串本身就占用了更多空间

不过增加的体积非常小（只有 0.23 KB），对于实际应用几乎没有影响。而且而带来的调试便利性远超这点体积增加。

## 发布 npm 包

npm 包结构也是一个前端项目，会多一个 `.npmignore`  文件，里面配置发布包时需要忽略的文件，其他的跟包发布相关的内容都在 package.json 中

### npm 包结构

```txt
vite-plugin-unique-page-chunks/
├── .gitignore           # Git忽略文件配置
├── .npmignore           # npm发布忽略文件配置
├── CHANGELOG.md         # 版本更新日志
├── LICENSE              # 许可证文件
├── README.md            # 项目说明文档
├── dist/                # 构建输出目录
│   ├── index.cjs        # CommonJS格式的构建产物
│   └── index.js         # ES Module格式的构建产物
├── index.d.ts           # TypeScript类型声明文件
├── package.json         # 项目配置和依赖管理
├── pnpm-lock.yaml       # pnpm锁定文件
├── rollup.config.js     # Rollup打包配置
├── src/                 # 源代码目录
│   └── index.js         # 插件主入口文件
├── test/                # 测试目录
│   ├── fixtures/        # 测试用例资源
│   │   └── mock-vite-project/ # 模拟的Vite项目
│   └── plugin.test.js   # 插件测试文件
└── vitest.config.js     # Vitest测试配置
```

### 打包

插件会使用 rollup 打包，生成对应的 cjs 和 esm 格式文件，然后在 package.json 中配置入口文件

rollup 不熟悉的同学可以去瞄一眼官网，配置代码如下:

```js
import { nodeResolve } from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import babel from '@rollup/plugin-babel';

export default [
  {
    input: 'src/index.js',
    output: [
      { file: 'dist/index.cjs', format: 'cjs', exports: 'named' },
      { file: 'dist/index.js', format: 'es' }
    ],
    external: ['path', 'fs'],
    plugins: [
      nodeResolve(),
      commonjs(),
      babel({
        babelHelpers: 'bundled',
        presets: [['@babel/preset-env', { targets: { node: '14' } }]]
      }),
    ]
  }
];
```

**package.json 中配置的入口文件**

```json
{
  "main": "./dist/index.cjs",
  "module": "./dist/index.js",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    }
  },
  "types": "./index.d.ts"
}
```

### 本地测试

npm 包调整完成后，需要测试一下 npm 包是否可用，直接发到 npm 上测试有问题的话，还得修改在发布，比较麻烦

测试有几种常用方案，推荐使用 `yalc` 来测试

#### 使用 yalc（推荐）

[yalc](https://github.com/wclr/yalc) 是一个专为本地包开发设计的工具，比 npm/pnpm link 更稳定可靠。而且用法也很简单

```bash
# 全局安装
pnpm add -g yalc

# 在包目录中构建并发布到本地 yalc 仓库
pnpm build
yalc publish

# 在测试项目中添加包
yalc add vite-plugin-unique-page-chunks
pnpm build  # 测试构建

# 更新包后重新发布
yalc publish  # 在包目录
yalc update   # 在测试项目中

# 移除本地包
yalc remove vite-plugin-unique-page-chunks
# 或移除所有包
yalc remove --all
```

#### 使用 npm/pnpm link

npm/pnpm link 是 npm 内置的本地包链接功能，适用于简单测试。

```bash
# 在包目录中
pnpm build
pnpm link --global

# 在测试项目中
pnpm link --global vite-plugin-unique-page-chunks

# 解除链接
pnpm unlink vite-plugin-unique-page-chunks  # 测试项目中
pnpm unlink --global  # 包目录中
```

#### 使用 npm pack

npm pack 创建一个本地 tarball 包，最接近实际发布的体验。

```bash
# 在包目录中
pnpm build
npm pack  # 生成 .tgz 文件
# 会创建一个 `.tgz` 文件，如 `vite-plugin-unique-page-chunks-1.0.0.tgz`。

# 在测试项目中
pnpm add /path/to/vite-plugin-unique-page-chunks-1.0.0.tgz
```

### 发包

当我们测试通过后，就可以发布 npm 包了

npm 发布包更简单，只需执行以下命令

```bash
# 查看当前登录的npm用户，如果已经登录了且是我们要发包的账号，就不需要登录了
npm whoami

# 查看当前源地址
npm config get registry
# 确保发布的是正确的源
npm config set registry https://registry.npmjs.org

# 登录 npm，根据提示输入账号、密码和邮箱即可登录
npm login

# 发布包
npm publish

# 更新包，会生成一个 版本号的 commit
npm version patch
npm publish
```

#### npm version

`npm version` 后面的参数：

* **patch**：小变动，比如 bug 修复等，版本号变动 v1.0.0 -> v1.0.1
* **minor**：增加新功能，不影响现有功能，版本号变动 v1.0.0 -> v1.1.0
* **major**：模块大改动，可能不向后兼容，版本号变动 v1.0.0 -> v2.0.0

## 总结

通过开发 `vite-plugin-unique-page-chunks` 插件，我们优雅地解决了 Vite + Vue3 项目中同名组件打包后无法区分的问题。该插件自动扫描页面目录，为每个页面生成唯一的 chunk 名称，使构建产物更加清晰，便于调试和性能分析。

* 插件已发布到 NPM，可通过 [vite-plugin-unique-page-chunks](https://www.npmjs.com/package/vite-plugin-unique-page-chunks) 安装使用。
* 插件源码地址：<https://github.com/fecym/vite-plugin-unique-page-chunks>
* demo 地址：<https://github.com/fecym/unique-page-chunks-demo>
* 原文地址：<https://chengyuming.cn/views/plugins/vite-plugin-unique-page-chunks.html>

---

---
url: /docs/01.前端/04. 浏览器/AST.md
---

## 什么是 AST

抽象语法树（`Abstract Syntax Tree`）简称 `AST`，是源代码的抽象语法结构的树状表现形式。`webpack`、`eslint` 等很多工具库的核心都是通过抽象语法书这个概念来实现对代码的检查、分析等操作。今天我为大家分享一下 JavaScript 这类解释型语言的抽象语法树的概念

我们常用的浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作。所以将 js 转化为抽象语法树更利于程序的分析。

如上图中变量声明语句，转换为 AST 之后就是右图中显示的样式

左图中对应的：

* `var` 是一个关键字
* `AST` 是一个定义者
* `=` 是 Equal 等号的叫法有很多形式，在后面我们还会看到
* `is tree` 是一个字符串
* `;` 就是 Semicolon

首先一段代码转换成的抽象语法树是一个对象，该对象会有一个顶级的 type 属性 `Program`；第二个属性是 `body` 是一个数组。

`body` 数组中存放的每一项都是一个对象，里面包含了所有的对于该语句的描述信息

```sh
type:         描述该语句的类型  --> 变量声明的语句
kind:         变量声明的关键字  --> var
declaration:  声明内容的数组，里面每一项也是一个对象
            type: 描述该语句的类型
            id:   描述变量名称的对象
                type: 定义
                name: 变量的名字
            init: 初始化变量值的对象
                type:   类型
                value:  值 "is tree" 不带引号
                row:    "\"is tree"\" 带引号
```

## 词法分析和语法分析

`JavaScript` 是解释型语言，一般通过 词法分析 -> 语法分析 -> 语法树，就可以开始解释执行了

词法分析：也叫`扫描`，是将字符流转换为记号流(`tokens`)，它会读取我们的代码然后按照一定的规则合成一个个的标识

比如说：`var a = 2` ，这段代码通常会被分解成 `var、a、=、2`

```js
[
  { type: 'Keyword', value: 'var' },
  { type: 'Identifier', value: 'a' },
  { type: 'Punctuator', value: '=' },
  { type: 'Numeric', value: '2' },
];
```

当词法分析源代码的时候，它会一个一个字符的读取代码，所以很形象地称之为扫描 - `scans`。当它遇到空格、操作符，或者特殊符号的时候，它会认为一个话已经完成了。

语法分析：也称`解析器`，将词法分析出来的数组转换成树的形式，同时验证语法。语法如果有错的话，抛出语法错误。

```js
{
  ...
  "type": "VariableDeclarator",
  "id": {
    "type": "Identifier",
    "name": "a"
  },
  ...
}
```

语法分析成 AST ，我们可以在这里在线看到效果 [http://esprima.org](https://esprima.org/demo/parse.html)

## AST 能做什么

* 语法检查、代码风格检查、格式化代码、语法高亮、错误提示、自动补全等
* 代码混淆压缩
* 优化变更代码，改变代码结构等

比如说，有个函数 `function a() {}` 我想把它变成 `function b() {}`

比如说，在 `webpack` 中代码编译完成后 `require('a') --> __webapck__require__("*/**/a.js")`

下面来介绍一套工具，可以把代码转成语法树然后改变节点以及重新生成代码

## AST 解析流程

准备工具：

* esprima：code => ast 代码转 ast
* estraverse: traverse ast 转换树
* escodegen: ast => code

在推荐一个常用的 AST 在线转换网站：<https://astexplorer.net/>

比如说一段代码 `function getUser() {}`，我们把函数名字更改为 `hello`，看代码流程

看以下代码，简单说明 `AST` 遍历流程

```js
const esprima = require('esprima');
const estraverse = require('estraverse');
const code = `function getUser() {}`;
// 生成 AST
const ast = esprima.parseScript(code);
// 转换 AST，只会遍历 type 属性
// traverse 方法中有进入和离开两个钩子函数
estraverse.traverse(ast, {
  enter(node) {
    console.log('enter -> node.type', node.type);
  },
  leave(node) {
    console.log('leave -> node.type', node.type);
  },
});
```

输出结果如下：

由此可以得到 AST 遍历的流程是深度优先，遍历过程如下：

## 修改函数名字

此时我们发现函数的名字在 `type` 为 `Identifier` 的时候就是该函数的名字，我们就可以直接修改它便可实现一个更改函数名字的 `AST` 工具

```js
// 转换树
estraverse.traverse(ast, {
  // 进入离开修改都是可以的
  enter(node) {
    console.log('enter -> node.type', node.type);
    if (node.type === 'Identifier') {
      node.name = 'hello';
    }
  },
  leave(node) {
    console.log('leave -> node.type', node.type);
  },
});
// 生成新的代码
const result = escodegen.generate(ast);
console.log(result);
// function hello() {}
```

## babel 工作原理

提到 AST 我们肯定会想到 babel，自从 Es6 开始大规模使用以来，babel 就出现了，它主要解决了就是一些浏览器不兼容 Es6 新特性的问题，其实就把 Es6 代码转换为 Es5 的代码，兼容所有浏览器，babel 转换代码其实就是用了 AST，babel 与 AST 就有着很一种特别的关系。

那么我们就在 babel 的中来使用 AST，看看 babel 是如何编译代码的（不讲源码啊）

需要用到两个工具包 `@babel/core`、`@babel/preset-env`

当我们配置 babel 的时候，不管是在 `.babelrc` 或者 `babel.config.js` 文件里面配置的都有 `presets` 和 `plugins` 两个配置项（还有其他配置项，这里不做介绍）

### 插件和预设的区别

```json
// .babelrc
{
  "presets": ["@babel/preset-env"],
  "plugins": []
}
```

当我们配置了 `presets` 中有 `@babel/preset-env`，那么 `@babel/core` 就会去找 `preset-env` 预设的插件包，它是一套

babel 核心包并不会去转换代码，核心包只提供一些核心 API，真正的代码转换工作由插件或者预设来完成，比如要转换箭头函数，会用到这个 plugin，`@babel/plugin-transform-arrow-functions`，当需要转换的要求增加时，我们不可能去一一配置相应的 plugin，这个时候就可以用到预设了，也就是 presets。presets 是 plugins 的集合，一个 presets 内部包含了很多 plugin。

### babel 插件的使用

现在我们有一个箭头函数，要想把它转成普通函数，我们就可以直接这么写：

```js
const babel = require('@babel/core');
const code = `const fn = (a, b) => a + b`;
// babel 有 transform 方法会帮我们自动遍历，使用相应的预设或者插件转换相应的代码
const r = babel.transform(code, {
  presets: ['@babel/preset-env'],
});
console.log(r.code);
// 打印结果如下
// "use strict";
// var fn = function fn() { return a + b; };
```

此时我们可以看到最终代码会被转成普通函数，但是我们只需要箭头函数转通用函数的功能，不需要用这么大一套包，只需要一个箭头函数转普通函数的包，我们其实是可以在 `node_modules` 下面找到有个叫做 `plugin-transform-arrow-functions` 的插件，这个插件是专门用来处理 箭头函数的，我们就可以这么写：

```js
const r = babel.transform(code, {
  plugins: ['@babel/plugin-transform-arrow-functions'],
});
console.log(r.code);
// 打印结果如下
// const fn = function () { return a + b; };
```

我们可以从打印结果发现此时并没有转换我们变量的声明方式还是 const 声明，只是转换了箭头函数

## 编写自己的插件

> 此时，我们就可以自己来写一些插件，来实现代码的转换，中间处理代码的过程就是使用前面提到的 AST 的处理逻辑

现在我们来个实战把 `const fn = (a, b) => a + b` 转换为 `const fn = function(a, b) { return a + b }`

### 分析 AST 结构

首先我们在在线分析 AST 的网站上分析 `const fn = (a, b) => a + b` 和 `const fn = function(a, b) { return a + b }`看两者语法树的区别

根据我们分析可得：

1. 变成普通函数之后他就不叫箭头函数了 `ArrowFunctionExpression`，而是函数表达式了 `FunctionExpression`
2. 所以首先我们要把 `箭头函数表达式(ArrowFunctionExpression)` 转换为 `函数表达式(FunctionExpression)`
3. 要把 `二进制表达式(BinaryExpression)` 包裹在 `返回语句中(ReturnStatement)` 然后 push 到 `代码块中(BlockStatement)`，
4. 其实我们要做就是把一棵树变成另外一颗树，说白了其实就是拼成另一颗树的结构，然后生成新的代码，就可以完成代码的转换

### 访问者模式

在 babel 中，我们开发 plugins 的时候要用到访问者模式，就是说在访问到某一个路径的时候进行匹配，然后在对这个节点进行修改，比如说上面的当我们访问到 `ArrowFunctionExpression` 的时候，对 `ArrowFunctionExpression` 进行修改，变成普通函数

那么我们就可以这么写：

```js
const babel = require('@babel/core');
const code = `const fn = (a, b) => a + b`; // 转换后 const fn = function(a, b) { return a + b }
const arrowFnPlugin = {
  // 访问者模式
  visitor: {
    // 当访问到某个路径的时候进行匹配
    ArrowFunctionExpression(path) {
      // 拿到节点
      const node = path.node;
      console.log('ArrowFunctionExpression -> node', node);
    },
  },
};

const r = babel.transform(code, {
  plugins: [arrowFnPlugin],
});

console.log(r);
```

### 修改 AST 结构

此时我们拿到的结果是这样的节点结果是 [这样的](https://chengyuming.cn/json/arrowFn.json)，其实就是 `ArrowFunctionExpression` 的 AST，此时我们要做的是把 `ArrowFunctionExpression` 的结构替换成 `FunctionExpression`的结构，但是需要我们组装类似的结构，这么直接写很麻烦，但是 babel 为我们提供了一个工具叫做 [`@babel/types`](https://babeljs.io/docs/en/babel-types)

`@babel/types` 有两个作用：

1. 判断这个节点是不是这个节点（ArrowFunctionExpression 下面的 path.node 是不是一个 ArrowFunctionExpression）
2. 生成对应的表达式

然后我们使用的时候，需要经常查文档，因为里面的节点类型特别多，不是做编译相关工作的是记不住怎么多节点的

那么接下来我们就开始生成一个 `FunctionExpression`，然后把之前的 `ArrowFunctionExpression` 替换掉，我们可以看 `types` 文档，找到 `functionExpression`，该方法接受相应的参数我们传递过去即可生成一个 `FunctionExpression`

```js
t.functionExpression(id, params, body, generator, async);
```

* id: Identifier (default: null) id 可传递 null
* params: Array\<LVal> (required) 函数参数，可以把之前的参数拿过来
* body: BlockStatement (required) 函数体，接受一个 `BlockStatement` 我们需要生成一个
* generator: boolean (default: false) 是否为 generator 函数，当然不是了
* async: boolean (default: false) 是否为 async 函数，肯定不是了

还需要生成一个 `BlockStatement`，我们接着看文档找到 `BlockStatement` 接受的参数

```js
t.blockStatement(body, directives);
```

看文档说明，`blockStatement` 接受一个 body，那我们把之前的 body 拿过来就可以直接用，不过这里 body 接受一个数组

我们在看 AST 结构，函数表达式中的 `BlockStatement` 中的 `body` 是一个 `ReturnStatement` 组成的集合，所以还需要生成一个 `ReturnStatement`

现在我们就可以改写 AST 了

```js
ArrowFunctionExpression(path) {
  // 拿到节点然后替换节点
  const node = path.node;
  // 拿到函数的参数
  const params = node.params;
  const returnStatement = t.returnStatement(node.body);
  const blockStatement = t.blockStatement([returnStatement]);
  const functionExpression = t.functionExpression(null, params, blockStatement);
  // 替换原来的函数
  path.replaceWith(functionExpression);
},
// 结果 const fn = function (a, b) { return a + b; };
```

当然如果没有返回语句的话我们也可以生成一个 `ExpressionStatement`，只需要把 `returnStatement` 改为 `ExpressionStatement` 其他逻辑不变

```js{7}
ArrowFunctionExpression(path) {
  // 拿到节点然后替换节点
  const node = path.node;
  // 拿到函数的参数
  const params = node.params;
  // 把 returnStatement 换成 expressionStatement 即可
  const expressionStatement = t.expressionStatement(node.body);
  const blockStatement = t.blockStatement([expressionStatement]);
  const functionExpression = t.functionExpression(null, params, blockStatement);
  // 替换原来的函数
  path.replaceWith(functionExpression);
},
// 结果 const fn = function (a, b) { a + b; };
```

## 按需引入

在开发中，我们引入 UI 框架，比如 vue 中用到的 `element-ui`，`vant` 或者 `React` 中的 `antd` 都支持全局引入和按需引入，默认是全局引入，如果需要按需引入就需要安装一个 `babel-plugin-import` 的插件，将全局的写法变成按需引入的写法。

就拿我最近开发移动端用的 vant 为例， `import { Button } from 'vant'` 这种写法经过这个插件之后会变成 `import Button from 'vant/lib/Button'` 这种写法，引用整个 vant 变成了我只用了 vant 下面的某一个文件，打包后的文件会比全部引入的文件大小要小很多

### 分析语法树

> `import { Button, Icon } from 'vant'` 写法转换为 `import Button from 'vant/lib/Button'; import Icon from 'vant/lib/Icon'`

看一下两个语法树的区别

根据两张图分析我们可以得到一些信息：

1. 我们发现解构方式引入的模块只有 import 声明，第二张图是两个 import 声明
2. 解构方式引入的详细说明里面(`specifiers`)是两个 `ImportSpecifier`，第二张图里面是分开的，而且都是 `ImportDefaultSpecifier`
3. 他们引入的 `source` 也不一样
4. 那我们要做的其实就是要把单个的 `ImportDeclaration` 变成多个 `ImportDeclaration`, 然后把单个 import 解构引入的 `specifiers` 部分 `ImportSpecifier` 转换成多个 `ImportDefaultSpecifier` 并修改对应的 `source` 即可

### 分析类型

为了方便传递参数，这次我们写到一个函数里面，可以方便传递转换后拼接的目录

这里我们需要用到的几个类型，也需要在 types 官网上找对应的解释

* 首先我们要生成多个 `importDeclaration` 类型

  ```js
  /**
   * @param {Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>} specifiers  (required)
   * @param {StringLiteral} source (required)
   */
  t.importDeclaration(specifiers, source);
  ```

* 在 `importDeclaration` 中需要生成 `ImportDefaultSpecifier`

  ```js
  /**
   * @param {Identifier} local  (required)
   */
  t.importDefaultSpecifier(local);
  ```

* 在 `importDeclaration` 中还需要生成一个 `StringLiteral`

  ```js
  /**
   * @param {string} value  (required)
   */
  t.stringLiteral(value);
  ```

### 上代码

按照上面的分析，我们开始上代码

```js
const babel = require('@babel/core');
const t = require('@babel/types');
const code = `import { Button, Icon } from 'vant'`;
// import Button from 'vant/lib/Button'
// import Icon from 'vant/lib/Icon'
function importPlugin(opt) {
  const { libraryDir } = opt;
  return {
    visitor: {
      ImportDeclaration(path) {
        const node = path.node;
        // console.log("ImportDeclaration -> node", node)
        // 得到节点的详细说明，然后转换成多个的 import 声明
        const specifiers = node.specifiers;
        // 要处理这个我们做一些判断，首先判断不是默认导出我们才处理，要考虑 import vant, { Button, Icon } from 'vant' 写法
        // 还要考虑 specifiers 的长度，如果长度不是 1 并且不是默认导出我们才需要转换
        if (!(specifiers.length === 1 && t.isImportDefaultSpecifier(specifiers[0]))) {
          const result = specifiers.map(specifier => {
            const local = specifier.local;
            const source = t.stringLiteral(
              `${node.source.value}/${libraryDir}/${specifier.local.name}`
            );
            // console.log("ImportDeclaration -> specifier", specifier)
            return t.importDeclaration([t.importDefaultSpecifier(local)], source);
          });
          console.log('ImportDeclaration -> result', result);
          // 因为这次要替换的 AST 不是一个，而是多个的，所以需要 `path.replaceWithMultiple(result)` 来替换，但是一执行发现死循环了
          path.replaceWithMultiple(result);
        }
      },
    },
  };
}
const r = babel.transform(code, {
  plugins: [importPlugin({ libraryDir: 'lib' })],
});
console.log(r.code);
```

看打印结果和转换结果似乎没什么问题，这个插件几乎就实现了

### 特殊情况

但是我们考虑一种情况，如果用户不全部按需加载了，按需加载只是一种选择，如果用户这么写了 `import vant, { Button, Icon } from 'vant'`，那么我们这个插件就出现问题了

如果遇到这种写法，那么默认导入的他的 `source` 应该是不变的，我们要把原来的 `source` 拿出来

所以还需要判断一下，每一个 `specifier` 是不是一个 `ImportDefaultSpecifier` 然后处理不同的 `source`，完整处理逻辑应该如下

```js
function importPlugin(opt) {
  const { libraryDir } = opt;
  return {
    visitor: {
      ImportDeclaration(path) {
        const node = path.node;
        // console.log("ImportDeclaration -> node", node)
        // 得到节点的详细说明，然后转换成多个的 import 声明
        const specifiers = node.specifiers;
        // 要处理这个我们做一些判断，首先判断不是默认导出我们才处理，要考虑 import vant, { Button, Icon } from 'vant' 写法
        // 还要考虑 specifiers 的长度，如果长度不是 1 并且不是默认导出我们才需要转换
        if (!(specifiers.length === 1 && t.isImportDefaultSpecifier(specifiers[0]))) {
          const result = specifiers.map(specifier => {
            let local = specifier.local,
              source;
            // 判断是否存在默认导出的情况
            if (t.isImportDefaultSpecifier(specifier)) {
              source = t.stringLiteral(node.source.value);
            } else {
              source = t.stringLiteral(
                `${node.source.value}/${libraryDir}/${specifier.local.name}`
              );
            }
            return t.importDeclaration([t.importDefaultSpecifier(local)], source);
          });
          path.replaceWithMultiple(result);
        }
      },
    },
  };
}
```

## babylon

> 在 babel 官网上有一句话 [Babylon is a JavaScript parser used in Babel](https://babeljs.io/docs/en/babylon).

### babylon 与 babel 的关系

`babel` 使用的引擎是 `babylon`，`Babylon` 并非 `babel` 团队自己开发的，而是 fork 的 `acorn` 项目，`acorn` 的项目本人在很早之前在兴趣部落 1.0 在构建中使用，为了是做一些代码的转换，是很不错的一款引擎，不过 `acorn` 引擎只提供基本的解析 `ast` 的能力，遍历还需要配套的 `acorn-traversal`, 替换节点需要使用 acorn-，而这些开发，在 Babel 的插件体系开发下，变得一体化了（摘自 AlloyTeam 团队的[剖析 babel](http://www.alloyteam.com/2017/04/analysis-of-babel-babel-overview/)）

### 使用 babylon

使用 babylon 编写一个数组 rest 转 Es5 语法的插件

把 `const arr = [ ...arr1, ...arr2 ]` 转成 `var arr = [].concat(arr1, arr2)`

我们使用 babylon 的话就不需要使用 `@babel/core` 了，只需要用到他里面的 `traverse` 和 `generator`，用到的包有 `babylon、@babel/traverse、@babel/generator、@babel/types`

### 分析语法树

先来看一下两棵语法树的区别

根据上图我们分析得出：

1. 两棵树都是变量声明的方式，不同的是他们声明的关键字不一样
2. 他们初始化变量值的时候是不一样的，一个数组表达式（ArrayExpression）另一个是调用表达式（CallExpression）
3. 那我们要做的就很简单了，就是把 数组表达式转换为调用表达式就可以

### 分析类型

这段代码的核心生成一个 callExpression 调用表达式，所以对应官网上的类型，我们分析需要用到的 api

* 先来分析 init 里面的，首先是 callExpression

  ```js
  /**
   * @param {Expression} callee  (required)
   * @param {Array<Expression | SpreadElement | JSXNamespacedName>} source (required)
   */
  t.callExpression(callee, arguments);
  ```

* 对应语法树上 callee 是一个 MemberExpression，所以要生成一个成员表达式

  ```js
  /**
   * @param {Expression} object  (required)
   * @param {if computed then Expression else Identifier} property (required)
   * @param {boolean} computed (default: false)
   * @param {boolean} optional (default: null)
   */
  t.memberExpression(object, property, computed, optional);
  ```

* 在 callee 的 object 是一个 ArrayExpression 数组表达式，是一个空数组

  ```js
  /**
   * @param {Array<null | Expression | SpreadElement>} elements  (default: [])
   */
  t.arrayExpression(elements);
  ```

* 对了里面的东西分析完了，我们还要生成 VariableDeclarator 和 VariableDeclaration 最终生成新的语法树

  ```js
  /**
   * @param {LVal} id  (required)
   * @param {Expression} init (default: null)
   */
  t.variableDeclarator(id, init);

  /**
   * @param {"var" | "let" | "const"} kind  (required)
   * @param {Array<VariableDeclarator>} declarations (required)
   */
  t.variableDeclaration(kind, declarations);
  ```

* 其实倒着分析语法树，分析完怎么写也就清晰了，那么我们开始上代码吧

### 上代码

```js
const babylon = require('babylon');
// 使用 babel 提供的包，traverse 和 generator 都是被暴露在 default 对象上的
const traverse = require('@babel/traverse').default;
const generator = require('@babel/generator').default;
const t = require('@babel/types');

const code = `const arr = [ ...arr1, ...arr2 ]`; // var arr = [].concat(arr1, arr2)

const ast = babylon.parse(code, {
  sourceType: 'module',
});

// 转换树
traverse(ast, {
  VariableDeclaration(path) {
    const node = path.node;
    const declarations = node.declarations;
    console.log('VariableDeclarator -> declarations', declarations);
    const kind = 'var';
    // 边界判定
    if (
      node.kind !== kind &&
      declarations.length === 1 &&
      t.isArrayExpression(declarations[0].init)
    ) {
      // 取得之前的 elements
      const args = declarations[0].init.elements.map(item => item.argument);
      const callee = t.memberExpression(t.arrayExpression(), t.identifier('concat'), false);
      const init = t.callExpression(callee, args);
      const declaration = t.variableDeclarator(declarations[0].id, init);
      const variableDeclaration = t.variableDeclaration(kind, [declaration]);
      path.replaceWith(variableDeclaration);
    }
  },
});
```

## 优雅处理 async await

异步终极解决方案：`async + await` 以同步的写法处理异步代码。一切都好，唯一有问题的就是要想捕获代码出现的问题需要使用 `try/catch` 包裹 await 代码片段。为了程序的健壮性，就可能需要在 async 中频繁的书写 `try/catch` 逻辑，此时我们可以就可以使用 ast 捕获到相应的代码然后处理没有被 `try/catch` 的 `await` 语句

```js
// 转换前
async function func() {
  await asyncFn();
}
```

```js
// 转换后
async function func() {
  try {
    await asyncFn();
  } catch (e) {}
}
```

### 分析语法树

我们发现我们要做的就是在 `AwaitExpression` await 表达式外层包裹一层 `TryStatement` try 语句

### 分析类型

那我们要做的就是生成一个 tryStatement，查看对应的 api

```js
/**
 * @param {BlockStatement} block  (required)
 * @param {CatchClause} handler  (default: null)
 * @param {BlockStatement} finalizer (default: null)
 */
t.tryStatement(block, handler, finalizer);
```

暂时先不考虑 CatchClause，先生成 try

```js
/**
 * @param {Array<Statement>} body  (required)
 * @param {Array<Directive>} directives  (default: [])
 */
t.blockStatement(body, directives);
```

再根据 ast 树结构中得到，body 是由表达式语句（ExpressionStatement）组成

```js
/**
 * @param {Expression} expression  (required)
 */
t.expressionStatement(expression);
```

在 expressionStatement 中需要的 expression 就是我们的当前捕获到的节点，那么我们就可以开始写代码了

### 代码

我们要在 AwaitExpression 中捕获代码，还需要判断该代码段的父节点没有被 try/catch 包裹，可以利用 path 参数的 findParent 方法向上遍历所有父节点，判断是否被 try/catch 的 Node 包裹

```js
AwaitExpression(path) {
  // 首先保证 await 语句没有被 try/catch 包裹
  if (path.findParent(path => t.isTryStatement(path.node))) return;
  const expression = t.expressionStatement(path.node);
  const tryBlock = t.blockStatement([expression]);
  // 生成 catch --> console.log(e)
  const paramsE = t.identifier('e');
  const memberExpression = t.MemberExpression(t.identifier('console'), t.identifier('log'));
  const consoleExpression = t.expressionStatement(t.callExpression(memberExpression, [paramsE]));
  const catchClause = t.catchClause(paramsE, t.blockStatement([consoleExpression]));
  const tryStatement = t.tryStatement(tryBlock, catchClause);
  // 数组
  path.replaceWithMultiple([tryStatement]);
}
// 得到的结果：
// async function func() {
//   try {
//     await asyncFn();
//   } catch (e) {
//     console.log(e);
//   }
// }
```

### 其他情况

另外我们要考虑到 await 表达式可能出现其他情况，可以直接声明变量赋值，可以直接赋值，然后就是刚刚处理的直接一个表达式

```js
// 声明变量赋值
const r = await asyncFn();
// 赋值
r = await asyncFn();
// 就是一个表达式
await asyncFn();
```

此时我们可以区分不同的情况做不同的处理，再次观察语法树，发现他们的区别在 blockStatement 节点下面，那么我们就可以直接替换这一级就可以，顺便把 catch 语句补充完整

此时我们输入的代码如下：

```js
async function func() {
  const r = await asyncFn1();
  res = await asyncFn2();
  await asyncFn3();
}
```

处理过程：

```js
AwaitExpression(path) {
  // 首先保证 await 语句没有被 try/catch 包裹
  if (path.findParent(path => t.isTryStatement(path.node))) return;
  const parent = path.parent;
  let replacePath = null;
  if (t.isVariableDeclarator(parent) || t.isAssignmentExpression(parent)) {
    // 赋值和声明的方式结构类似，都是在 AwaitExpression 中 path 的 parentPath.parentPath 上的节点就是 blockStatement 所需要的的参数，可以直接这么替换
    replacePath = path.parentPath.parentPath;
  } else {
    // 如果只是表达式的话，path.parentPath.node 就是 blockStatement 参数
    replacePath = path.parentPath;
  }
  const tryBlock = t.blockStatement([replacePath.node]);
  // 生成 catch --> new Error(e)
  const paramsE = t.identifier('e');
  const throwStatement = t.throwStatement(t.newExpression(t.identifier('Error'), [paramsE]));
  const catchClause = t.catchClause(paramsE, t.blockStatement([throwStatement]));
  const tryStatement = t.tryStatement(tryBlock, catchClause);
  replacePath.replaceWithMultiple([tryStatement]);
},
// 得到结果
// async function func() {
//   try {
//     const r = await asyncFn1();
//   } catch (e) {
//     throw new Error(e);
//   }

//   try {
//     res = await asyncFn2();
//   } catch (e) {
//     throw new Error(e);
//   }

//   try {
//     await asyncFn3();
//   } catch (e) {
//     throw new Error(e);
//   }
// }
```

## 具体语法书

和抽象语法树相对的是具体语法树（`Concrete Syntax Tree`）简称 `CST`（通常称作分析树）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦 AST 被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。可参考[抽象语法树和具体语法树有什么区别？](https://www.it-swarm.dev/zh/parsing/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%E5%92%8C%E5%85%B7%E4%BD%93%E8%AF%AD%E6%B3%95%E6%A0%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/968637142/)

## 补充

关于 node 类型，全集大致如下：

```sh
(parameter) node: Identifier | SimpleLiteral | RegExpLiteral | Program | FunctionDeclaration | FunctionExpression | ArrowFunctionExpression | SwitchCase | CatchClause | VariableDeclarator | ExpressionStatement | BlockStatement | EmptyStatement | DebuggerStatement | WithStatement | ReturnStatement | LabeledStatement | BreakStatement | ContinueStatement | IfStatement | SwitchStatement | ThrowStatement | TryStatement | WhileStatement | DoWhileStatement | ForStatement | ForInStatement | ForOfStatement | VariableDeclaration | ClassDeclaration | ThisExpression | ArrayExpression | ObjectExpression | YieldExpression | UnaryExpression | UpdateExpression | BinaryExpression | AssignmentExpression | LogicalExpression | MemberExpression | ConditionalExpression | SimpleCallExpression | NewExpression | SequenceExpression | TemplateLiteral | TaggedTemplateExpression | ClassExpression | MetaProperty | AwaitExpression | Property | AssignmentProperty | Super | TemplateElement | SpreadElement | ObjectPattern | ArrayPattern | RestElement | AssignmentPattern | ClassBody | MethodDefinition | ImportDeclaration | ExportNamedDeclaration | ExportDefaultDeclaration | ExportAllDeclaration | ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier
```

Babel 有文档对 AST 树的详细定义，可参考[这里](https://github.com/babel/babylon/blob/master/ast/spec.md)

## 代码地址

代码以存放到 GitHub，[地址](https://github.com/fecym/ast-share.git)

## 相关链接

1. [JavaScript 语法解析、AST、V8、JIT](https://cheogo.github.io/learn-javascript/201709/runtime.html)
2. [详解 AST 抽象语法树](https://blog.csdn.net/huangpb123/article/details/84799198)
3. [AST 抽象语法树](https://segmentfault.com/a/1190000016706589?utm_medium=referral\&utm_source=tuicool) ps: 这个里面有 class 转 Es5 构造函数的过程，有兴趣可以看一下
4. [剖析 Babel——Babel 总览 | AlloyTeam](http://www.alloyteam.com/2017/04/analysis-of-babel-babel-overview)
5. [不要给 async 函数写那么多 try/catch 了](https://juejin.im/post/5d25b39bf265da1bb67a4176)
6. [@babel/types](https://babeljs.io/docs/en/babel-types)
7. [文章已同步掘金](https://juejin.im/post/5eef4b416fb9a058583e7d71)

---

---
url: /docs/views/plugins/chrome.md
---


---

---
url: /docs/01.前端/01. 基础/css.md
---

## css 加载会造成阻塞吗

> js 加载会造成 *DOM* 树的解析和渲染

### css 加载会造成 DOM 树的阻塞嘛？

* 首先，*css* 加载会阻塞 *DOM* 树渲染，但是 *css* 并不会阻塞 *DOM* 树的解析
* 也就是说，你可以在 *css* 加载完之前可以在 *js* 中获取到 *DOM* 元素，但是 *DOM* 却是没有渲染到页面上，需要等到 *css* 加载完毕才渲染
* 为什么会这样？
  * 在你加载 *css* 的时候，可能会修改 *DOM* 节点的样式，如果 *css* 加载不阻塞 *DOM* 树渲染的话，那么当 *css* 加载完之后， *DOM* 树可有又得重绘或者回流了
  * 所以干脆先把 *DOM* 树的结构先解析完成，把可以做的工作做完，然后等你 *css* 加载完之后，再根据最终样式来渲染 *DOM* 树，这种做法性能方面确实会比较好一点。（猜测）

### css 加载会阻塞 js 运行嘛？

* css 加载会阻塞**后面的 js 语句**的执行

### 总结

1. css 加载不会阻塞 *DOM* 树的解析；
2. css 加载会阻塞 *DOM* 树的渲染；
3. css 加载会阻塞后面 js 语句的执行

### 浏览器渲染流程

* 浏览器渲染的流程如下：
  1. *html* 解析文件，生成 *DOM* 树，解析 *css* 文件生成 *CSSOM* 树
  2. 将 *DOM* 树和 *CSSOM* 树结合，生成 *Render Tree*
  3. 根据 *Render Tree* 渲染机制，将像素渲染到屏幕上
* 从浏览器渲染流程可以看出
  1. *DOM* 解析和 *CSS* 解析是两个并行的进程，所以这也解释了为什么 *css* 加载不会阻塞 *DOM* 的解析
  2. 然而，由于 *Render Tree* 是依赖与 *DOM Tree* 和 *CSSOM Tree*，所以它必须等到 *CSSOM Tree* 构建完成，也就是 *css* 资源加载完成(或者加载失败)后，才开始渲染，因此，css 加载是会阻塞 *DOM* 的渲染的
  3. 由于 *js* 可能会操作之前的 *dom* 节点和 *css* 样式，因此浏览器会维持 *html* 中 *css* 和 *js* 的顺序。因此，样式表会在后面的 *js* 执行前先加载执行完毕。所以 *css* 会阻塞后面 *js* 的执行

### DOMContentLoaded

* 对于浏览器来说，页面加载主要有两个事件，一个是 *DOMContentLoaded*，另一个是 *onLoad*
* *onload* 就是等待页面所有资源都在加载完成才会触发，这些资源包括 css、js、图片视频等
* *DOMContentLoaded* 顾明思议就是当页面的**内容解析完成后**，则触发该事件
  * 如果页面中同时存在 css 和 js，并且**js 在 css 后面**，则 *DOMContentLoaded* 事件会在 css 加载完后才执行
  * 其他情况下，*DOMContentLoaded* 都不会等待 css 加载，并且 *DOMContentLoaded* 事件也不会等待图片、视频等其他资源加载

## css 自定义属性

> 17 年 3 月份，微软宣布 *Edge* 浏览器支持 *css* 变量，那就说明所有浏览器都支持了

### 变量的声明

* 变量声明的时候，变量名前面要加两个横线 **--**

```css {2}
:root {
  --color: green;
  --base-size: 4px;
}
.foo {
  --theme-color: red;
  --border-radios-num: 4px;
}
```

* 它们与 color、font-size 等正式属性没有什么不同，只是没有默认含义。所以 *CSS* 变量（*CSS variable*）又叫做"*CSS* 自定义属性"（*CSS custom properties*）。因为变量与自定义的 *CSS* 属性其实是一回事。
* 因为 *$color* 被 *Sass* 用掉了，*@color* 被 *Less* 用掉了。为了不产生冲突，官方的 *CSS* 变量就改用两根连词线了。
* 变量名大小写敏感，--header-color 和--Header-Color 是两个不同变量。

### 变量的使用

* *var()* 函数用于读取变量
* *var()* 函数还可以使用第二个参数，表示变量的默认值。如果变量不存在，就会使用默认值。

```css {3}
p {
  /* color: var(--theme-color); */
  color: var(--color, #7f583f);
  border: 1px solid #000;
  border-radius: var(--border-radios-num);
}
```

* 变量值只能用作属性值，不能用作属性名。

### 变量的作用域

* 同一个 *CSS* 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 *CSS* 的"层叠"（cascade）规则是一致的。

```html
<style>
  :root {
    --color: blue;
  }
  div {
    --color: green;
  }
  #alert {
    --color: red;
  }
  * {
    /* 使用变量 */
    color: var(--color);
  }
</style>
<body>
  <p>蓝色</p>
  <div>绿色</div>
  <div id="alert">红色</div>
</body>
```

* 上面代码中，三个选择器都声明了 *--color* 变量。不同元素读取这个变量的时候，会采用优先级最高的规则，因此三段文字的颜色是不一样的。
* 也就是说，变量的作用域就是它所在的选择器的有效范围。
* 所以全局的变量通常放在根元素 *:root* 里面，确保任何选择器都可以读取它们。
* [参考链接](https://www.ruanyifeng.com/blog/2017/05/css-variables.html)

## *margin*

* 关于 *margin*，有几点需要注意下
* *margin* 的 *top 和 bottom* 对非替换内联元素无效（可以暂时理解为行内元素）
* 不过对于 *display: inline-block;* 的元素设置是有效的
* 但是 *margin: auto* 对于 *display: inline-block;* 的元素设置是无效的
* 对于 *display: inline-block;* 的元素设置居中需要用到 *text-align: center;*
* *margin* 塌陷暂时不提

## 居中

### 利用 *absolute* + *负 margin* 实现

* 要求：已知宽高

```html {23}
<style>
  /* 公共代码 */
  .parent {
    border: 1px solid red;
    width: 300px;
    height: 300px;
  }
  .child {
    width: 100px;
    height: 100px;
    background: green;
  }
  /* 公共代码 */

  /* 核心代码 */
  .parent {
    position: relative;
  }
  .child {
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
  }
</style>
<body>
  <div class="parent">
    <div class="child">content</div>
  </div>
</body>
```

### 利用 *position* + *margin auto* 实现

* 科普一下，我以为认为这种方法是不可以实现居中，曾面试别人的时候，我还理直气壮的跟别人说，你这个根本实现不了
* 今天，我才感觉自己当时是多么的无知，当然核心原理是**已知要居中元素的宽高**
* 如果要居中元素的宽高**未知**，那么这么设置会让子元素的*宽高变得和父亲的宽高一样*，同时 *margin: auto* 也是无效的
* 这可能也是我当时理解错的地方，所以跟人家说这个根本实现不了
* 要求：已知宽高

```html {25}
<style>
  /* 公共代码 */
  .parent {
    border: 1px solid red;
    width: 300px;
    height: 300px;
  }
  .child {
    width: 100px;
    height: 100px;
    background: green;
  }
  /* 公共代码 */

  /* 核心 */
  .parent {
    position: relative;
  }
  .child {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
  }
</style>
<body>
  <div class="parent">
    <div class="child">content</div>
  </div>
</body>
```

### 利用 *position* + *calc 函数* 实现

* 他的原理跟第一种基本一样
* 要求已知宽高

```html
<style>
  /* 公共代码 */
  .parent {
    border: 1px solid red;
    width: 300px;
    height: 300px;
  }
  .child {
    width: 100px;
    height: 100px;
    background: green;
  }
  /* 公共代码 */

  /* 核心 */
  .parent {
    position: relative;
  }
  .child {
    position: absolute;
    top: calc(50% - 50px);
    left: calc(50% - 50px);
  }
</style>
<body>
  <div class="parent">
    <div class="child">content</div>
  </div>
</body>
```

### 利用 *position* + *transform* 实现

* 这个方法经常用在移动端或者那些不确定宽高的情况下
* 不需要知道子盒子的宽度和高度，也是我经常用的一种

```html {31}
<style>
  :root {
    --width: 100px;
    --height: 100px;
    --bgc: green;
  }
  /* 公共代码 */
  .parent {
    border: 1px solid red;
    width: 300px;
    height: 300px;
  }

  .child {
    /* 宽高是动态的，未知的 */
    width: var(--width);
    height: var(--height);
    background: var(--bgc);
  }
  /* 公共代码 */

  /* 核心 */
  .parent {
    position: relative;
  }

  .child {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
</style>
<body>
  <div class="parent">
    <div class="child">content</div>
  </div>
</body>
```

### 利用 *text-align* + *lineheight* 实现

* 这种方法，可以使元素不脱标，在标准流下实现居中
* 但是，要求**子盒子**不能是*块级元素*（也可以转成行内或者行内块元素）
* 此时只需要给父盒子设置样式即可，*lineheight 必须设置为父盒子的高度*

```html
<style>
  /* 公共代码 */
  .parent {
    border: 1px solid red;
    width: 300px;
    height: 300px;
  }
  .child {
    padding: 50px;
    background: green;
  }
  /* 公共代码 */

  /* 核心 */
  .parent {
    text-align: center;
    line-height: 300px;
  }
</style>
<body>
  <div class="parent">
    <!-- <div class="child">content</div> -->
    <span class="child">子</span>
  </div>
</body>
```

### 利用 *writing-mode* 来实现

::: tip
介绍下*writing-mode* 属性：顾名思义是书写方式，那就是文字写书方式，就是文字是横排还是竖排。

* 因为 *writing-mode* 是曾经是 IE 私有的，后来被各大浏览器所支持，所以他有两套不同的语法

* css3 规范的语法
  * *writing-mode: horizontal-tb;* -> *tb（top-bottom）*，元素是从上到下堆叠的
  * *writing-mode: vertical-rl;* -> *rl（right-left）*，表示文字是垂直方向(*vertical*)展示，然后阅读顺序是从右往左
  * *writing-mode: vertical-lr;* -> *lr（left-right）*，表示文字是垂直方向(*vertical*)展示，然后阅读顺序是从左往右
  * *writing-mode: inherit;*
  * *writing-mode: initial;*
  * *writing-mode: unset;*

* *writing-mode* 使得默认的水平流改成了垂直流。具体介绍请看[张鑫旭](https://www.zhangxinxu.com/wordpress/2016/04/css-writing-mode/)大大的博客
  :::

* 其实原理也是跟 *text-align* + *lineheight* 实现差不多，只不过水平流变成了垂直垂直流

```html {23}
<style>
  /* 公共代码 */
  .parent {
    border: 1px solid red;
    width: 300px;
    height: 300px;
  }
  .child {
    width: 100px;
    height: 100px;
    background: green;
  }
  /* 公共代码 */

  /* 核心 */
  .parent {
    writing-mode: vertical-rl;
    text-align: center;
    line-height: 300px;
  }
  .child {
    writing-mode: horizontal-tb;
    line-height: 100px;
    display: inline-block;
  }
</style>
<body>
  <div class="parent">
    <div class="child">content</div>
  </div>
</body>
```

* 注意高亮的弟 23 行，为什么又设置了一次 *line-height*，因为子元素被定义成了 *inline-block*，*inline-block* 是有一些问题的，需要特殊处理

### 利用 *table* 表格布局实现

* 表格布局，现在布局基本不用这种方式了，所以暂时不做介绍了

### 利用 *table-cell* 来实现

* 原理就是将 div 转换为 table 布局

```html
<style>
  /* 公共代码 */
  .parent {
    border: 1px solid red;
    width: 300px;
    height: 300px;
  }
  .child {
    width: 100px;
    height: 100px;
    background: green;
  }
  /* 公共代码 */

  /* 核心 */
  .parent {
    display: table-cell;
    text-align: center;
    vertical-align: middle;
  }
  .child {
    display: inline-block;
  }
</style>
<body>
  <div class="parent">
    <div class="child">content</div>
  </div>
</body>
```

### 利用 *flex* 布局实现

* *flex* 布局作为 css 最强大布局方式，不多做介绍

```html {17}
<style>
  /* 公共代码 */
  .parent {
    border: 1px solid red;
    width: 300px;
    height: 300px;
  }
  .child {
    width: 100px;
    height: 100px;
    background: green;
  }
  /* 公共代码 */

  /* 核心 */
  .parent {
    display: flex;
    justify-content: center;
    align-items: center;
  }
</style>
<body>
  <div class="parent">
    <div class="child">content</div>
  </div>
</body>
```

### 利用 *grid* 网格布局实现

* *grid* 作为 css 新宠，也是很强大的，只是兼容性不好，但是写法也很简单

```html {17}
<style>
  /* 公共代码 */
  .parent {
    border: 1px solid red;
    width: 300px;
    height: 300px;
  }
  .child {
    width: 100px;
    height: 100px;
    background: green;
  }
  /* 公共代码 */

  /* 核心 */
  .parent {
    display: grid;
  }
  .child {
    align-self: center;
    justify-self: center;
  }
</style>
<body>
  <div class="parent">
    <div class="child">content</div>
  </div>
</body>
```

## 布局 - 左边固定右边自适应

### 经典方案 float

```html
<style>
  .container {
    overflow: hidden;
  }
  .left {
    float: left;
    width: 200px;
    height: 100vh;
    background-color: blue;
  }
  .right {
    margin-left: 200px;
    height: 100vh;
    background-color: green;
  }
</style>
<body>
  <div class="container">
    <div class="left"></div>
    <div class="right"></div>
  </div>
</body>
```

### 经典方案 定位

```html
<style>
  .container {
    position: relative;
  }
  .left {
    position: absolute;
    width: 200px;
    height: 100vh;
    background-color: blue;
  }
  .right {
    margin-left: 200px;
    height: 100vh;
    background-color: green;
  }
</style>
<body>
  <div class="container">
    <div class="left"></div>
    <div class="right"></div>
  </div>
</body>
```

### flex 布局

```html
<style>
  .container {
    display: flex;
  }
  .left {
    width: 200px;
    height: 100vh;
    background-color: blue;
  }
  .right {
    flex: 1;
    height: 100vh;
    background-color: green;
  }
</style>
<body>
  <div class="container">
    <div class="left"></div>
    <div class="right"></div>
  </div>
</body>
```

## 层叠上下文和层叠顺序

### 层叠上下文

* 在 css2.1 规范中，每个盒模型的位置是三维的，分别是平面画布上的 x 轴，y 轴以及表示层叠的z 轴
* z 轴：表示的是用户与屏幕的这条看不见的垂直线

- 一般情况下，元素在页面上沿 x 轴 y 轴平铺，我们察觉不到它们在 z 轴上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。它们的层叠关系我们可称为层叠上下文。
- 元素的层叠等级（谁在谁上边）是由其所在的层叠上下文决定的
- 层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级是没有意义的。
- 如何生成层叠上下文？
  1. HTML 中根元素本身就具有层叠上下文，称为根层叠上下文
  2. 普通元素设置 *position* 属性为非 *static* 值并设置 *z-index* 属性为具体数值，产生层叠上下文
  3. css3 中的新属性也可以产生层叠上下文
- 说的多不如上代码，来的直接，上代码，和效果图

```html
<style>
  div {
    width: 300px;
    position: relative;
    color: white;
  }
  p {
    width: 300px;
    height: 300px;
    position: absolute;
  }
  .a {
    z-index: 1;
    background-color: red;
  }
  .b {
    z-index: 2;
    background-color: green;
    top: 20px;
    left: 20px;
  }
  .c {
    z-index: 3;
    background-color: blue;
    top: 40px;
    left: 40px;
  }
</style>
<div>
  <p class="a">我是a</p>
  <p class="b">我是b</p>
</div>
<div>
  <p class="c">我是c</p>
</div>
```

* 还有一种情况就是，当父盒子也设置为层叠上下文，那么就会根据父盒子的 *z-index* 来处理，子盒子设置再高也不行，上代码和图

```html {9}
<style>
  div {
    width: 300px;
    height: 300px;
    position: relative;
    color: white;
  }
  .box1 {
    z-index: 2;
  }
  .box2 {
    z-index: 1;
  }
  p {
    width: 300px;
    height: 300px;
    position: absolute;
  }
  .a {
    z-index: 10;
    background-color: red;
  }
  .b {
    z-index: 20;
    background-color: green;
    top: 20px;
    left: 20px;
  }
  .c {
    z-index: 99999;
    background-color: blue;
    top: -260px;
    left: 40px;
  }
</style>
<div class="box1">
  <p class="a">我是a</p>
  <p class="b">我是b</p>
</div>
<div class="box2">
  <p class="c">我是c</p>
</div>
```

* 为什么出现这种情况？举个例子：处于层叠上下文中的元素，就像是元素当了官，等级自然比普通元素高。再想象一下，假设一个官员 A 是个省级领导，他下属有一个秘书 a-1，家里有一个保姆 a-2。另一个官员 B 是一个县级领导，他下属有一个秘书 b-1，家里有一个保姆 b-2。a-1 和 b-1 虽然都是秘书，但是你想一个省级领导的秘书和一个县级领导的秘书之间有可比性么？甚至保姆 a-2 都要比秘书 b-1 的等级高得多。谁大谁小，谁高谁低一目了然，所以根本没有比较的意义。只有在 A 下属的 a-1、a-2 以及 B 下属的 b-1、b-2 中相互比较大小高低才有意义。

### 层叠顺序

* 层叠顺序表示元素发生层叠时按照特定的顺序规则在*Z 轴*上垂直显示
  1. 左上角"层叠上下文 background/border"指的是层叠上下文元素的背景和边框。
  2. **inline/inline-block**元素的层叠顺序要高于**block(块级)/float(浮动)元素**。
  3. 单纯考虑层叠顺序，z-index: auto 和 z-index: 0 在同一层级，但这两个属性值本身是有根本区别的。
* 为什么**inline/inline-block**元素的层叠顺序要高于**block(块级)/float(浮动)元素**？
  * 网页设计之初最重要的就是文字内容，所以在发生层叠时会优先显示文字内容，保证其不背覆盖
* 如何在遇到元素层叠时，能很清晰地判断出谁在上水在下？
  1. 首先比较两个元素是否处于同一个层叠上下文中
  2. 如果处于同一个层叠上下文中，谁的层级等级大谁在上面（根据图）
  3. 如果两个元素不在统一层叠上下文中，请先比较他们所处的层叠上下文的层叠等级
  4. 当两个元素层叠等级相同、层叠顺序相同时，在**DOM 结构中后面的元素**层叠等级在前面元素之上
* *z-index: auto*的情况下，不产生层叠上下文

### css3 影响层叠上下文的属性

* 父元素的 *display* 属性值为 *flex|inline-flex*，子元素的 *z-index* 属性值不为 *auto* 的时候，子元素为层叠上下文元素
* 元素的 *opacity* 属性值不是 1
* 元素的 *transform* 属性值不是 *node*
* 元素的 *mix-blend-mode* 属性值不是 *normal*
* 元素的 *filter* 属性值不是 *node*
* 元素的 *isolation* 属性值是 *isolate*
* *will-change* 指定的属性值为上面的任意一个
* 元素的 *-webkit-overflow-scrolling* 属性值为 *touch*

```html {3}
<style>
  .box {
    display: flex;
  }
  .parent {
    width: 200px;
    height: 100px;
    background-color: skyblue;
    z-index: 1;
  }
  .child {
    width: 100px;
    height: 200px;
    background: greenyellow;
    position: relative;
    z-index: -1;
  }
</style>
<div class="box">
  <div class="parent">
    parent
    <div class="child">child</div>
  </div>
</div>
```

* 参考链接，[张鑫旭大大博客](https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/)、[MagicEyeslv 的彻底搞懂 CSS 层叠上下文...](https://juejin.im/post/5b876f86518825431079ddd6)

## css 选择器

### 伪类和伪元素

* 以 **:** 开头的是伪类，比如：:last-child
* 以 **::** 开头的是伪元素，比如：::after

### + 和 ~

* **+** 选择器，被称为相邻选择符，可选择紧接在另一元素后的元素，且二者有相同父元素。如下代码，此时 *test-2* 将会变成红色
* **~** 选择器，被称为兄弟选择符，位置无须紧邻，只须同层级，A~B 选择 A 元素之后所有同层级 B 元素，如下，*And here is a span.* 将变成红色

```html
<!-- 相邻选择器 -->
<style>
  .test + li {
    color: red;
  }
</style>
<ul>
  <li class="test">test-1</li>
  <li>test-2</li>
  <li>test-3</li>
</ul>
```

```html
<!-- 兄弟选择器 -->
<style>
  p ~ span {
    color: red;
  }
</style>
<span>This is not red.</span>
<p>Here is a paragraph.</p>
<code>Here is some code.</code>
<span>And here is a span.</span>
```

### :not()

* **:not(X)** 被称为否定伪类，也叫 **排除选择器**。是一个简单的以选择器 *X* 为参数的功能性标记函数。它匹配不符合参数选择器 *X* 描述的元素。*X* 不能包含另外一个否定选择器
* **:not(X)** 伪类的优先级即为它参数选择器的优先级。**:not(X)** 伪类不像其它伪类，它不会增加选择器的优先级。
* 如下代码，该选择可以很好的用在，排除谁在外的其他元素设置样式，比如导航栏的最后一个不需要 *margin-right*，其他都有 *margin* 就可以这么玩

```html
<style>
  li:not(:last-child) {
    margin-right: 20px;
  }
</style>
<ul>
  <li>首页</li>
  <li>首页</li>
  <li>首页</li>
  <li>首页</li>
  <li>首页</li>
</ul>
```

### ::first-line

* **::first-line** 伪元素，顾名思义是设置一个元素内的第一行的样式。第一行的长度取决于很多因素，包括元素宽度，文档宽度和文字大小。
* **::first-line** 只能在块元素中，所以 **::first-line** 只能在一个 *display* 值为 *block*, *inline-block*, *table-cell* 或者 *table-caption* 中有用。在其他的类型中，**::first-line** 是不起作用的.
* 如下代码，只有第一行会被设置为红色，但是如果没有换行的话，就是全部红色了哦

```html
<style>
  p::first-line {
    color: red;
  }
</style>
<p>
  <span>::first-line-1</span>
  <br />
  <span>::first-line-2</span>
  <br />
  <span>::first-line-3</span>
  <br />
  <span>::first-line-4</span>
  <br />
  <span>::first-line-5</span>
</p>
```

### :nth-child(an+b)

* **:nth-child(an+b)** 首先找到所有当前元素的兄弟原色，然后按照位置的先后顺序从 1 开始排序，选择结果为 **(an+b)** 个元素的集合 **(n=0, 1, 2, 3..)**
* 0n+3或简单3匹配第三个元素
* 1n+0或简单n匹配每一个元素
* 2n+0或简单2n匹配位置为 2、4、6、8...的元素
* 2n+1匹配位置为 1、3、5、7...的元素
* 完整语法就是 an+b，我们基本使用之传入一个数字，来告诉选择器我们选择哪个元素，css 的排序规则是从1开始的，这点跟js不一样
* :nth-last-child(an+b) 语法跟 :nth-child(an+b) 基本一样，不一样的地方是，:nth-last-child(an+b) 是倒着数的

## 浏览器的滚动 scroll

### 设置滚动条的滚动高度

* 最常用的方法就是 window.scrollTo(0, 100)

```js
// 绝对滚动到距离上边100
window.scrollTo(0, 100);
// 或者传递一个对象
window.scrollTo({
  left: 0,
  top: 100,
});
```

* 也可以使用相对滚动设置 scrollBy

```js
// 每次滚动相对于当前位置，向下滚动100
window.scrollBy(0, 100);
// 或者
window.scrollBy({
  left: 0,
  top: 100,
});
```

* 再或者直接使用 scrollTop 设置

```js
document.scrollingElement.scrollTop = 100;
```

### 如何指定一个元素显示在指定的位置

* 最常用的方法就是：获取到元素距离文档顶部的距离，然后设置滚动条的高度过去

```js
const offsetTop = document.getElementById('scroll').offsetTop;
// 设置滚动条的高度
window.scrollTo(0, offsetTop);
```

* 也可以使用锚点

```html
<a href="#box">我要看这个盒子</a>
<div id="box">你要看的盒子</div>
```

* 或者直接使用 scrollIntoView API

```js
// 不传参数，默认跳到该元素的顶端
document.getElementById('scroll').scrollIntoView();
// 还可以指定元素出现在指定的位置
document.getElementById('scroll').scrollIntoView({
  // 不传参数默认为start
  block: 'start' | 'center' | 'end',
});
```

### 平滑的移动

* 如果使他们平滑的移动呢，可以传递一个参数 behavior 设置为 smooth

```js
window.scrollTo({
  // 将浏览器的行为设置为平滑的移动
  behavior: 'smooth',
});
window.scrollBy({
  behavior: 'smooth',
});
document.getElementById('scroll').scrollIntoView({
  behavior: 'smooth',
});
```

* 也可以使用 css 属性进行设置

```css
html {
  /* 使得全局的滚动都具有平滑的效果 */
  scroll-behavior: smooth;
}
/* 或者设置所有的滚动 */
* {
  scroll-behavior: smooth;
}
```

### 横向滚动

* 设置横向滚动其实很简单，以前我的做法是利用 js 做的，完全是因为基础不扎实的缘故
* 其实 css 完全可以实现横线滚动，而且不需要动态的计算父盒子的宽度然后进行设置
* 具体实现如下，我们只需要设置为超出不换行就可以了

```html {5}
<style>
  ul {
    overflow-x: auto;
    /* 超出不换行 */
    white-space: nowrap;
  }
  li {
    display: inline-block;
    border: 3px solid #000;
    border-radius: 4px;
  }
  li:not(:last-child) {
    margin-right: 20px;
  }
  img {
    display: block;
    width: 260px;
    height: 150px;
  }
</style>
<ul>
  <li><img src="./imgs/1.jpg" alt="" /></li>
  <li><img src="./imgs/2.jpg" alt="" /></li>
  <li><img src="./imgs/3.jpg" alt="" /></li>
  <li><img src="./imgs/4.jpg" alt="" /></li>
  <li><img src="./imgs/5.jpg" alt="" /></li>
  <li><img src="./imgs/6.jpg" alt="" /></li>
</ul>
```

### 滑动小技巧

* 之前看到别人的网站首页，滑动页面，滑动很少一部分的时候页面调回到原来的起点，滑动大于一半的时候页面跳到下个页面
* 相信你对这个也感兴趣吧，他们是怎么实现的呢其实很简单，用 css 完全可是实现，看下面的代码

```css
/* 还是接着上面的代码，这里只做一下补充 */
ul {
  scroll-snap-type: x mandatory;
}
li {
  scroll-snap-align: center;
}
```

## position

> **position** 常用到的属性值有：*relative*、*absolute*、*fixed*，*absolute* 相对于父元素来定位的，*fixed* 相对于浏览器窗口定位的。那么可以改变 *fixed* 让他相对于父元素定位嘛？

### fixed 可以相对于父元素进行定位吗？

* 首先，答案是可以的，而且很简单，只需要给他的父元素设置 transform: translate(0, 0); 即可
* 在 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position) 中提到 当元素祖先的 transform 属性非 none 时，定位容器由视口改为该祖先。
* 其实有三种情况会发生这种情况：
  * transform 属性值不为 none 的元素
  * perspective 属性值不为 none 的元素
  * 在 will-change 中指定了任意 CSS 属性
* [参考文章](https://www.cnblogs.com/coco1s/p/7358830.html)

### 粘性布局 sticky

* 单词 sticky 的中文意思是"粘性的"，position: sticky 表现也符合这个粘性的表现。基本上，可以看出是 position: relative 和 position: fixed 的结合体——当元素在屏幕内，表现为 relative，就要滚出显示器屏幕的时候，表现为 fixed。例如，可以滚动下面这个框框感受下交互表现：

- 这个效果其实就是设置了 position: sticky 来实现的
- 给标题设置了这个属性，然后设置 top 值为 0，此时在标题将要滚动出在屏幕的时候自动会变成 fixed 的效果
- 参考 [张鑫旭的 position:sticky ](https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/)

---

---
url: /docs/02.服务端/node/fs.md
---

> fs 模块是 nodejs 的核心模块，使用该模块只需要引入而不需要下载，对文件系统的操作，不外乎增删改查，我们就从这几步来入手

## 文件操作

### 读取文件

* fs 模块所有的都有同步和异步语法，异步语法直接写 api，同步写法就是 api 后紧跟 sync(同步)
* fs.readFile() 就是异步写法，那么同步写法就是 fs.readFilSync()
* 异步写法的返回值在回调函数中，同步写发直接就有返回值，这基本上也是 fs 所有模块的写法

```js
const fs = require('fs');
const path = require('path');
const resolve = dir => path.join(__dirname, '..', dir);
// 异步写法
fs.readFile(resolve('file/test.html'), 'utf8', (err, data) => {
  if (err) throw err;
  // data就是他的返回值
  console.log('异步测试：--> ' + data);
});
// 同步写法
const result = fs.readFileSync(resolve('file/test.txt'), 'utf8');
// result就是返回值，返回读取到的文件内容
console.log(result);
```

* fs.readFile 接受三个参数 (path\[, options], callback)
  * 文件目录、{ 文档编码, 文件系统标志 }, 回调函数(err, data)
  * node 基本上所有的 api 的回调函数的第一个参数都是错误
  * 如上面的写法就是 node 读取一个文件的例子

### 写入文件

* fs.writeFile 接受四个参数(file, data\[, options], callback)
* 跟读取很像，不过第二个参数变成了要写入的数据
* options 参数中有个 flag，表示你要怎么写入文件 [传送门](/node/fs.html#写入文件)
* r 代表读取文件，w 代表写文件，a 代表追加。，默认为 w

```js
const data = Buffer.from('hello world');
const options = {
  encoding: 'utf8',
  mode: 0o666,
  // 文件描述符，r代表读取文件，w代表写文件，a代表追加。，默认为w
  // 'flag': 'w'
  flag: 'a',
};
fs.writeFile(resolve('write/options.txt'), data, options, err => {
  if (err) throw err;
  console.log('文件写入成功');
});
```

### 追加文件

* fs.appendFile()，跟 fs.writeFile 基本不一样
* 不一样的地方是，fs.appendFile() 默认的 flag 是 a

### 复制文件

* fs.copyFile() 看文档吧，[传送门](http://nodejs.cn/api/fs.html#fs_fs_copyfile_src_dest_flags_callback)

### 链接文件

* 我们所认为的文件的复制操作，对于计算机而言是建立文件链接，把文件备份被称为硬链接（hard link）
* 把文件创建一个快捷方式就是软链接，也叫符号链接（symbolic link），软链接就是快捷方式
* fs 提供了这么两种方法，fs.link()就是备份文件，fs.symlink()就是软链接
* 接收三个参数，originPath，targetPath，callback(err)，前两个参数必须到 filename，你可以备份后名字不一样，但是不可以不写清楚 filename

```js
// 硬链接，备份文件
fs.link(resolve('file/test.txt'), resolve('write/test_copy.txt'), err => {
  if (err) throw err;
  console.log('文件备份成功');
});
// 软链接，快捷方式
fs.symlink(resolve('file/test.txt'), resolve('write/test_symbolic.txt'), err => {
  if (err) throw err;
  console.log('建立软链接成功');
});
```

### 删除文件

* 删除文件很简单，备份文件是 link 那么删除就是 unlink 了
* 两个参数，path 和 callback

```js
fs.unlink(resolve('write/options.txt'), err => {
  if (err) throw err;
  console.log('文件删除成功');
});
```

### 重命名文件

* fs.rename() 方法接收三个参数，源名字，新名字，回调函数
* 如果第一个参数和第二个参数不在同一个文件夹内，还会造成移动文件
* 如果新名字存在，则会覆盖它

```js
fs.rename(resolve('file/1.txt'), '哈哈哈.js', err => {
  if (err) throw err;
  console.log('重命名完成');
});
```

### 文件系统标志

> 当 flag 选项采用字符串时，可用以下标志：

* 'a' - 打开文件用于追加。如果文件不存在，则创建该文件。
* 'ax' - 与 'a' 相似，但如果路径已存在则失败。
* 'a+' - 打开文件用于读取和追加。如果文件不存在，则创建该文件。
* 'ax+' - 与 'a+' 相似，但如果路径已存在则失败。
* 'as' - 以同步模式打开文件用于追加。如果文件不存在，则创建该文件。
* 'as+' - 以同步模式打开文件用于读取和追加。如果文件不存在，则创建该文件。
* 'r' - 打开文件用于读取。如果文件不存在，则出现异常。
* 'r+' - 打开文件用于读取和写入。如果文件不存在，则出现异常。
* 'rs+' - 以同步模式打开文件用于读取和写入。指示操作系统绕过本地的文件系统缓存。这对于在 NFS 挂载上打开文件时非常有用，因为它允许跳过可能过时的本地缓存。 它对 I/O 性能有非常实际的影响，因此除非需要，否则不建议使用此标志。这不会将 fs.open() 或 fsPromises.open() 转换为同步的阻塞调用。 如果需要同步的操作，则应使用 fs.openSync() 之类的。
* 'w' - 打开文件用于写入。如果文件不存在则创建文件，如果文件已存在则截断文件。
* 'wx' - 与 'w' 相似，但如果路径已存在则失败。
* 'w+' - 打开文件用于读取和写入。如果文件不存在则创建文件，如果文件已存在则截断文件。
* 'wx+' - 与 'w+' 相似，但如果路径已存在则失败。

## 文件夹的操作

> 文件夹的操作都比较简单，直接上代码

### fs.mkdir 创建文件夹

```js
  fs.mkdir(resolve('mkdir'), function(err) {
    if (err) throw err
    console.log('创建目录成功')
  }
```

### fs.rmdir 删除文件夹

```js
fs.rmdir(dir, err => {
  if (err) throw err;
  console.log('文件夹删除成功');
});
```

### fs.readdir 读取文件夹

* 文件夹读取成功返回一个数组，返回文件夹下的所有子目录，并且按照字符串的排序规则排序，如果是空文件夹则返回空数组

```js
  fs.readdir(dir, (err, data) => {
    if (err) throw err
    if (data.length) {
      console.log('说明有子文件')
    }
  }
```

### fs.existsSync 判断文件路径

* fs.existsSync 接收一个参数，文件路径
* 如果路径存在，返回 true，不存在返回 false
* 该方法的异步写法已被废弃，只有同步写法

## 文件对象属性

* fs.stat() 和 fs.lstat()
* 这俩方法用俩查看一个文件或目录的信息，如文件的大小、创建时间、权限等信息
* 唯一区别是当查看符号链接文件的信息时，必须使用 fs.lstat()方法
* 接受两个参数，path 和 callback

```js {4}
const filePath = path.resolve('D:/');
fs.stat(filePath, (err, stats) => {
  if (err) throw err;
  console.log(stats);
});
```

* 此时我们可以在 stats 上看到文件的信息
  * **dev**: 文件或目录所在的设备 ID。该属性值在 UNIX 系统下有效；
  * **mode**: 文件或目录的权限标志，采用数值形式表示；
  * **nlink**: 文件或目录的的硬连接数量；
  * **uid**: 文件或目录的所有者的用户 ID。该属性值在 UNIX 系统下有效；
  * **gid**: 文件或目录的所有者的用户组 ID。该属性值在 UNIX 系统下有效；
  * **rdev**: 字符设备文件或块设备文件所在设备 ID。该属性值在 UNIX 系统下有效；\*\*
  * **ino**: 文件或目录的索引编号。该属性值仅在 UNIX 系统下有效；
  * **size**: 文件的字节数；
  * **atime**: 文件或目录的访问时间；
  * **mtime**: 文件或目录的最后修改时间；
  * **ctime**: 文件或目录状态的最后修改时间；
  * **birthtime**: 文件创建时间，文件创建时生成。在一些不提供文件 birthtime 的文件系统中，这个字段会使用 ctime 或 1970-01-01T00:00Z 来填充；
* states 上面有一些方法如下
  * **stats.isFile()**： 判断被查看对象是否是一个文件。如果是标准文件，返回 true。是目录、套接字、符号连接、或设备等返回 false。
  * **stats.isDirectory()**： 判断被查看对象是否是一个目录。如果是目录，返回 true。
  * **stats.isBlockDevice()**： 判断被查看对象是否是一个块设备文件。 如果是块设备，返回 true，大多数情况下类 UNIX 系统的块设备都位于/dev 目录下。
  * **stats.isCharacterDevice()**： 判断被查看对象是否是一个字符设备文件。如果是字符设备，返回 true。
  * **stats.isSymbolicLink()**： 判断被查看对象是否是一个符号链接文件。如果是符号连接，返回 true。该方法仅在 fs.lstat()方法的回调函数中有效。
  * **stats.isFIFO()**： 判断被查看对象是否是一个 FIFO 文件。如果是 FIFO，返回 true。FIFO 是 UNIX 中的一种特殊类型的命令管道。该方法仅在 LINUX 系统下有效。
  * **stats.isSocket()**： 判断被查看对象是否是一个 socket 文件。 如果是 UNIX 套接字，返回 true。该方法仅在 LINUX 系统下有效。
* 我们可能经常会用到的 stats.isFile() 和 stats.isDirectory()来判断该文件是文件夹还是文件
* 我们根据这些内容来做几个轮子，加深一下印象

## 轮子

### 批量创建文件

* 我们造俩轮子，来测试我们的猜想
* 指定一个存在的文件夹，为其批量创建 100 个文件
* 首先我们需要判断该文件夹存在，不存在则创建，存在则直接创建文件
* 判断有没有该文件夹的方法是没有的，我们可以直接创建，如果创建失败了，那么说明有文件夹，则直接创建文件，没有这个文件夹就创建成功了呗

```js
const fs = require('fs');
const path = require('path');
const resolve = dir => path.join(__dirname, dir);

// 判断是否有该文件夹

function isDir(dir) {
  console.log(dir);
  return new Promise(resolve => {
    fs.mkdir(dir, err => {
      if (err) {
        // 失败了说明文件夹创建过了
        return resolve(true);
      } else {
        return resolve(false);
      }
    });
  });
}

function betchCreateFile() {
  isDir(resolve('mkdir'))
    .then(result => {
      if (result) {
        for (let i = 0; i < 100; i++) {
          fs.writeFile(resolve(`mkdir/${i}.txt`), 'hello world', err => {
            if (err) throw err;
            console.log('文件 ' + i + ' 写入成功');
          });
        }
      } else {
        betchCreateFile();
      }
    })
    .catch(err => {
      console.log(err, '哪出错了？？');
    });
}

betchCreateFile();
```

### 批量删除当前文件夹下的文件

* 删除文件和删除文件夹是不一样的，如果文件夹有文件那么删除会失败
* 根据这个我们先判断一下有没有文件了，然后进行删除，先来个简单的，只考虑一层的删除

```js
const rm = dir => {
  // 文件夹读取返回一个数组，返回文件夹下的所有子目录，并且按照字符串的排序规则排序
  fs.readdir(dir, (err, data) => {
    if (err) throw err;
    if (data && data.length) {
      // 说明有文件
      data.forEach((item, idx) => {
        fs.unlinkSync(`${dir}/${item}`);
        console.log(`开始删除第${idx + 1}个文件：${item}`);
      });
      rm(dir);
    } else {
      fs.rmdir(dir, err => {
        if (err) throw err;
        console.log('文件夹删除成功');
      });
    }
  });
};
```

### 批量读取文件

* 读取文件，读取一个文件夹下面所有的文件，如果读取到文件夹下面还有文件那么递归这个方法继续打印我们的文件
* 这个时候我们就需要使用 fs.stat() 返回的 stats 中得 stats.isFile()和 stats.isDirectory()来区分是文件还是文件夹了

```js
const fs = require('fs');
const path = require('path');

const fileDisplay = filePath => {
  console.log(filePath);
  fs.readdir(filePath, (err, files) => {
    if (err) {
      console.warn('文件夹读取失败' + err);
    } else {
      // 遍历文件列表
      files.forEach(filename => {
        // 获取当前路径
        let filedir = path.join(filePath, filename);
        fs.stat(filedir, (err, stats) => {
          if (err) {
            console.warn('获取文件stat失败：' + err);
          } else {
            let isFile = stats.isFile();
            let isDir = stats.isDirectory();
            if (isFile) console.log('文件读取成功：' + filedir);
            if (isDir) fileDisplay(filedir);
          }
        });
      });
    }
  });
};

fileDisplay(path.join(__dirname, '..', '..', '..'));
```

### 批量删除所有文件

* 删除的，我们需要用同步的写法，全部同步的写法，异步写法可能会出问题
* 因为没有办法获取到什么时候删除成功了，成功删除了文件还是文件夹

```js
// 同步写法
const fs = require('fs');
const path = require('path');
const resolve = dir => path.join(__dirname, dir);

const rmdir = dir => {
  let files = [];
  // 判断该文件路径是否存在返回一个布尔值
  if (fs.existsSync(dir)) {
    // 先读取文件
    files = fs.readdirSync(dir);
    files.forEach(filename => {
      // 获取当前的绝对路径
      let curPath = path.join(dir, filename);
      // 获取该文件的信息，如果是文件夹，那么递归
      if (fs.statSync(curPath).isDirectory()) {
        rmdir(curPath);
      } else {
        // 如果是文件，那么删除
        fs.unlinkSync(curPath);
        console.log('文件 ' + curPath + ' 删除成功');
      }
    });
    // 删除完文件删除文件夹
    fs.rmdirSync(dir);
    console.log('文件夹 ' + dir + ' 删除成功');
  }
};

rmdir(resolve('../../test'));
```

* 异步写法，为了不报错，只能删除掉所有的子文件，可能我写法有问题，先贴出来，求指正

```js
const fs = require('fs');
const path = require('path');
const resolve = dir => path.join(__dirname, dir);

const rmdir = dir => {
  // 先读取文件
  fs.readdir(dir, (err, files) => {
    if (err) {
      console.warn('文件读取失败：' + err);
    } else {
      // 说明文件夹里有东西
      if (files.length) {
        // 判断是文件还是文件夹
        files.forEach(filename => {
          // 获取当前的绝对路径
          let positionPath = path.join(dir, filename);
          fs.stat(positionPath, (err, stats) => {
            if (err) {
              console.warn('获取文件信息失败：' + err);
            } else {
              let isDir = stats.isDirectory();
              let isFile = stats.isFile();
              if (isDir) {
                // 如果是文件夹则递归
                rmdir(positionPath);
              }
              if (isFile) {
                // 若是文件则删除文件
                fs.unlink(positionPath, err => {
                  if (err) {
                    console.warn('文件 ' + positionPath + ' 删除失败：' + err);
                  } else {
                    console.warn('文件 ' + positionPath + ' 删除成功');
                    rmdir(dir);
                  }
                });
                // fs.unlinkSync(positionPath)
              }
            }
          });
        });
      } else {
        // 说明是空文件夹
        fs.rmdir(dir, err => {
          if (err) {
            console.warn('文件夹 ' + dir + ' 删除失败：' + err);
          } else {
            console.log('文件夹 ' + dir + ' 删除成功');
          }
        });
      }
    }
  });
};

rmdir(resolve('../../test'));
```

---

---
url: /docs/03.工具/Git 相关/git-1.md
---

## 前言

Git 是目前广泛使用的分布式版本控制系统，在日常开发中经常会用到。
这篇文章记录了一些 Git 的基础知识和常用操作，希望能对大家有所帮助

## 文章导览

## Git 简介

Git 是一个 **分布式版本控制系统**，最初由 Linux 之父 Linus Torvalds 编写。它可以帮助我们跟踪代码的修改历史、多人协作开发，并在出问题时迅速回滚。

> ✅ **Git vs SVN**：Git 是分布式的，每个开发者都有完整历史记录；SVN 是集中式的，依赖服务器。
> git 与区块链一样都是去中心化的思想，理论上操作不可逆。每个人都有自己的操作节点

## Git 基础概念

* **工作区（Working Directory）**：电脑上看到的文件夹。
* **暂存区（Staging Area）**：准备提交的文件列表。
* **本地仓库（Local Repository）**：本机的 `.git` 目录。
* **远程仓库（Remote Repository）**：比如 GitHub、GitLab 上托管的项目。

```
工作区 → 暂存区 → 本地仓库 → 远程仓库
```

* **HEAD**：当前指向的提交或分支。
* **origin**：默认远程仓库别名。

## Git 安装与配置

### 安装方式

* Windows：访问 <https://git-scm.com> 下载并安装
* macOS：使用 Homebrew 安装：`brew install git`

### 初始化配置

```bash
git config --global user.name "你的名字"
git config --global user.email "你的邮箱"
git config --global init.defaultBranch main
```

`--global` 参数表示全局配置，不添加 `--global` 表示当前目录配置(存在 .git 的目录)

### 配置进阶

Git 的配置远不止用户名和邮箱，以下是一些实用的配置：

```bash
# 配置编辑器（推荐使用 VS Code）
git config --global core.editor "code --wait"

# 配置换行符处理（重要！避免跨平台问题）
git config --global core.autocrlf true    # Windows 系统
git config --global core.autocrlf input   # Mac/Linux 系统

# 配置推送策略
git config --global push.default simple

# 配置颜色输出
git config --global color.ui auto

# 查看所有配置
git config --list
```

## Git 常用命令

在介绍命令之前，有个注意事项要提前声明下: `使用 Git 一定要有去中心化的思想，一旦 push 到远程仓库后，想要撤销修改就需要考虑到其他用户，不可轻易使用 git push -f，使用该命令前一定要与其他同事确认，并有对应的，否则会丢代码!`

### 仓库操作

```bash
git init               # 初始化本地仓库
git clone <url>        # 克隆远程仓库
```

### 代码提交

```bash
git add .              # 添加所有更改
git commit -m "说明"   # 提交更改
git status             # 查看状态
git diff               # 查看改动
```

#### add

* `git add` 添加要提交的文件，一般常用 `git add .`

```shell
# 添加单个文件
git add <filename>

# 添加多个文件
git add <file1> <file2> <file3>

# 添加所有文件（包括新增和修改）如果文件已经在 .gitignore 文件中了，则不会被添加
git add .
# 或者
git add --all
# 或者
git add -A

# 添加某个目录下的内容
git add <directory_name/>

# 添加被忽略的文件 (.gitignore 中的文件)
git add -f <filename>

# 查看哪些文件会被添加 (模拟执行 git add .，不会真正添加任何文件)
git add -n .
```

* 已经 add 的文件，可以使用 `git restore --staged <file>` 命令取消添加，该命令可以取消对文件的添加，但是不会删除文件，也不会删除文件修改的内容。
* 如果本地某个修改不想要了，要恢复到修改之前，可以使用 `git checkout <file>`，都不要可以使用 `git checkout .` (这个操作不会恢复已经 add 的文件哦)
* `.` 和 `-A` 的区别在于: `-A` 会添加所有变化 `.` 只会添加添加当前目录及其子目录的所有变化，如果是上级目录的修改是不会被添加的

#### commit

* 提交信息规范，建议使用 `git commit -m "feat: 新功能"` 或 `git commit -m "fix: 修复 bug"`，具体有以下几种:

```txt
{
  "feat":     "特性:     ✨  新增功能",
  "fix":      "修复:     🐛  修复缺陷",
  "docs":     "文档:     📝  文档变更(更新README文件，或者注释)",
  "style":    "格式:     🌈  代码格式（空格、格式化、缺失的分号等）",
  "refactor": "重构:     🔄  代码重构（不修复错误也不添加特性的代码更改）",
  "perf":     "性能:     🚀  性能优化",
  "test":     "测试:     🧪  添加疏漏测试或已有测试改动",
  "build":    "构建:     📦️  构建流程、外部依赖变更（如升级 npm 包、修改 vite 配置等）",
  "ci":       "集成:     ⚙️   修改 CI 配置、脚本",
  "revert":   "回退:     ↩️   回滚 commit",
  "chore":    "其他:     🛠️   对构建过程或辅助工具和库的更改（不影响源文件、测试用例）",
  "wip":      "开发中:   🚧  开发阶段临时提交"
}
```

平时开发中常用的有: `feat`、`fix`、`style`、`revert`、`wip`

* 修改提交信息：

代码提交后，想要修改下提交信息，可以使用 `git commit --amend`，会弹出一个 vi 编辑器，将修改后的提交信息保存并提交。
如果已经 push 到远程仓库，想要修改的话，也是一样，但是需要 `git push --force` 强制推送到远程仓库(⚠️ 慎用)。

#### status

git status 可以查看当前仓库状态，会显示当前分支、未暂存的文件、暂存的文件、当前分支的提交记录。当我们不知所措的时候使用该命令也会给我们相应的提示

#### diff

git diff 可以查看当前仓库的改动，会显示当前分支的提交记录和暂存区的改动。如果已经 add 过则需要 `git diff <hash>` 来显示改动。

### 临时暂存

* 在开发新的需求的过程中，会经常遇到已经提测的需求有 bug 要优先处理，但是本地开发一半的代码，又不想提交到远程仓库，此时就会用到 `git stash` 命令
* 这个命令会将当前暂存区的改动暂存到 stash 栈中，然后本地暂存区干净了，就可以切换到对应的分支去修改 bug，修复完之后，再回到原来的分支使用
  stash 恢复刚才暂存的文件
* 使用方式如下:

```shell
# 把工作区和暂存区的改动放到 stash 栈中
git stash push -m "说明"
# 或者（已弃用，不推荐使用）
git stash save "说明"

# 恢复 stash 的栈顶的最近一次 stash
git stash pop

# 查看 stash 栈，会返回类似于 stash@{0}: On main: 说明 的一个列表
git stash list

# 指定恢复对应的 stash，比如恢复 stash@{0} 的改动
git stash apply stash@{0}
```

### 择优挑选

`git cherry-pick` 是 Git 中一个非常实用的命令，用于将某个分支上的特定提交（commit）复制到当前所在的分支上。它允许你有选择性地将某些提交引入到不同的分支中，而不需要合并整个分支的所有改动。

语法: `git cherry-pick <commit_id>`，也可以拣选多个提交: `git cherry-pick <commit_id1> <commit_id2>`

📌 使用场景:

* 在稳定版本中加入某个功能或修复 bug ：例如，你想在 v2.0 稳定版本分支中加入 v3.0 开发分支中的某次 bug 修复提交，就可以使用 cherry-pick 来提取这个 commit 。
* 避免合并整个分支 ：当你只想合入其他分支的某些改动，而不是全部历史时，非常适合使用此命令 。
* 多分支开发中同步特定提交 ：比如你在 feature 分支做了一些修改，想将其中一部分提交同步到 main 分支 。
* 有一点要注意: cherry-pick 会生成新的提交对象，虽然内容相同，但提交哈希值不同，当我们把对应分支合并进来的时候，就会有两个提交信息是一样的，虽然他们的哈希值不同

⚠️ 冲突处理

如果在 cherry-pick 过程中发生冲突，Git 会暂停操作并提示你解决冲突。

```txt
1. 修改冲突文件，手动解决冲突
2. 运行 git add <file> 添加修改后的文件
3. 继续 cherry-pick: git cherry-pick --continue
4. 如果你不想继续，可以中止：`git cherry-pick --abort`
```

### 分支管理

```bash
git branch             # 查看本地分支
git branch dev         # 创建 dev 分支
git checkout -b dev    # 创建并切换到 dev 分支（传统方式）
git switch -c dev      # 创建并切换到 dev 分支（Git 2.23+ 推荐方式，更安全）
git branch -d dev      # 删除 dev 分支
git branch -D dev      # 强制删除 dev 分支
git merge dev          # 合并 dev 分支到当前分支
git push origin --delete dev # 删除远程分支
```

#### 合并策略

Git 提供了多种合并策略，不同场景下选择合适的策略很重要：

```bash
# 快进合并（默认）- 如果可能，直接移动指针
git merge feature-branch

# 非快进合并（保留分支历史）- 始终创建合并提交
git merge --no-ff feature-branch

# 压缩合并 - 将多个提交压缩为一个
git merge --squash feature-branch
```

**使用建议**：

* `--no-ff`：适合功能分支合并，保留完整的分支历史
* `--squash`：适合将实验性的多个提交整理为一个干净的提交

#### 冲突解决

合并分支时经常遇到冲突，以下是完整的解决流程：

```bash
# 合并时出现冲突
git merge feature-branch
# Auto-merging file.txt
# CONFLICT (content): Merge conflict in file.txt
# Automatic merge failed; fix conflicts and then commit the result.

# 查看冲突状态
git status
```

**冲突标记格式**：

```bash
<<<<<<< HEAD
当前分支的内容
=======
要合并分支的内容
>>>>>>> feature-branch
```

**解决步骤**：

1. 手动编辑冲突文件，删除冲突标记，保留需要的内容
2. 添加解决后的文件：`git add <文件名>`
3. 提交合并：`git commit`（会自动生成合并提交信息）

```bash
# 解决冲突的完整流程
git add .                 # 标记冲突已解决
git commit               # 完成合并提交

# 如果不想继续合并，可以中止
git merge --abort
```

### 远程操作

```bash
git remote add origin <url>  # 添加远程仓库
git push -u origin main      # 推送到远程并设置默认分支
git pull origin main         # 拉取远程更新
git fetch origin             # 获取远程更新但不合并
```

### 标签管理

每次上线、发布、打包，都需要知道："这次发布的是哪一版？"，`git tag v1.0.0 -m "正式发布 1.0.0 版本"`，也可以方便回滚，一般是上线是使用的

标签跟分支的操作基本上是一样的

```shell
# 查看所有标签
git  tag

# 查看标签信息
git show <tagname>

# 查看符合条件的标签（例如以 v1. 开头）
git tag -l "v1.*"

# 创建标签

# 轻量标签，给某个提交打个书签，没有额外信息
git tag <tagname>

# 默认是个当前HEAD 打标签，也可以指定提交：
git tag v1.0.0 <commit-hash>

# 注释标签，带作者、日期、说明信息
git tag -a <tagname> -m "Release version 1.0.0"

# 也可以指定提交
git tag -a v1.0.0 <commit-hash> -m "Release note"

# 删除标签
git tag -d <tagname>

# 删除远程标签
git push origin --delete <tagname>
```

### .gitignore 规则详解

`.gitignore` 文件用于告诉 Git 哪些文件或目录应该被忽略，不纳入版本控制。

#### 语法规则

```bash
# 基本规则
*.log          # 忽略所有 .log 文件
!debug.log     # 但不忽略 debug.log（感叹号表示例外）
/build         # 只忽略根目录的 build 文件夹
build/         # 忽略任意位置的 build 文件夹
doc/*.txt      # 忽略 doc 目录下的 .txt 文件（不递归）
doc/**/*.pdf   # 忽略 doc 及其子目录下的 .pdf 文件（递归）

# 常用示例
node_modules/  # Node.js 依赖
dist/          # 构建输出目录
.env           # 环境变量文件
.env.local     # 本地环境变量
*.log          # 日志文件
*.pyc          # Python 编译文件
__pycache__/   # Python 缓存目录
.DS_Store      # macOS 系统文件
Thumbs.db      # Windows 系统文件
.vscode/       # VS Code 配置（可选）
.idea/         # JetBrains IDE 配置（可选）
```

#### 实用技巧

```bash
# 查看某个文件是否被忽略，以及被哪条规则忽略
git check-ignore -v <filename>

# 查看所有被忽略的文件
git ls-files --others --ignored --exclude-standard

# 强制添加被忽略的文件
git add -f <filename>
```

**⚠️ 注意**：`.gitignore` 只对未被跟踪的文件有效。如果文件已经被提交过，需要先从跟踪中移除：

```bash
# 从跟踪中移除但保留本地文件
git rm --cached <filename>
# 提交这个移除操作
git commit -m "untrack file"
```

## 回退提交

### revert

revert 是用于撤销某次提交（commit）的命令。它通过创建一个`新的提交`来反向应用 指定提交的更改，从而实现撤销效果，而不是直接删除或修改历史提交。

语法: `git revert <commit_id>`，`<commit_id>` 你想撤销的提交的哈希值（可以是 HEAD、HEAD~1 等简写方式）。

git revert 会基于你要撤销的提交生成一个新的提交 ，这个新提交的内容正好抵消原提交所做的更改。

```shell
# 撤销最近的一次提交
git revert HEAD

# 撤销指定提交的提交
git revert <commit_id>
```

revert 有几个选项:

1. `--no-commit / -n`: 只应用 revert 改动到暂存区，不自动创建提交（适合手动编辑后再提交）
2. `-m`: 用于合并提交，需指定父编号，如 `-m 1` 表示选择第一个父提交
3. `-e`: 打开编辑器修改提交信息

注意: revert 之后，在次 merge 这个提交可能会失效或者冲突

这是因为:

* 当你使用 git revert 撤销一个提交后，Git 并不会删除原始提交，而是创建了一个新的提交 来抵消原始更改。
* -当你后续尝试将原始提交再次合并进来时（比如从另一个分支合并），Git 会认为这个提交已经被处理过了（因为它的更改已经被 revert
  提交抵消），于是可能会跳过该提交的更改或者提示冲突：already reverted
* Git 会认为这些更改不需要重复应用。
* 可以使用 cherry-pick 或者`再 revert 那个 revert 提交`来恢复原来的更改
* 或者删除掉原来的 revert 提交(rebase -i)

### reset

reset 是 Git 中一个非常强大且常用的命令，用于撤销本地的提交、暂存区或工作区更改，但是也是一个特别危险的命令。

使用场景:

* 撤销本地的提交: 在本地有很多临时提交，想要撤销
* 本地修改完全不想要了，要跟远端同步
* 重置分支

语法: `git reset [--soft | --mixed | --hard] <commit_id>`

| 参数    | 效果       | 使用场景               |
|---------|----------|--------------------|
| --soft  | 只移动HEAD | 想重新编辑提交信息     |
| --mixed | 重置暂存区 | 想重新选择要提交的文件 |
| --hard  | 重置所有   | 完全放弃本地修改       |

\--soft 和 --mixed 的区别：

* `--soft`：暂存区保持不变，再次提交不需要 add
* `--mixed`：暂存区被清空，再次提交需要重新 add

\--hard 是很危险的参数，一旦 hard reset 很难恢复

### reflog（操作历史记录）

Git reflog 是一个强大的数据恢复工具，记录了本地仓库中 HEAD 和分支引用的变化历史。即使提交被删除了，通过 reflog 也能找回。

希望大家这辈子都不需要用到这个命令。

```shell
# 查看所有操作历史
git reflog

# 查看指定分支的操作历史
git reflog show <branch-name>

# 恢复到指定的历史状态
git reset --hard HEAD@{2}

# 恢复被误删的分支
git checkout -b recovered-branch HEAD@{3}

# 查看某个时间点的状态
git reflog --since="1 hour ago"
```

**使用场景**：

* 误删提交后的恢复：`git reset --hard HEAD@{1}`
* 误删分支后的恢复：先用 reflog 找到分支最后的提交，再重建分支
* rebase 出错后的恢复：回到 rebase 之前的状态

**注意**：reflog 只记录本地操作，不会同步到远程仓库。默认保留 90 天。

### rebase

rebase 是 Git 提供的一种交互式变基方式，让你可以对一系列提交进行修改、重排、合并、删除、编辑等操作。

通常用于： 清理历史（整理提交）、 合并多个提交为一个、修改历史提交信息、删除错误提交、重排提交顺序

#### 介绍

下面是 `rebase -i` 的介绍:

执行 `git rebase -i ae6c55b5`，commitId 是你希望从哪个提交之后开始变基（不包括该提交本身）。

此时会打开以下的界面，是 vi 编辑器，修改内容使用 vi 的语法既可

```shell
# pick ae6c55b5 登录页面开发    这个是不包含的
pick 123abcd 修复登录按钮
pick 456efgh 添加样式优化
pick 789ijkl 调整接口请求方式

# Commands:
# p，pick <commit> = use commit  使用该提交
# r，reword <commit> = use commit，but edit the commit message  使用该提交，但修改提交信息
# e，edit <commit> = use commit，but stop for amending  使用该提交，但会暂停以便进行修改
# s，squash <commit> = use commit，squashing into prior commit  使用该提交，将其压缩进前一个提交
# f，fixup <commit> = like "squash"，but discard this commit's message  类似 "squash"，但会丢弃该提交的信息
# x，exec <command> = run command (the rest of the line) using shell  使用 shell 执行该行后面的命令
# d，drop <commit> = remove commit  删除该提交
# l，label <label> = label current HEAD at <label>  给当前 HEAD 打上 <label> 标签
# t，reset <label> = reset HEAD to <label>  将 HEAD 重置为 <label>
# m，merge [-C <commit>] <label> = create a merge commit  创建一个合并提交
```

每一行表示一个提交。

可以把每行开头的 pick 替换成其他命令，如：

* reword：修改提交信息
* edit：暂停以修改代码或提交
* squash：把当前提交合并到上一个
* fixup：像 squash，但会丢掉当前提交的信息
* drop：删除这个提交

#### 示例

1. 把后两个提交合并到第一个：

```shell
pick 123abcd 修复登录按钮
squash 456efgh 添加样式优化
squash 789ijkl 调整接口请求方式
```

保存后，Git 会让你编辑新的提交信息，可以保留其中某些内容或全部合并为一句话

2. 修改某个提交信息

```shell
pick 123abcd 修复登录按钮
reword 456efgh 添加样式优化
pick 789ijkl 调整接口请求方式
```

保存后 Git 会打开编辑器，允许你修改第二条提交的信息。

3. 删除某个提交

```shell
pick 123abcd 修复登录按钮
drop 456efgh 添加样式优化
pick 789ijkl 调整接口请求方式
```

456efgh 提交将被删除

* rebase 会重写历史，只建议对本地分支使用，不要对已推送到共享仓库的提交做 rebase。
* 操作过程中可能会出现冲突，Git 会提示你解决冲突并继续变基。
* 解决冲突后执行：

```shell
git add .
git rebase --continue
```

| 命令   | 作用                        |
|--------|---------------------------|
| pick   | 使用该提交                  |
| reword | 修改提交信息                |
| edit   | 修改提交内容（中断）          |
| squash | 合并为一个提交，保留所有信息 |
| fixup  | 合并为一个提交，丢弃当前信息 |
| drop   | 删除该提交                  |

## 总结

恭喜你！🎉 完成了第一篇的学习，现在你已经掌握了 Git 的核心技能：

**基础概念**：理解了工作区、暂存区、本地仓库、远程仓库的关系\
**日常操作**：熟练使用 add、commit、push、pull 等常用命令\
**分支管理**：掌握分支创建、切换、合并和冲突解决\
**版本控制**：学会使用 revert、reset、rebase 进行版本回退\
**团队协作**：了解不同的分支策略和工作流程

这些知识已经足够你在大部分项目中愉快地使用 Git 了！💪

## 下期预告

第二篇我们将深入探讨 Git 的高级特性和实战技巧：

🔥 **进阶内容预览**：

* **Git 内部原理**：深入了解 .git 文件夹的秘密
* **协作最佳实践**：分支命名规范、提交信息模板、Code Review 指南
* **协作进阶**：大型团队的 Git 工作流和最佳实践
* **性能优化与维护**：仓库体检、垃圾回收、GPG 签名等企业级维护
* **统计分析**：贡献统计、项目分析、开发效率评估
* **故障排查与恢复**：问题诊断技巧、紧急恢复场景、数据找回方法

***

**💡 学以致用**：建议你现在就创建一个练习项目，把第一篇学到的命令都实际操作一遍。实践是最好的老师！

**🚀 继续关注**：第二篇即将发布，我们将一起探索 Git 的更多奥秘，让你从 Git 用户进阶为 Git 专家！

*"路虽远行则将至，事虽难做则必成"* —— 加油，Git 高手之路等着你！⭐

---

---
url: /docs/03.工具/Git 相关/git-2.md
---

## 前言

在[第一篇](git-1.md)中，我们掌握了 Git 的基础操作和核心概念。现在让我们继续深入，探索 Git 的高级特性和实战技巧。

## 源的管理

```shell
# 查看源仓库信息
git remote -v

# 修改源仓库信息
git remote set-url <origin_name> <url>

# 添加源仓库
git remote add <origin_name> <url>

# 删除源仓库
git remote rm <origin_name>

# 推送代码到指定的源仓库
git push <origin_name> <branch>
```

默认的源仓库名称是 origin，一套代码可能需要推送到多个 git 仓库，此时就会用到这个

## .git 文件夹

.git 文件夹是 Git 仓库的核心，是 Git 用来跟踪版本历史、管理分支、记录配置等所有信息的隐藏目录。
当你在一个项目中执行 `git init`，或者克隆一个仓库时，`.git` 文件夹就会自动生成。

1. `HEAD`: 指向当前分支的引用。 `ref: refs/heads/main`
2. `config`: Git 仓库的本地配置（例如远程地址、用户信息、自动换行等）。相当于项目级 .gitconfig。
3. `description`: 仓库的描述信息。
4. `hooks/`: 钩子脚本目录，可以设置在 Git 操作前后执行自定义命令（如自动检查代码、发邮件、部署等）。
5. `info/`: 存放额外信息，比如 .git/info/exclude 是用于忽略文件的（作用类似 .gitignore，但仅当前仓库有效）。
6. `objects/`: Git 的对象数据库，所有的提交、树（目录结构）、文件内容（blob）等都以哈希对象形式存储在这里。
7. `refs/`: 引用数据库，保存分支、标签、HEAD 等引用。
8. `logs/`: 存放提交日志，用于记录提交历史。可用于 git reflog 查看历史操作。
9. `index`: 暂存区，保存当前工作目录的修改，等待下一次提交。
10. `COMMIT_EDITMSG`: 保存最近一次提交时的提交信息临时文本（用于提交时编辑）。
11. `packed-refs`: 当引用（分支、标签）很多时，Git 会将它们打包存储到此文件中，优化性能。

🧠 小贴士

1. .git 文件夹不应该被修改，除非你非常了解 Git 内部结构。
2. .git 丢失后，该项目就不再是 Git 仓库了。
3. 在 Mac 和 Linux 中 .git 开头的文件属于隐藏文件。可使用 ls -a 查看。

## Git hooks

git hooks 是 .git 文件夹的一个特殊目录，用于存储 Git 仓库的钩子脚本。默认会有很多 .sample 结尾的文件，这些都是示例文件，当把 .sample 后缀去掉后，Git 就会自动执行该脚本 。

### 让钩子生效

我们可以简单写两个钩子脚本，来尝试一下，基本步骤如下

1. 在项目的根目录下创建个对应的脚本，在提交的时候打印一些信息，在 commit 的时候校验提交内容是否符合 `conventional commit` 的规范

```txt
your-project/
├── scripts/
│   ├── pre-commit-message.sh
│   └── validate-commit-msg.sh
├── .git/
│   └── hooks/
│       ├── pre-commit
│       └── commit-msg
```

2. 脚本内容

`pre-commit-message.sh` 的内容

```shell
#!/bin/sh
echo "🚀 继续加油！每一次 commit 都是在构筑未来。"
echo "🔍 请确保你已经保存了所有改动，并且 commit message 清晰明确。"
```

3. 增加执行权限

```shell
chmod +x scripts/pre-commit-message.sh
```

4. 配置钩子脚本

* 复制 pre-commit.sample 文件到 .git/hooks 目录下，并重命名为 pre-commit
* 在中间插入以下脚本内容

```shell
# 先切换到 git 仓库根目录
cd "$(git rev-parse --show-toplevel)"
# 执行 pre-commit 消息脚本
sh scripts/pre-commit-message.sh
```

此时执行 git commit 命令时，就会先执行 pre-commit 脚本，打印出我们所编写内容

### 更优雅的方式

我们应该遵循 `.git 文件夹不应该被修改`的原则，直接在 .git 文件夹下创建脚本，在中间修改了对应代码，还是有点不合适的，我们可以修改 git hooks 的路径，让他执行我们自己的自定的脚本

```shell
# 新建个 .githooks 文件夹
mkdir .githooks

# 指定新的hooks 路径
git config core.hooksPath .githooks

# 创建 pre-commit 文件
touch .githooks/pre-commit

# 赋予可执行权限
chmod +x .githooks/pre-commit

# 要恢复默认的 hooks 路径，可以执行 git config --unset core.hooksPath
```

`.githooks/pre-commit` 的内容

```shell
#!/bin/sh

# 切换到项目根目录
cd "$(git rev-parse --show-toplevel)"

# 执行 pre-commit 消息脚本
sh scripts/pre-commit-message.sh 
```

此时效果跟刚才一样直接修改 `.git/hooks/pre-commit` 文件效果一样

### commit-msg

`commit-msg` 的作用是检查提交信息是否符合规范的钩子，比如是否符合 `conventional commit` 的规范。

他的写法需要获取到提交的内容，然后验证是否符合规范，需要先获取到提交内容的地方，上面我们有提到 `.git/COMMIT_EDITMSG`
里面保存最近一次提交时的提交信息临时文本，我们可以从这里拿到

但是考虑到不同版本的 git(企业版或者定制版) 以及防范未来的变化，并且 git 提供了对应的参数接口，我们还是按照推荐的写法来编写

并且 git 提供的没有直接获取提交临时路径的变量，所有我们可以在执行脚本的时候传递过来

脚本内容如下:

scripts/validate-commit-msg.sh 脚本如下:

```shell
#!/bin/sh
commit_msg_file=$1
commit_msg=$(cat "$commit_msg_file")

# 支持的提交前缀
valid_prefixes="feat|fix|docs|style|refactor|test|chore"

if echo "$commit_msg" | grep -qE "^($valid_prefixes)(\(.+\))?: .+"; then
  echo "✅ 提交信息格式通过校验"
  exit 0
else
  echo "❌ 提交信息格式不规范！请使用以下格式之一："
  echo "   feat: xxx"
  echo "   fix: xxx"
  echo "   docs: xxx"
  echo "   chore(scope): xxx"
  echo "👉 当前提交信息为：$commit_msg"
  exit 1
fi
```

.githooks/commit-msg\` 的内容如下:

```shell
#!/bin/sh

# 切换到项目根目录
cd "$(git rev-parse --show-toplevel)"

# 执行 commit-msg 验证脚本，传递 commit message 文件路径
sh scripts/validate-commit-msg.sh "$1"
```

别忘了给这两个文件添加执行权限哦

### husky

如果你是一个前端同学，我们这种写法好熟悉，好像在哪见过，对没错 就是 husky，新版的 husky 就是使用了这种方式来处理 钩子的，具体配置方法之前文章有讲过，可以参考我当时那篇关于 [eslint 工作流](https://chengyuming.cn/views/FE/lint.html#husky)

其他语言也有类似的工具，比如 Python 有 [pre-commit](https://pre-commit.com/)  ，Rust 有 [cargo-watch](https://github.com/rhysd/cargo-husky)，Java 有 Maven/Gradle 插件

当然还有个通用的: [Lefthook](https://github.com/evilmartians/lefthook) 支持任何项目

## 协作最佳实践

良好的 Git 协作习惯能大大提高团队开发效率，避免很多不必要的问题。

### Git Flow（经典流程）

Git Flow 适合中大型项目或需要严格发布控制的团队。

* **主分支**：`main` / `master`，只用于正式发布版本
* **集成分支**：`develop`，日常开发合并到这里
* **功能分支**：`feature/*`，从 develop 拉出
* **修复分支**：`hotfix/*`，紧急 Bug 修复分支
* **发布分支**：`release/*`，发布准备分支

示例流程:

1. 从 develop 创建 feature/login
2. 完成后合并回 develop，进行测试
3. 准备发布时从 develop 创建 release/v1.0
4. 发布完成后合并到 master 和 develop
5. 紧急修复 bug 使用 hotfix 分支

当然这是简单的一个流程，如果涉及到多需求多团队并行开发的情况下，需要考虑更多的流程和策略，以下是个示例

1. 从 master 创建 feature/login (保证代码与生产环境是最新的，可以随时上线)
2. 开发完成后合并回 develop，进行测试
3. 遇到 bug，在 feature/login 进行修改，修复完成后合并到 develop，进行测试
4. 准备发布时从 feature/login 创建 release/v1.0
5. 发布完成后合并到 master，也可以直接把 feature/login 合并到 master
6. 在 develop 分支随时同步 master 代码
7. 在生产遇到 bug ，基于 master 切 hotfix 分支进行修复

当然如果中间有 UAT 或者 pre 环境的话可以根据具体情况调整策略

### 其他常见分支策略

除了 Git Flow，还有其他适合不同团队的分支策略：

#### GitHub Flow（简化流程）

适合持续部署的团队，流程更简单：

1. 从 `main` 创建功能分支
2. 开发完成后发起 Pull Request
3. 代码审查通过后合并到 `main`
4. 自动部署到生产环境

**优点**：流程简单，适合小团队
**缺点**：缺乏发布控制，适合持续部署的项目

#### GitLab Flow（环境分支）

结合环境分支的流程：

* `main`：开发主分支
* `pre-production`：预生产环境分支
* `production`：生产环境分支

**流程**：开发 → 测试环境 → 预生产环境 → 生产环境

**优点**：环境隔离清晰，发布可控
**缺点**：分支较多，管理复杂

#### 选择建议

* **小团队、快速迭代**：GitHub Flow
* **中大型团队、版本发布**：Git Flow
* **多环境部署**：GitLab Flow
* **企业级项目**：根据具体需求定制化流程

### 分支命名规范

统一的分支命名规范让团队协作更顺畅：

推荐这套规范：

* **主分支**：`main` / `master`，只用于正式发布版本
* **集成分支**：`develop`，日常开发合并到这里
* **功能分支**：`feature/*`，从 develop 拉出
* **修复分支**：`hotfix/*`，紧急 Bug 修复分支
* **发布分支**：`release/*`，发布准备分支

### 提交信息模板

可以为项目设置提交信息模板：

```bash
# 创建提交模板文件
echo "
# <类型>: <简短描述>
# 
# <详细描述>
# 
# <相关问题编号>
#
# 类型说明:
# feat: 新功能
# fix: 修复bug
# docs: 文档更新
# style: 代码格式调整
# refactor: 代码重构
# test: 测试相关
# chore: 构建/工具链相关
" > .gitmessage

# 配置模板
git config commit.template .gitmessage
```

### Code Review 最佳实践

* **小而频繁的提交**：便于审查和理解
* **清晰的提交信息**：说明改动的原因和内容
* **自测后再提交**：确保代码能正常运行
* **及时响应反馈**：积极参与代码讨论

### 团队协作流程建议

1. **拉取最新代码**：开始工作前先 `git pull`
2. **创建功能分支**：从最新的主分支创建
3. **频繁提交**：完成一个小功能就提交一次
4. **推送和PR**：功能完成后推送并创建Pull Request
5. **代码审查**：等待团队成员审查
6. **合并主分支**：审查通过后合并

## 性能优化与维护

随着项目发展，Git 仓库可能会变得臃肿，定期维护很有必要。

### 性能优化命令

```bash
# 垃圾回收和仓库优化
git gc --aggressive

# 清理无用的对象
git prune

# 查看仓库大小统计
git count-objects -vH

# 清理远程分支引用
git remote prune origin

# 压缩仓库（更激进的优化）
git repack -ad
```

### 仓库体检

```bash
# 检查仓库完整性
git fsck --full

# 查看哪些文件占用空间最大
git rev-list --objects --all | \
git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' | \
sed -n 's/^blob //p' | \
sort --numeric-sort --key=2 | \
tail -n 10

# 找出历史中的大文件
git filter-branch --tree-filter 'rm -rf path/to/large/files' HEAD
```

**⚠️ 注意**：`git filter-branch` 会重写历史，使用前请备份！

### GPG 签名

为了确保提交的安全性，可以使用 GPG 签名：

```bash
# 生成 GPG 密钥（如果没有的话）
gpg --gen-key

# 查看 GPG 密钥
gpg --list-keys

# 配置 Git 使用 GPG 签名
git config --global user.signingkey <key-id>
git config --global commit.gpgsign true

# 手动签名提交
git commit -S -m "signed commit"

# 验证签名
git log --show-signature
```

## 统计分析

Git 提供了丰富的统计功能，帮助了解项目开发情况。

### 贡献统计

```bash
# 查看贡献者统计
git shortlog -sn

# 查看某个作者的提交
git log --author="张三" --oneline

# 统计指定时间段的提交
git log --since="2023-01-01" --until="2023-12-31" --pretty=format:"%h %an %ad %s" --date=short

# 统计各个作者的代码行数变化
git log --pretty=format:"%an" --numstat | awk '
{
  if (NF == 1) {
    author = $1
  } else if (NF == 3) {
    add[author] += $1
    del[author] += $2
  }
}
END {
  for (a in add) {
    printf "%s: +%d -%d\n", a, add[a], del[a]
  }
}'

# 统计指定时间段内的代码行数变化
git log --since="2025-01-01" --until="2025-12-31" --pretty=format:"%an" --numstat | awk '
{
  if (NF == 1) {
    author = $1
  } else if (NF == 3) {
    add[author] += $1
    del[author] += $2
  }
}
END {
  for (a in add) {
    printf "%s: +%d -%d\n", a, add[a], del[a]
  }
}'
```

### 项目分析

```bash
# 查看文件修改频率
git log --name-only --pretty=format: | sort | uniq -c | sort -rg | head -10

# 查看最活跃的文件
git log --format=format: --name-only | grep -v '^$' | sort | uniq -c | sort -rg | head -10

# 统计不同类型文件的提交次数
git log --name-only --pretty=format: | grep -E '\.(js|py|java|go)$' | sort | uniq -c | sort -rg

# 查看项目的生命周期
git log --reverse --format="%ai %s" | head -1  # 第一次提交
git log --format="%ai %s" | head -1            # 最近提交
```

这些统计信息对项目管理、代码审查和团队协作都很有帮助。

## 故障排查与恢复

在使用 Git 的过程中，难免会遇到各种问题。掌握一些排查和恢复技巧很重要。

### 常见问题排查

```bash
# 检查仓库完整性
git fsck --full

# 检查远程仓库连接状态
git remote show origin

# 查看当前状态（脚本友好格式）
git status --porcelain

# 查看配置问题
git config --list --show-origin

# 检查忽略文件规则
git check-ignore -v <filename>
```

### 紧急恢复场景

**场景1：误删重要文件**

```bash
# 如果文件还没有被提交，可以从暂存区恢复
git checkout HEAD -- <filename>

# 如果已经提交但后来被删除，从历史恢复
git log --follow -- <filename>  # 找到文件的历史
git checkout <commit-hash> -- <filename>  # 恢复特定版本
```

**场景2：提交到错误分支**

```bash
# 查看最近的提交
git log --oneline -5

# 切换到正确的分支
git checkout correct-branch

# 将提交从错误分支复制过来
git cherry-pick <commit-hash>

# 回到错误分支删除那个提交
git checkout wrong-branch
git reset --hard HEAD~1
```

**场景3：合并出现问题**

```bash
# 如果合并过程中想要中止
git merge --abort

# 如果合并已完成但有问题
git reset --hard HEAD~1  # 回到合并前
# 或者
git revert -m 1 HEAD      # 创建反向提交
```

**场景4：rebase 搞砸了**

```bash
# 查看 rebase 前的状态
git reflog

# 回到 rebase 之前
git reset --hard HEAD@{n}  # n 是 reflog 中的序号
```

### 数据恢复技巧

```bash
# 找回"丢失"的提交
git reflog --all | grep <commit-partial-hash>

# 恢复已删除的分支
git reflog | grep <branch-name>
git checkout -b <branch-name> <commit-hash>

# 找回被误删的 stash
git fsck --unreachable | grep commit | cut -d' ' -f3 | xargs git log --merges --no-walk --grep=WIP
```

## 小技巧

记录一些，上面不曾提到过得小技巧

* 开发过程中， 可以使用图形界面工具（Sourcetree），来 diff 要提交的内容是否为自己要提交，以防止一些不想提交的东西提交进去。
* 刚初始化的项目，想要撤销第一次提交，推荐使用：`git reset --soft HEAD~1`
* 远端删除的掉分支，本地想要同步删除可以使用：`git fetch -p`，`-p` 是 `--prune` 的缩写，也可以手动清理：`git remote prune origin`
* 本地代码想要重置到远程分支的最新状态，可以使用 `git reset --hard origin/<branch_name>` 来重置到远程分支最新的代码
* 修改了一半的代码，想要撤销回去，可以使用：
  * `git checkout .` 来复位（旧方式，不会对已经 add 过的修改生效）
  * `git restore .` 来复位工作区（Git 2.23+ 推荐方式）
  * `git restore --staged .` 来取消暂存区的修改
* 以行的形式查看最近的提交：`git log --oneline`，可以直接看一屏的提交历史
* 查看当前分支名，适合脚本使用：`git rev-parse --abbrev-ref HEAD`
* 可视化所有分支结构：`git log --graph --oneline --all --decorate`
* git 是可以设置别名的，比如上一个命令太长不好记住，可以设置个别名：`git config --global alias.lg "log --oneline --graph --decorate --all"`
* 生成补丁文件：`git format-patch HEAD~3`，导出最近 3 次提交为 .patch 文件
* 应用补丁文件：`git apply xxx.patch`，把补丁应用到当前代码
* 查看两个 commit 之间的 log，`git log <起点>..<终点>`，`git log HEAD~5..HEAD --oneline` 查看最近 5 个提交
* 已经提交过得文件，现在想要添加到 .gitignore 中，但它们依然会被 Git 追踪，为什么？

```shell
# .gitignore 只对未被 Git 跟踪（未提交）的文件有效。对于已经被提交并纳入版本控制的文件，它不起作用。
# 解决方法如下
# 1. 从 Git 暂存区中移除文件（不删除本地文件）：
git rm --cached <文件路径>

# 2. 提交一次"清除追踪"的变更：
git commit -m "xxx"

# 查看未追踪的被忽略文件	
git ls-files -i -o --exclude-standard

# 查看已追踪但被忽略的文件
git ls-files -i -c --exclude-standard

# 可以一键清理哦
git ls-files -z --cached --ignored --exclude-standard | xargs -0 git rm --cached
```

* git 是不会对空文件夹进行管理的，如果需要保留空文件夹，可以在其中添加 `.gitkeep` 文件
* 查看文件的修改历史：`git log -p -- <filename>`，可以看到文件每次修改的具体内容
* 查看谁修改了文件的某一行：`git blame <filename>`，可以看到每一行的最后修改者和时间
* 搜索提交信息：`git log --grep="关键词"`，搜索代码内容：`git log -S "代码片段"`
* 批量修改历史中的邮箱地址：`git filter-branch --env-filter 'if [ "$GIT_AUTHOR_EMAIL" = "old@email.com" ]; then export GIT_AUTHOR_EMAIL="new@email.com"; fi'`

## 总结

恭喜你完成了 Git 进阶之旅！🎉

通过两篇文章的学习，你现在已经：

### 🎯 **掌握的技能**

* **基础扎实**：熟练掌握 Git 日常操作和核心概念
* **分支专家**：能够处理复杂的分支管理和冲突解决
* **团队协作**：了解各种工作流程和最佳实践
* **高级技巧**：掌握远程管理、性能优化、故障排查
* **深度理解**：了解 Git 内部原理，知其然知其所以然

### 💪 **你现在可以**

* 在任何规模的团队中高效协作
* 解决各种复杂的 Git 问题
* 优化和维护 Git 仓库
* 设计适合团队的 Git 工作流
* 成为团队中的 Git 专家

### 🚀 **继续进步**

* **实践为王**：在实际项目中应用所学知识
* **持续学习**：关注 Git 新特性和社区最佳实践
* **分享交流**：与团队分享你的 Git 经验
* **工具探索**：尝试各种 Git GUI 工具和集成

**📚 相关文章**：

* [Git 基本介绍 —— 入门到熟练](git-1.md)

**🎯 记住**：Git 是一个工具，但更重要的是背后的版本控制思想。掌握了这些，你就掌握了现代软件开发的重要基石！

*"工欲善其事，必先利其器"* —— 现在你的 Git 这把利器已经磨得锋利无比！⭐

---

---
url: /docs/03.工具/Git 相关/git-submodules.md
---

## 项目背景

因公司项目要拆成多个模块，部分模块给分公司的小伙伴开发权限一起开发，所以最终决定使用 git 子模块来拆分项目，今天来复盘下项目拆分中爬过的一些坑。有兴趣的同学可以参考源码一起阅读，附[源码](https://github.com/fecym/git-submodules.git)。

## 文章导览

## 子模块

首先来科普一下 git 子模块

子模块允许你将一个 git 仓库作为另一个 git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。

官方中举了一个例子：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。git 通过子模块来解决这个问题

我们当时遇到的场景也是类似，而且涉及到代码权限问题，所以使用子模块是一个不错的解决方案

可以通过 `git submodules add` 向主模块添加一个子模块，子模块可以理解为和主模块相互独立的两个 git，只是通过使用 git submodules add 为主模块关联了另一个 git

### 常用命令

* 添加子模块

格式：git submodule add `仓库地址` `本地文件夹地址`

```sh
# 示例：把 submodules-1 添加为子模块文件为 src/modules/submodules-1
git submodule add git@github.com:fecym/submodules-1.git src/modules/submodules-1
```

* 查看子模块

```sh
git submodule
```

* 更新子模块

```sh
# 更新项目内子模块到最新版本
git submodule update

# 更新子模块为远端的最新版本
git submodule update --remote
```

* 递归拉取子模块代码

```sh
git pull --recurse-submodules
```

* 批量更新子模块

因项目中存在多个子模块，开发过程中我们可能会遇到要把所有子模块都切换到某个分支去处理一些问题，此时一个个到指定文件夹下去切换分支或者执行其他操作。git 提供了批量操作可以解决这个问题

命令格式：git submodule foreach `子模块要执行的命令`

```sh
# 比如，子模块都切换到 develop 分支
git submodule foreach git checkout develop
```

### 克隆项目

克隆包含子模块的项目有二种方法：一种是先克隆父项目，再更新子模块；另一种是直接递归克隆整个项目。

1. 克隆父项目，再更新子模块

```sh
# download 项目
git git@github.com:fecym/git-submodules.git
# 查看子模块
git submodule
# -7413b6cd1656398e36077d67bbafaa9652c45171 src/modules/DeviceManagement
# 子模块前面有一个-，说明子模块文件还未检入（空文件夹）
# 初始化子模块
git submodule init
# 更新子模块
git submodule update
# 或者 git submodule update --init --recursive 也可以
```

2. 递归克隆整个项目

```sh
也可以直接递归克隆整个项目
git clone git@github.com:fecym/git-submodules.git --recursive
```

## 项目改造

### 子模块关联改造

子模块关联改造时，有以下步骤：

1. 先把要做成子模块的代码先做成 git，上传到对应的 git 仓库中
2. 然后在项目中删除到要做成子模块的文件夹
3. 使用 git submodule add 把子模块添加到项目中，文件夹地址换成之前的地址

* 如果遇到 `'src/modules/submodules-2' already exists in the index` 这种报错的情况，说明该文件夹还存在，删除掉并且保证 git 工作状态是干净的就可以了

4. 此时我们使用 `git submodules` 就可以看到添加成功的子模块了

然后我们就能看到主模块中多了一个 `.gitmodules` 文件，里面 path 就是我们项目中作为子模块的文件夹，url 是子模块 git 的地址。

也可以给子模块指定分支 `branch = master`

```yml
[submodule "src/modules/submodules-1"]
	path = src/modules/submodules-1
	url = git@github.com:fecym/submodules-1.git
  branch = master
[submodule "src/modules/submodules-2"]
	path = src/modules/submodules-2
	url = git@github.com:fecym/submodules-2.git
  branch = master
```

这之后每次更新子模块，在主模块使用 `git status` 会发现终端由以下提示子模块的变动（hash 发生了改变）会有两种状态：`modified content` 和 `new commits`，两种情况发生在 `代码有修改但未提交` 和 `代码修改并提交`

提交代码前，可以在主模块看一下状态(git status)，确保确保是自己的修改，并且状态是对的

如果发现还有子模块的信息未提交，查看一下是否为自己的修改：

若都为自己的修改，且是本次需求，直接提交

若不是要同步远端最新代码包括子模块，直接站在主模块下敲如下命令

```sh
# 递归拉取代码
git pull --recurse-submodules
# 让所有子模块切换到 develop（提交环境）分支
git submodule foreach git checkout develop
# 让所有子模块拉取远端最新代码
git submodule foreach git pull
```

同步完远端最新代码后，正常情况下，你会发现只剩下自己的提交了；若还发现有别人代码的修改，那应该是上个开发人员未做一步，你可以帮他一起提了

**科普一下**：子模块与主模块关联之后，子模块根目录下的 .git 文件夹将会变成 `.git 文件`，里面内容指定了 git 的地址

```sh
# 子模块的 .git 文件
gitdir: ../../../.git/modules/src/modules/submodules-1
```

然后主模块的 .git 文件夹下会增加 modules 文件夹，里面是对应子模块的配置

### 忽略子模块的更新

当然每次更新子模块主模块都会收到提示有时候也会很烦躁，多人开发的时候还有可能出现那种子模块 hash 的冲突，这个 git 也是有解决方案的

可以直接在 `.gitmodules` 文件里面加上 `ignore = all` 可以忽略掉所有的主模块与子模块的关联

```yml
[submodule "src/modules/submodules-1"]
	path = src/modules/submodules-1
	url = git@github.com:fecym/submodules-1.git
  branch = master
  ignore = all
[submodule "src/modules/submodules-2"]
	path = src/modules/submodules-2
	url = git@github.com:fecym/submodules-2.git
  branch = master
  ignore = all
```

ignore 有三个值：

* dirty：使用 dirty 会忽略对子模块工作树的所有更改，只显示对存储在超级项目中的提交的更改
* untracked：当使用 untracked 时，子模块仅包含未跟踪的内容时不被认为是脏的（但仍会扫描它们以查找修改的内容）
* all：使用 all 隐藏对子模块的所有更改（并在设置配置选项 status.submodulesummary 时抑制子模块摘要的输出）

### router 改造

因为使用了子模块，每次新增了子模块，不能每次都在主模块里面更新路由，这样每次子模块增加菜单都要更新主模块，肯定是不合适的，所以要做成路由自动注册，我们需要定一个规则

最终决定把路由定义在所建模块文件夹下面，命名 xxxxRouter.js ，导出一个数组。最终会在主项目路由统一引入注册。

自动注册路由就是用 webpack 中的的 `require.context` api 来注册，还不了解 `require.context` 的话可以看一下我的另一篇文章[webpack 拓展](https://chengyuming.cn/views/webpack/webpack-3.html)

```js
const webpackContext = require.context('../modules/', true, /\w+(Router\.js)$/);
const requireAll = ctx => ctx.keys().map(ctx);
const moduleRoutes = requireAll(webpackContext).map(r => r.default);
const routes = [];
moduleRoutes.forEach(moduleRoute => {
  // 考虑路由定义为对象的情况
  const moduleRoutes = Array.isArray(moduleRoute) ? moduleRoute : [moduleRoute];
  routes.push(...moduleRoutes);
});

export default routes;
```

最终把引入的路由添加到路由主文件中

```js
// router/index.js
import Vue from 'vue';
import VueRouter from 'vue-router';
import modules from './requireModules';

Vue.use(VueRouter);

const router = new VueRouter({
  mode: 'history',
  base: process.env.BASE_URL,
  routes: [...modules],
});

export default router;
```

### vuex 改造

vuex 做了统一引入注册，写法同路由，定义在我们所建模块文件夹下面，命名以 xxxxxStore.js ，但有两点强制要求：

1. 必须以 Store.js 结尾
2. 模块名称不能与之前出现过的文件夹名称重复

统一注册的规则是最终生成一个对象，key 为那个文件夹文件，value 为 `模块名称 + Store.js` 的文件内容 所以用法就是 `模块名称.xxx` 即可

```js
const modulesFiles = require.context('../modules', true, /\w+(Store\.js)$/);
const replacer = (m, p) => p.slice(0, -5);

const modules = modulesFiles.keys().reduce((modules, modulePath) => {
  const moduleName = modulePath.replace(/.+\/(\w+Store)\.js/, replacer);
  const value = modulesFiles(modulePath);
  modules[moduleName] = value.default;
  return modules;
}, {});

export default modules;
```

## 平时开发

经过上面的改造，基本上就已经完成项目拆分，然后在 git 仓库中给对应得开发人员相应的子模块代码权限，就可以做相应的代码开发了

子模块之间互不关联，与主模块的联系也是依赖主模块的一些东西，我们也改造成了自动去注册，所以也没有其他问题

平时开发，我们只需要在子模块开发，主模块一般不需要动，但是项目默认打开都在主模块下，git 提交都是主模块的信息

这里有点坑需要把目录切到相应子模块的根目录下。切到对应的开发分支，对子模块进行代码修改提交后，提 MR 到对应的分支。 主项目有修改，提 MR 后周知关联开发人员。

Jenkins 构建的时候，需要添加几条命令，以确保代码都是最新的

```sh
# 递归拉去代码
git pull origin master --recurse-submodules
# 把子模块所有的分支都切换到要构建的分支
git submodule foreach git checkout master
# 拉去所有子模块的最新的代码
git submodule foreach git pull origin master
```

平时开发的时候如果我们需要保证最新代码的话也可以先执行这三个命令，但是每次都敲这个三个命令会很麻烦，我们可以添加一个别名 prf 来替我们来取

```sh
git config --global alias.prf '!f() { git pull origin master --recurse-submodules && git submodule foreach git checkout master && git submodule foreach git pull origin master; }; f'
```

当然我们也可以把分支当做参数传过去配置一个别名

```sh
git config --global alias.prf '!f() { git pull origin $1 --recurse-submodules && git submodule foreach git checkout $1 && git submodule foreach git pull origin $1; }; f'
```

使用的时候只需要输入 `git prf master`，便可以递归拉取代码 master 的代码

自此我们已经完全改造完成了，然后按照规定正常开发即可

## 子模块 lint 失效

code review 时，发现小伙伴儿的代码风格都不一样，理论上代码提交时有 githooks 来控制执行 lint，自动按照配置来格式化代码。

很明显 eslint + prettier 失效了，思来想去想到子模块也是一个 git，而 githooks 执行时是查找 package.json 里面的配置

```json
"gitHooks": {
  "pre-commit": "lint-staged"
},
"lint-staged": {
  "*.{js,vue}": [
    "vue-cli-service lint",
    "git add"
  ]
}
```

当然这还是有前提条件的，需要为 git 注册 hooks，那我们还需要接着为子模块注册 hooks

## @vue/cli-service lint 命令

@vue/cli-service 默认是没有 lint 命令，只有 `serve`、`inspect` 和 `build` 三个默认命令，都是使用 registerCommand 来注册的

子模块要想 lint 代码并且与主模块保持一致，我们还得使用 @vue/cli-service lint，但是主模块有，我当时也很纳闷，于是看了一下源码发现是必须有 eslint 的时候他会自己去注册 lint 命令，于是我们在 package.json 中加入 eslint 就可以了

最终子模块 package.json 代码如下

```json
{
  "name": "submodules-1",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "keywords": [],
  "author": "",
  "license": "ISC",
  "scripts": {
    "lint": "npx vue-cli-service lint **/*.js **/*.vue"
  },
  "devDependencies": {
    "@vue/cli-plugin-eslint": "~5.0.0"
  },
  "gitHooks": {
    "pre-commit": "lint-staged"
  },
  "lint-staged": {
    "*.{js,vue}": ["yarn lint", "git add"]
  }
}
```

然后我们在改造主模块为子模块注册 git hooks

## githooks

git hooks 的实现其实非常简单，就是 .git/hooks 文件下，保存了一些 shell 脚本，然后在对应的钩子中执行这些脚本就行了。比如下图中，这是一个还没有配置 git hooks 的仓库，默认会有很多 .sample 结尾的文件，这些都是示例文件

我们项目已经注册了 githooks，不带 .sample 就是已经注册好的，打开 pre-commit.sample 文件看一下其中的内容，大致意思是说这是一个示例，做了一些格式方面的检测，这个脚本默认是不生效的，如果要生效，把文件名改为 pre-commit 也就是去掉 `.sample` 即可

`pre-commit` 这个钩子是在 git commit 命令执行之前触发

| Git hooks          | 调用时机                                 | 说明                                             |
| ------------------ | ---------------------------------------- | ------------------------------------------------ |
| pre-applypatch     | git am 执行前                            |                                                  |
| applypatch-msg     | git am 执行前                            |                                                  |
| post-applypatch    | git am 执行后                            | 不影响 git am 的结果                             |
| pre-commit         | git commit 执行前                        | 可以用 git commit --no-verify 绕过               |
| commit-msg         | git commit 执行前                        | 可以用 git commit --no-verify 绕过               |
| post-commit        | git commit 执行后                        | 不影响 git commit 的结果                         |
| pre-merge-commit   | git merge 执行前                         | 可以用 git merge --no-verify 绕过                |
| prepare-commit-msg | git commit 执行后，编辑器打开之前        |                                                  |
| pre-rebase         | git rebase 执行前                        |                                                  |
| post-checkout      | git checkout 或 git switch 执行后        | 不使用--no-checkout，则在 git clone 之后也会执行 |
| post-merge         | git commit 执行后                        | 在执行 git pull 时也会被调用                     |
| pre-push           | git push 执行前                          |                                                  |
| pre-receive        | git-receive-pack 执行前                  |                                                  |
| update             |                                          |                                                  |
| post-receive       | git-receive-pack 执行后                  | 不影响 git-receive-pack 的结果                   |
| post-rewrite       | 执行 git commit --amend 或 git rebase 时 |                                                  |

PS：完整钩子说明，请参考[官网链接](https://git-scm.com/docs/githooks)

### husky

githooks 保存在 .git 文件夹中。git 是一个多人协作工具，那按理说 git 仓库中的所有文件都应该被跟踪并且上传至远程仓库的。但是有个例外，.git 文件夹不会，这就导致一个问题，我们在本地配置好 githooks 后，怎么分享给其他小伙伴儿呢？copy 吗？那未免太 low 了，都用 git 了还 copy，也太不优雅了。这时候我们可以用 [husky](https://github.com/typicode/husky)

husky 是一个让配置 git 钩子变得更简单的工具。husky 的原理是让我们在项目根目录中写一个配置文件，然后在安装 husky 的时候把配置文件和 githooks 关联起来，这样我们就能在团队中使用 githooks 了。也可以直接执行 `husky install` 来生成 githooks，husky 不是很了解的同学可以看我另外一篇文章 [eslint 工作流](https://chengyuming.cn/views/FE/lint/)

### yorkie

但是我们项目是 vue-cli 搭建的，Vue 使用的 `yorkie`，`yorkie` fork 自 `husky`，然后做了一些改动：

1. 先考虑位于.git 目录旁边的 package.json，而不是硬编码的向上搜索。避免了在 lerna 仓库中的根包和子包都依赖于 husky 的问题，它会混淆并用错误的路径，双重更新根 git 钩子。
2. 更改在 package.json 中 hooks 的位置

那我们最终的做法就是让 yorkie 给子模块增加 package.json，然后安装 hooks 就可以了

但是每次都没成功，于是翻看了源码，里面查找的路径是基于当前 node\_modules 然后向上查找到 package.json，内部执行的是包内的 `runner.js`，是相对于 install.js 目录

如果我们想直接用的话，就需要在每一个子模块中都安装 yorkie，但是能在主模块中处理一次，肯定不能在子模块中多次处理，最终还是决定把 yorkie 源码拿过来修改一下，在初始化的时候执行一次即可

## 改造 yorkie

最终我们按照 yorkie 的思路做了一个注册子模块 githooks 的脚本，然后只需在初始化的时候执行一次即可

```js
const fs = require('fs');
const path = require('path');
const findHooksDir = require('yorkie/src/utils/find-hooks-dir');
const getHookScript = require('yorkie/src/utils/get-hook-script');
const is = require('yorkie/src/utils/is');
const hooks = require('yorkie/src/hooks.json');

const SKIP = 'SKIP';
const UPDATE = 'UPDATE';
const MIGRATE_GHOOKS = 'MIGRATE_GHOOKS';
const MIGRATE_PRE_COMMIT = 'MIGRATE_PRE_COMMIT';
const CREATE = 'CREATE';

// 把这里改成绝对地址
const runnerPath = path.resolve('./node_modules/yorkie/src/runner.js');

function write(filename, data) {
  fs.writeFileSync(filename, data);
  fs.chmodSync(filename, parseInt('0755', 8));
}

function createHook(hooksDir, hookName) {
  const filename = path.join(hooksDir, hookName);

  const hookScript = getHookScript(hookName, '.', runnerPath);

  // Create hooks directory if needed
  if (!fs.existsSync(hooksDir)) fs.mkdirSync(hooksDir);

  if (!fs.existsSync(filename)) {
    write(filename, hookScript);
    return CREATE;
  }

  if (is.ghooks(filename)) {
    write(filename, hookScript);
    return MIGRATE_GHOOKS;
  }

  if (is.preCommit(filename)) {
    write(filename, hookScript);
    return MIGRATE_PRE_COMMIT;
  }

  if (is.huskyOrYorkie(filename)) {
    write(filename, hookScript);
    return UPDATE;
  }

  return SKIP;
}

function installFrom(projectDir) {
  try {
    const hooksDir = findHooksDir(projectDir);
    if (hooksDir) {
      const createAction = name => createHook(hooksDir, name);
      hooks.map(hookName => ({ hookName, action: createAction(hookName) }));
      const submodule = path.relative(__dirname, projectDir);
      console.log(`submodule：${submodule} installation completed\n`);
    } else {
      console.log("can't find .git directory, skipping Git hooks installation");
    }
  } catch (e) {
    console.error(e);
  }
}

function getSubmoduleDirs() {
  const parentDir = 'src/modules';
  // 子模块文件地址
  const dirs = ['submodules-1', 'submodules-2'];
  return dirs.map(dir => path.resolve(parentDir, dir));
}

const dirs = getSubmoduleDirs();

dirs.forEach(installFrom);
```

编写完脚本之后，执行一次，就会为子模块生成相应的 githooks，可以在根目录下 `.git/modules/src/modules/submodules-1/hooks` 就可以看到生成的 githooks 了（主模块添加子模块后，子模块的 .git 文件夹会变成 .git 文件然后指向了主模块中，所以添加的 hooks 也是在主模块中）

如果添加完后发现子模块 lint 有报错：`Either disable config file checking with requireConfigFile: false, or configure Babel so that it can find the config files` 这个可能 babel 版本问题，只需要在子模块中增加一个 babel 配置，然后继承主模块的配置就可以了

```js
module.exports = {
  extends: '../../../babel.config.js',
};
```

## 自动注册 hooks

到此为止，项目就支持了子模块提交时的 lint 功能，但是小伙伴第一次使用的时候是没有安装子模块的 git hooks 的，而且对于新来的小伙伴来说他们可能不知道需要这样做，导致代码风格还是不一样，总不能给来一个小伙伴给他们讲一遍吧，所以还是写个脚本检测一下是否安装过了子模块的 hooks，如果安装了就该干嘛干嘛，未安装的话先安装一次

在项目运行的时候先去检查一下子模块的 hooks 是否安装过了，安装过了则直接运行项目，没有安装的话先安装项目，安装完之后在运行项目，那么我们就要解决几个问题

### 怎么知道是否已经注册过了

要知道是否注册过 hooks，我们可以在项目根目录中找 `.git/hooks` 里面找那些 shell 脚本，默认会有很多 .sample 结尾的文件，如果所有文件都是 .sample 结尾的则说明没有安装 hooks，如果不带 .sample 说明已经注册过了

那我们要做的就是直接读取文件夹里面的文件看是否存在如果该文件已存在则说明注册过了，不存在则说明没有注册

那怎么知道要读取哪个文件夹呢，可以写个方法来找，如果没找到就返回，找到了则看一下是文件还是文件夹：

* 如果是文件夹的话，这个文件夹下面的 hooks 就是咱们要找的了
* 如果是文件的话，那么这个文件里面会告诉我他的 hooks 的文件夹在哪（子模块会用到）

```js
function findHooksDir(dir) {
  if (dir) {
    let gitDir = path.join(dir, '.git');
    if (!fs.existsSync(gitDir)) return;
    const stats = fs.lstatSync(gitDir);
    if (stats.isFile()) {
      const gitFileData = fs.readFileSync(gitDir, 'utf-8');
      gitDir = gitFileData.split(':').slice(1).join(':').trim();
    }
    return path.resolve(dir, gitDir, 'hooks');
  }
}
```

既然这个问题解决了我们就可以直接写个方法来检查是否已经注册过 git hooks 了

```js
const path = require('path');
const hooks = [
  'applypatch-msg',
  'pre-applypatch',
  'post-applypatch',
  'pre-commit',
  'prepare-commit-msg',
  'commit-msg',
  'post-commit',
  'pre-rebase',
  'post-checkout',
  'post-merge',
  'pre-push',
  'pre-receive',
  'update',
  'post-receive',
  'post-update',
  'push-to-checkout',
  'pre-auto-gc',
  'post-rewrite',
  'sendemail-validate',
];
const findHooksDir = require('./findHooksDir');
const fs = require('fs');
const { promisify } = require('util');
const exists = promisify(fs.exists);
// 那么直接传入项目根目录就可以查到是否注册过
function checkHooks(huskyDir) {
  return new Promise((resolve, rejected) => {
    const hooksDir = findHooksDir(huskyDir, '.git');
    Promise.all(hooks.map(hook => exists(path.resolve(hooksDir, hook)))).then(res => {
      resolve(res.every(x => !!x));
    }, rejected);
  });
}
```

接下来把所有子模块的根目录传进去就可以得到，得到子模块是否注册过了 git hooks

### 检查子模块是否注册过

改造下这个代码让子模块支持，思路也很简单，把子模块的文件路径传递过去然后去读文件然后判断结果就可以

```js
const path = require('path');
// 把一些通用的东西拆出去了，文末会有项目地址，里面会有完整代码
const { findHooksDir, hooks, submoduleDirs, warnLogger } = require('./helper');
const fs = require('fs');
const { promisify } = require('util');
const exists = promisify(fs.exists);

function checkHooks(huskyDir) {
  return new Promise((resolve, rejected) => {
    const hooksDir = findHooksDir(huskyDir, '.git');
    Promise.all(hooks.map(hook => exists(hooksDir && path.resolve(hooksDir, hook)))).then(res => {
      const relativeDir = path.relative(__dirname, huskyDir);
      const result = res.every(x => !!x);
      resolve({ hooksDir, huskyDir, relativeDir, result });
    }, rejected);
  });
}

module.exports = function check() {
  return new Promise((resolve, rejected) => {
    Promise.all(submoduleDirs.map(checkHooks)).then(result => {
      const res = result.filter(r => !r.result);
      const logger = r => {
        const text = `${r.relativeDir.replace('../src/modules/', '')} 子模块未注册 Git Hook`;
        warnLogger(text);
      };
      res.forEach(logger);
      resolve(!res.length);
    }, rejected);
  });
};
```

此时执行 `check` 方法就可以得到子模块是否都注册过hooks

### npm pre 钩子

最后把之前改造 yorkie 的代码和查找子模块是否注册过的代码合到一起，然后放到 npm pre 钩子函数中执行即可

npm 脚本有 pre 和 post 两个钩子。举例来说，serve 脚本命令的钩子就是 preserve 和 postserve

执行 npm run serve 的时候，就会先执行 preserve 里面的脚本然后在执行 serve 脚本

执行结果就是 `npm run preserve && npm run serve`，npm 钩子不熟悉的同学可以参考另一篇代码[ eslint工作流/npm 钩子 ](/views/FE/lint.html#npm-钩子)

如果 preserve 里面的代码是异步的，也会等异步返回结果后才会执行下一个脚本，所以非常符合我们的预期

最终代码改造为：

```json
{
  "scripts": {
    "preserve": "node installHooks",
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
}
```

```js
// installHooks/index.js
require("./checkHooks")().then(checked => {
  if (!checked) require("./install.hooks");
});
```

源码地址：<https://github.com/fecym/git-submodules>

## 参考文献

1. [Config Files](https://babeljs.io/docs/en/config-files)
2. [Vue CLI git hook](https://cli.vuejs.org/zh/guide/cli-service.html#git-hook)
3. [一文带你彻底学会 Git Hooks 配置](https://segmentfault.com/a/1190000022970270)

---

---
url: /docs/02.服务端/http-undone.md
---

## 头部

### 通用头

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存行为               |
| Connection        | 链接的管理                 |
| Date              | 报文日期                   |
| Pragma            | 报文指令                   |
| Trailer           | 报文尾部的首部             |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade           | 升级为其他协议             |
| Via               | 代理服务器信息             |
| Warning           | 错误通知                   |

### 请求头

| 首部字段名          | 说明                                            |
| ------------------- | ----------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                        |
| Accept-Charset      | 优先的字符集                                    |
| Accept-Encoding     | 优先的编码                                      |
| Accept-Language     | 优先的语言                                      |
| Authorization       | 认证信息                                        |
| Expect              | 期待服务器的特定行为                            |
| From                | 用户的电子邮件地址                              |
| Host                | 请求资源所在的服务器                            |
| If-Match            | 比较实体标记                                    |
| If-Modified-Since   | 比较资源的更新时间                              |
| If-None-Match       | 比较实体标记                                    |
| If-Range            | 资源未更新时发送实体 Byte 的范围请求            |
| If-Unmodified-Since | 比较资源的更新时间（和 If-Modified-Since 相反） |
| Max-Forwards        | 最大传输跳数                                    |
| Proxy-Authorization | 代理服务器需要客户端认证                        |
| Range               | 实体字节范围请求                                |
| Referer             | 请求中的 URL 的原始获取方法                     |
| TE                  | 传输编码的优先级                                |
| User-Agent          | HTTP 客户端程序信息                             |

### 响应头

| 首部字段名          | 说明                         |
| ------------------- | ---------------------------- |
| Accept-Ranges       | 是否接受字节范围             |
| Age                 | 资源的创建时间               |
| Etag                | 资源的匹配信息               |
| Location            | 客户端重定向至指定的 URL     |
| Proxy-Authorization | 代理服务器对客户端的认证信息 |
| Retry-After         | 再次发送请求的时机           |
| Server              | 服务器信息                   |
| Vary                | 代理服务器缓存的管理信息     |
| WWW-Authorization   | 服务器对客户端的认证         |

### 实体头

| 首部字段名       | 说明                         |
| ---------------- | ---------------------------- |
| Allow            | 资源可支持的 HTTP 方法       |
| Content-Encoding | 实体的编码方式               |
| Content-Language | 实体的自然语言               |
| Content-Length   | 实体的内容大小（单位：字节） |
| Content-Location | 替代对应资源的 URI           |
| Content-MD5      | 实体的报文摘要               |
| Content-Range    | 实体的位置范围               |
| Content-Type     | 实体主机的媒体类型           |
| Expires          | 实体的过期时间               |

---

---
url: /docs/02.服务端/https-undone.md
---

## https

参照[老左笔记](https://www.laozuo.org/7676.html)进行实践

## 准备东西

首先准备一台空的服务器

## 安装的东西

* 安装 git、nginx

```sh
yum install git
yum install nginx
```

## 快速获取 Let's Encrypt 免费 SSL 证书

执行以下脚本，域名换成自己的域名，邮箱换成自己的邮箱，然后一路同意

注意：执行脚本的时候一定要停掉 nginx，否则会出错

```sh
git clone https://github.com/letsencrypt/letsencrypt
cd letsencrypt
./letsencrypt-auto certonly --standalone --email diy_mnb@163.com -d https.cym.today
```

## 有效期是 90 天

每间隔 90 需要执行以下这个脚本

```sh
./letsencrypt-auto certonly --renew-by-default --email diy_mnb@163.com -d https.cym.today
```

如何配置参照老左笔记

## 配置 nginx

进入 `/etc/nginx`，修改 `nginx.conf`

```sh
cd /etc/nginx/
vi nginx.conf
```

---

---
url: /docs/01.前端/01. 基础/javascript.md
---

## 类型转换

### 一个有趣的问题

> 看到了这个我亲自尝试了下，结果发现自己对 js 基础越来越陌生了，现在好好复习下吧

```js
0 == '0'; // true
0 == []; // true
'0' == []; // false
```

#### 为什么？

> 为什么 '0' == \[] 是 false ？
> 为什么 为什么 0 == \[] 是 true？
> 为什么 \[] == !\[] 是 true

带着这三个疑问来解释下这个问题

首先，`==` 转换有几个基本规则：

1. `NaN` 与任何值都不相等，包括自己本身
2. `undefined` 与 `null` 相等(==)，其他都不等
3. 对象与字符串类型做比较，会把对象转换成字符串然后做比较
4. 其他类型比较都要转换成 `数字` 做比较

#### 1. 为什么 '0' == \[] 是 false ？

这个对应上面的第三条规则 `对象与字符串类型做比较，会把对象转换成字符串然后做比较`，那么 `[].toString()` 返回一个 `''` 所以就是 false

#### 2. 为什么 0 == \[] 是 true？

这个对应第四条规则：会把 `[]` 转换成数字进行比较，`[]` 转数字会变成 `0`，所以这个也是 `true`

拓展一下：`Number([]) => 0、Number([''] => 0、Number([1]) => 1)`

#### 3. 为什么 \[] == !\[] 是 true

这个也对应第四条规则

* 首先 `[].toString()` 会得到一个 `''` 字符串
* `![]` 得到一个布尔值 `false`
* `''` 与 `false` 比较肯定要转换成数字比较
* 那么 `''` 转换则为 `0`， `false` 转换也是 `0`
* 所以这道题就是 `true`

```js
Number([]); // 0
Number(![]); // 0
Number(!![]); // 1
```

### 类型转换规则

> 在 js 中类型转换有三种情况：转布尔值；转数字；转字符串。如果发生了隐式转换，那么各种类型互转符合下面的规则：

### 显示数据类型转换

* 转数字：`Number()`
  * 如果是 `number` 类型的字符串，那么转换的时候回返回自己
  * 如果不是 `number` 类型的字符串，那么转换结果是 `NaN`
  * 如果是 `''`，那么转换结果是 `0`

* 转数字：`parseInt`
  * 忽略掉前面的空格，直到找到第一个非空字符串，还会降后面的非数字字符串去掉
  * 如果第一个字符不是数字符号或者负号，则返回 `NaN`
  * 会向下取整

* 转数字：`parseFloat`

  * 同上，但是会保留小数

* 转字符串：`String()、toString()`

* 转 boolean：`Boolean()`
  * 在进行转换 `boolean` 的时候，所有的结果都为 `true`，除了 `false、''、0、-0、NaN、undefined、null`

### 隐式转换

* 转 `number`：减乘除取余都可以让字符串隐式转换为 `number`
* 转 `string`：可以通过加 `''` 字符串来转换 `a = a + ''`
* 转 `boolean`：可以通过加 `!` 来转换 `a = !!a`
* 在条件判断时，除了 `false、''、0、-0、NaN、undefined、null`，其他值都可以转为 `true`，包括所有对象

### 对象转原始类型

* 对象转换类型的时候，会调用内置的 `[toPrimitive]` 函数，对于该函数来说，算法逻辑如下：
  * 如果已经是原始类型了，那就不需要转换了
  * 调用 `x.valueOf()` ，如果转为基础类型，就返回转换的值
  * 调用 `x.toString()` ，如果转为基础类型，就返回转换的值
  * 如果都没有返回原始类型，就会报错
  * 当然也可以重写 `[Symbol.toPrimitive]`，该方法在转换原始类型时调用优先级最高
  ```js
  const obj = {
    valueOf() {
      return 0;
    },
    toString() {
      return '1';
    },
    [Symbol.toPrimitive]() {
      return 2;
    },
  };
  obj + 1; // 3
  ```
* 引用类型转换为 `Number` 类型，先调用 `valueOf` ，在调用 `toString`
* 引用类型转换为 `String` 类型，先调用 `toString` ，在调用 `valueOf`
* 若 `valueOf` 和 `toString` 都不存在，或者没有返回基本类型，则会抛出 `TypeError` 异常

```js
// 可以转换的
const obj = {
  valueOf() {
    console.log('valueOf');
    return 123;
  },
  toString() {
    console.log('toString');
    return 'cym';
  },
};
console.log(obj - 1); // valueOf 122
console.log(`${obj} 你好`); // toString cym 你好
// 转换报错
const o = {
  valueOf() {
    console.log('valueOf');
    return {};
  },
  toString() {
    console.log('toString');
    return {};
  },
};
console.log(o - 1); // Uncaught TypeError: Cannot convert object to primitive value
console.log(`${o} 你好`); // Uncaught TypeError: Cannot convert object to primitive value
```

### 再来一张图

* 这张图可能理解会更好点

### == 和 ===

> `===` 叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如 `'1' === 1` 结果是 false，因为一边是 string，另一边是 number。其实这种说法不严格，严格来说是：`== 允许在相等比较中进行强制类型转换，而 === 不允许`

* `==` 不像 `===` 那样严格，对于一般情况，只要值相等，就返回 `true`，但 `==` 还涉及一些类型转换，它的转换规则如下：

  * 两边类型是否相同，相同的话就比较值的大小，例如 `1 == 2`，返回 `false`
  * 判断的值是否是 `null` 和 `undefined`，是的话就返回 `true`（js 中只有 `null == undefined`）
  * 判断的类型是否 `String` 和 `Number`，是的话就把 `String` 转换成 `Number`，在进行比较
  * 判断其中一方是否是 `Boolean`，是的话就把 `Boolean` 转换成 `Number`，在进行比较（遇到布尔值会转换为数字进行比较）
  * 判断其中一方是否是 `Object`，且另一方为 `String、Number、Symbol`，会将 `Object` 转成字符串，在进行比较
  * 此段内容摘自[掘金 - 原生 JS 灵魂之问](https://juejin.im/post/5dac5d82e51d45249850cd20#heading-17)

* 对象的 `==` 和 `===` 比较的时候工作原理是一样的，都是判断其地址是否一致

```js
console.log({ a: 1 } == true); // false
console.log({ a: 1 } == '[object Object]'); // true
```

### 假值常规和非常规的情况

```js
  '0' == null         // false
  '0' == undefined    // false
  '0' == false        // true   -- 嘿嘿
  '0' == NaN          // false
  '0' == 0            // true
  '0' == ''           // false

  false == null       // false
  false == undefined  // false
  false == NaN        // false
  false == 0          // true   -- 嘿嘿
  false == ''         // true   -- 嘿嘿
  false == []         // true   -- 嘿嘿
  false == {}         // false

  '' == null          // false
  '' == undefined     // false
  '' == NaN           // false
  '' == 0             // true   -- 嘿嘿
  '' == []            // true   -- 嘿嘿
  '' == {}            // false

  0 == null           // false
  0 == undefined      // false
  0 == NaN            // false
  0 == []             // true   -- 嘿嘿
  0 == {}             // false

  [] == ![]           // true   -- 嘿嘿嘿
```

## 枚举

* 声明一个变量然后直接赋值，会返回一个 *undefined*
* 声明一个变量之后，在为其赋值，将会返回你赋的那个值
* 那么一个 ts 的枚举就是利用这个来实现的

```js
var Days = {};
function enumerate(Enum = {}) {
  Enum[(Enum['a'] = 1)] = 'a';
  Enum[(Enum['b'] = 2)] = 'b';
  Enum[(Enum['c'] = 3)] = 'c';
  Enum[(Enum['d'] = 4)] = 'd';
  Enum[(Enum['e'] = 5)] = 'e';
  return Enum;
}
// 那么枚举的实现应该这么写
function creatEnum(Enum = {}, args = []) {
  if (!args.length) return {};
  for (let i = 0, len = args.length; i < len; i++) {
    Enum[(Enum[i] = i)] = args[i];
  }
  return Enum;
}
```

## 传值和传址

### 基础概念

> 对于一个引用类型，把这个引用类型赋值给其他的引用类型的后，对该引用类型的某个属性进行修改，则另外一个也会变，但是覆盖后，则对另一个不会有影响

```js
const obj = { a: 1, b: '我是b' };
let b = obj;
// 对其某个属性修改，则会另外一个对象也会变，因为是同一个引用
b.b = '我是b';
console.log(obj, b); // {a: 1, b: "我是b"} {a: 1, b: "我是b"}
// 对其覆盖，则不会影响另一个对象
b = { c: '我是b的c' };
console.log(obj, b); // {a: 1, b: "我是b"} {c: "我是b的c"}
```

### 函数的传值和传址

* 传值：传给函数的是值的一个复制，函数中对其的修改 **不会影响到外面的值**
* 传址：传给函数的是一个引用，函数中 **对引用的属性做修改会影响到外部的对象**，但用 **新引用覆盖其则在不会影响到外面的引用**

```js
let a = [1, 2, 3];
let b = [5, 6];
function change(a, b) {
  a[0] = 4; // 对其属性的修改外部可见
  let c = a;
  a = b; // 用新引用覆盖
  b = c;
  console.log(a); // '5, 6'
  console.log(b); // '4, 2, 3'
}
change(a, b);
console.log(a); // '4, 2, 3'
console.log(b); // '5, 6'
```

### 如何解决函数内传址带来的影响

根据上面的情况我们发现：当传递给函数参数是一个引用的时候，在函数中修改该引用会影响到外面的引用类型，因为他们是同一个地址

那么我不想影响到函数外面的引用类型怎么办？

在 《你不知道的 JavaScript》中卷中，有这么一句话：`如果通过值复制的方式来传递复合值（如数组），就需要为其创建一个副本，这样传递的就不再是原始值`

也就是说我们传递一个引用类型的副本给函数，那么修改了也是对这个副本的引用有影响，对原来的引用值没有影响，还是不理解？那么看下面的代码：

```js
const arr = [1, 2, 3];
function fn(arr) {
  arr.push(8);
}
// 执行函数fn传递数组的副本过去，此时，我们在打印外面的 arr 发现是没有变化的
fn(arr.slice());
// 为什么呢？因为这么写就相当于我们用了引用覆盖了原来的引用，当然不会对原来的引用造成影响了
// 相当于这么写
let copyArr = arr;
copyArr = arr.slice();
fn(copyArr);
```

## this

在《你不知道的 JavaScript》上卷中提到 `this` 绑定有四种规则，分别是默认绑定（函数自执行）、隐式绑定（对象打点调用）、显示绑定（call 之类绑定）、new 绑定（构造函数）

### 默认绑定

默认绑定也是最常用的函数调用类型，也就是函数自执行，此时函数中 · 执行全局中最顶层对象，浏览器中就是 `window`、`node` 中就是 `global`

如果是在严格模式下，则不能将全局对象用于默认绑定，因此 `this` 会被绑定到 `undefined`

### 隐式绑定

1. 隐式绑定其实就是看调用位置是否有上下文对象，或者说是否被某个对象拥有或者所包含，当函数拥有上下文对象时，隐式绑定会把函数中的 `this` 绑定到这个上下文对象上

2. 对象属性引用链中只有上一层或者说最后一层调用位置中起作用，来看以下代码：

```js
function print_a() {
  console.log(this.a);
}
const obj2 = {
  a: 42,
  print_a,
};
const obj1 = {
  a: 2,
  obj2,
};
// 最后一层调用链中起作用
obj1.obj2.print_a(); // 42
```

3. `dom` 编程中事件函数中的 `this`（事件函数不是箭头函数的情况）指向了绑定事件的元素，说白了还是谁调用函数那么 `this` 就指向谁

4. 隐式绑定可能会出现丢失的情况，看以下代码：

```js
function print_a() {
  console.log(this.a);
}
const obj = { a: 2, print_a };
// 我们把函数赋值给了一个变量来保存
const fn = obj.print_a;
var a = '我是window的a';
// 此时执行这个函数，其实就是相当于函数的自执行的，那么就会走默认绑定的规则
fn(); // 我是window的a
```

### 显示绑定

显示绑定分两种情况：使用 [`call、apply、bind`](/views/basis/api.html#call-和-apply) 方法绑定 `this` 和 `api` 调用的上下文

```js
// api 调用的上下文
function foo(el) {
  console.log(el, this.id);
}
const obj = { id: 'awesome' }[
  // 调用 foo 时把 this 绑定到 obj 上
  (1, 2, 3)
].forEach(foo, obj); // 1 awesome 2 awesome 3 awesome
```

### new 绑定

`new` 绑定也是可以影响函数中 this 绑定行为的方法，也是这四种规则中优先级最高的一个，详细可以看 [`new的实现`](/views/basis/api.html#实现一个-new-操作符)

### 箭头函数

箭头函数不会使用 `this` 四种标准规则，而是根据外层（函数或者全局）作用域来决定 `this`，其实一个简单的理解就是我们在箭头函数出来之前经常用的一种方法，在函数外面 `var that = this`，然后在内层函数中使用 `that` 此时就保留了外层的 `this` 值

```js
var name = 'cym';
const fn = () => console.log(this.name);
const obj = { name: 'obj' };
// this 不会被改变
fn.call(obj); // cym

// 来个面试题理解下
const obj1 = {
  name: 'obj1',
  print: function() {
    return () => console.log(this.name);
  },
};
const obj2 = { name: 'obj2' };
obj1.print()(); // obj1
obj1.print().call(obj2); // obj1
obj1.print.call(obj2)(); // obj2
```

## 防抖和节流

### 防抖

* 防抖：触发高频事件后 n 秒内只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间。
* 思路：每次触发事件时都取消之前的延时调用

```js
function debounce(fn, step) {
  let timer = null;
  return function() {
    clearTimeout(timer);
    // 每次调用前先清除
    timer = setTimeout(() => {
      fn.apply(this, arguments);
    }, step);
  };
}
```

### 节流

* 高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率
* 思路：每次触发事件时都判断当前是否有等待执行的延时函数

```js
  function throttle(fn, step) {
    ley canRun = true
    return function() {
      if (!canRun) return
      canRun = false
      setTimeout(() => {
        fn.apply(this, arguments);
        canRun = true
      }, step)
    }
  }
```

### 补充

* 以前我认为防抖和节流都差不多，但是有一次在开发地图的时候发生改变

* 需求是这样的，我们要模仿百度地图的搜索，搜索完之后，把后台返回的数据展示为一个列表，然后对应的点显示上去

* 鼠标悬停列表后地图上的点也改变其颜色，如下图

* 鼠标滑动事件是高频事件，一定需要阻止一下，否则一会页面就卡死了，我想都没有想就想到了节流，限制事件的执行频率，代码如下

```html
<!-- vue结构 -->
<div
  v-for="(item, idx) in aoiNameList"
  :key="idx"
  class="item"
  @click="showDetails(item)"
  @mouseover="changeMapLocationIcon(idx)"
  @mouseout="clearTimer"
></div>
```

```typescript
  // 节流处理
  protected throttle: boolean = true
  // 根绝鼠标悬停改变mapbox中的样式
  protected changeMapLocationIcon(idx: number) {
    if (!this.throttle) return
    this.throttle = false
    setTimeout(() => {
      this.markerList.forEach((item: any, index: number) => {
        item._element.classList.remove('active')
        if (idx === index) {
          console.log(item)
          item._element.classList.add('active')
        }
      })
      this.throttle = true
    }, 200)
  }
```

* 我鼠标不停的滑动来切换，我发现 mapbox 上的图标颜色没有改变，
* 我才想到，这么玩的话，在满足条件再次执行该函数的时候，永远保持上一个状态，他只会记住一次状态，所有我们应该选择防抖而不是节流
* 于是，我把代码改了下:

```ts
  // 防抖处理高频事件
  protected timer: any = null
  protected changeMapLocationIcon(idx: number) {
    clearTimeout(this.timer)
    this.timer = setTimeout(() => {
      this.markerList.forEach((item: any, index: number) => {
        item._element.classList.remove('active')
        if (idx === index) {
          item._element.classList.add('active')
        }
      })
    }, 300)
  }
  protected clearTimer() {
    clearTimeout(this.timer)
  }
  protected beforeDestroy() {
    clearTimeout(this.timer)
  }
```

## Reflect

::: tip
*Reflect*对象与*Proxy*对象一样，都是 Es6 为了操作对象而提供的新 API。*Reflect*对象的设计目的有这样几个

* 将*Object*对象的一些明显属于语言内部的方法（比如*Object.defineProperty*），放到*Reflect*对象上。现阶段，某些方法同时在*Object*和*Reflect*对象上部署，未来新的方法将只部署在*Reflect*对象上。也就是说，从*Reflect*对象上可以拿到语言内部的方法。
* 修改某些*Object*方法的返回结果，让其变得更合情合理。比如，*Object.defineProperty(obj, name, desc)*在无法定义属性时会抛出一个错误，而*Reflect.definProperty(obj, name, desc)*则会返回*false*
* 让*Object*操作都变成函数行为。某些*Object*操作都是命令式，比如*name in obj*和*delete obj\[name]*，而\*Reflect.has(obj, name)*和*Reflect.deleteProperty(obj, name)\*让他它们变成了函数行为
* *Reflect*对象的方法与*Proxy*对象的方法一一对应，只要是*Proxy*对象的方法，就能在*Reflect*对象上找到对应的方法。这就让*Proxy*对象可以方便地调用对应的*Reflect*方法，完成默认行为，作为修改行为的基础。也就是说，**不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为**。
  :::

## 发布订阅机制

> 发布订阅模式也是观察者模式，它定义了一种一对多的关系，让多个订阅对象同时监听某一个主题对象，这个主题对象某一状态发生改变的时候就会通知所有订阅者。它有两类对象组成：发布者和订阅者，发布者负责发布消息，同时订阅者通过订阅这些事件来观察主题。发布者和订阅者是完全解耦的，彼此不知道对方的存在，两者仅仅共享一个自定义事件的名称。（摘自博客园）

* 今天上午提到的 **Redis** 的发布订阅，就是一个发布订阅模式 [传送门](/views/big-front-end/redis/#redis-发布订阅)
* **node** 中的 **events** 模块中的 **EventEmitter** 类就是一个发布订阅模式

```js
// 演示下node中的发布订阅
const Emitter = require('events').EventEmitter;
const emitter = new Emitter();
emitter.on('test', msg => {
  console.log(msg, '第一个');
});
emitter.on('test', (...msg) => {
  console.log(msg, '第二个');
});
emitter.on('test', msg => {
  console.log(msg, '第三个');
});
emitter.emit('test', 'chengyuming');
emitter.emit('test2', '嘿嘿嘿', '哈哈哈');
```

* 让我们来实现一个简单发布订阅模式
  * 首先我们要有一个 **Emitter** 类
  * 这个类里有个属性里面用来存放我们的消息队列
  * 这个类的实例要有两个方法，一个发布一个订阅

```js
class Emitter {
  constructor() {
    // 消息队列，以及消息类型
    this.handlers = {};
  }
  // 订阅事件，绑定函数
  on(eventType, handler) {
    // 判断消息队列里面有没有该事件，有则继续push没有则赋值空[]
    if (!(eventType in this.handlers)) {
      this.handlers[eventType] = [];
    }
    this.handlers[eventType].push(handler);
  }
  // 发布消息
  emit(eventType) {
    // 获取到发布的所有消息
    const messages = Array.prototype.slice.call(arguments, 1);
    // 触发订阅事件的函数执行
    this.handlers[eventType].forEach(handler => {
      handler.apply(this, messages);
    });
  }
}
```

---

---
url: /docs/01.前端/01. 基础/inherit.md
---

> 继承是一个老生常谈的问题，因为它的晦涩难懂，且它又是前端基础的重中之重。本篇文章将围绕着我所遇到的继承以及我所认识的理解的继承做一下记录。

## 原型

### 野史

> 根据野史记载，**Brendan Eich** 用了一周的时间创造了今天的 **JavaScript**，当 **Brendan Eich** 在为 **JavaScript** 设计面向对象系统时，借鉴了 **Self** 和 **Smalltalk** 这两门基于原型的语言。而且 **Brendan Eich** 一开始就没有打算在 **JavaScript** 中加入类的概念，所以 **JavaScript** 是一门基于原型的语言。在原型编程的思想中，类并不是必须的，对象未必需要从类中创建而来，一个对象是通过另一个对象而得到的。

* 在曾探的《设计模式》中提到 **JavaScript** 中的原型继承会遵循以下这些原型编程的基本规则：
  * 所有的数据都是对象
  * 要得到一个对象，不是通过实例化类，而是找到一个对象为原型并克隆它
  * 对象会记住他的原型
  * 如果无法响应某个请求，它会把这个请求委托给它自己的原型

### 原型是什么？

* 我们知道在 **JavaScript** 中创建一个对象可以使用构造函数语法（通过 `new` 调用的函数通常被称为构造函数）来创建一个新的对象，如下

```js
function Person(name) {
  this.name = name;
}
// 创建一个新对象
var person = new Person('cym');
```

* 这和一般面向对象编程语言中创建对象的语法很类似，但是 `new` 后面跟的不是类，而是构造函数。在面向对象语言中这样创建的对象除了属性一样外，并没有其他的任何联系，对象之间无法共享属性和方法。每当我们新建一个对象时，都会方法和属性分配一块新的内存，这是极大的资源浪费。
* 考虑到这一点，**JavaScript** 的设计者 **Brendan Eich** 决定为构造函数设置一个属性。
* 这个属性指向一个对象，所有实例对象**需要共享的属性和方法**，都放在这个对象里面，那么**不需要共享的属性和方法**就放在构造函数里面。实例一旦被创建，就会自动引用这个对象的属性和方法。
* 实例对象的属性和方法，分为两种，一种是本地的不共享的，一种是引用的共享的，这个对象就是原型对象，简称原型

### 自己的理解

```js
// 关于对象
const obj = {};
// 所有对象都是Object的实例，
obj.__proto__ === Object.prototype;
// 原型链终点
Object.prototype.__proto__ === null;
obj.__proto__.__proto__ === null;

// 关于函数
const bar = function() {};
// 所有的函数都是Function的实例，包括Function本身
bar.__proto__ === Function.prototype;
// Function的原型继承了Object
Function.prototype.__proto__ === Object.prototype;
// 原型链终点
Object.prototype.__proto__ === null;

// Object是由Function构造的
Object.__proto__ === Function.prototype;
// Function也是由Function构造的
Function.__proto__ === Function.prototype;
Function.__proto__.__proto__ === Object.prototype;
Function.prototype.__proto__ === Object.prototype;
Function.__proto__.__proto__ === Function.prototype.__proto__;
// 原型链终点
Object.prototype.__proto__ === null;

// 函数也是对象的实例
Function instanceof Object;
Object instanceof Function;
Function instanceof Function;
```

* 根据上面的代码，我们可以得到一些结论

  * 根据（`obj.__proto__ === Object.prototype`）得出所有的对象都有 `__proto__` 属性
  * 根据（`obj.__proto__ === Object.prototype`）还可以得出所有的对象都是 `Object` 的实例
  * 根据（`bar.__proto__ === Function.prototype`）得出函数也是有 `__proto__` 属性
  * 根据（`Function instanceof Object 和 Function.__proto__.__proto__ === Object.prototype`）得出函数也是对象（js 一切皆对象还是有点道理的），`Function` 也是 `Object` 的实例
  * 而 `prototype` 是函数的属性，对象是没有的，所以说函数也是对象，但是函数却不包括对象，但是可以构造对象
  * 根据（`bar.__proto__ === Function.prototype`）得出，所有的函数都是由 `Function` 构造出来的，所有的函数都是 `Function` 的实例
  * 根据（`Function.__proto__ === Function.prototype`）得出， `Function` 也是 `Function` 的实例，更加证明了上句话
  * 根据（`Object.__proto__ === Function.prototype`）得出，上句话是正确的....
  * 根据（`Function instanceof Object`）得出，函数是对象的实例
  * 根据（`Object instanceof Function`）得出，对象也是函数的实例
  * 总结出来就是这么几句话
    1. 所有的对象都是 `Object` 的实例
    2. 函数也是对象
    3. 所有的函数都是 `Function` 的实例，包括 `Function` 本身，当然也包括 `Object` 这个构造函数
    4. `Object` 也是 `Function` 的实例，`Function` 也是 `Object` 的实例

### 误区

一直以来我都以为 `对象的 __proto__` 和 `函数的 prototype` 属性都指向一个对象

```js
// 比如说
function F() {}
const f = new F();
typeof f.__proto__ === 'object';
typeof F.prototype === 'object';
// f.__proto__ 是一个对象，F.prototype 是一个对象
```

但是今天在群里为群友指点原型相关的知识的时候，有个群友说，`Function.prototype` 是一个函数不是一个对象，然后我才去试了一下才发现我错了

```js
typeof Function.prototype === 'function'; // true
typeof Function.__proto__ === 'function'; // true
typeof Object.__proto__ === 'function'; // true
```

### 经典图

### prototype

* `prototype` 是一个显示原型属性，只有**函数才拥有该属性**，基本上所有函数都有这个属性
* 但是也有例外，下面这种方法创建的函数不会具有 `prototype` 属性

```js
  let fun = Function.prototype.bind
  let fun = Function.prototype.call
  ...
```

* 当我们创建一个函数时，`prototype` 属性就被自动创建了
* `prototype` 这个属性的值是一个对象（也就是一个原型），只有一个属性 `constructor`

```js
function bar() {}
bar.prototype // 是 { constructor: ƒ bar(params) } 
bar.__proto__ === Function.prototype
new bar().__proto__ === bar.prototype
```

### constructor

* *constructor* 是一个公有且不可枚举的属性，一旦我们改变了函数的 *prototype*，那么新对象就没有这个属性了
* 当然可以通过原型链取到 *constructor*
* *constructor* 属性指向了构造自己的构造函数

### **proto**

* \_\_\_proto\_\_\_ 是对象的属性，当然函数也可以访问，指向了 Function.prototype：**f.\_\_proto\_\_ === Function.prototype**
* \_\_\_proto\_\_\_ 指向了**创建该对象的构造函数的原型**
* 不推荐使用 \_\_\_proto\_\_\_ 来获取对象的这个属性，**Es6**提供了 \_Object.getPrototypeOf(tartget-object)\_ 方法
* 因为在 js 中没有类的概念，为了实现类似继承的方式，通过 \_\_\_proto\_\_\_ 将对象和原型联系起来组成了原型链，得以让对象可以访问到不属于自己的属性
* 当我们使用 *new* 操作符时，生成的实例对象就有了 \_\_\_proto\_\_\_ 属性

### new

* *new* 一个函数经历了什么？
  1. 新生成了一个对象
  2. 链接到原型
  3. 绑定 this
  4. 返回一个新对象
* 在调用 *new* 的过程中会发生以上四件事，尝试着分析一下
  * 新生成一个对象，比如我们生成了一个对象 *obj*
  * 连接到原型，我们让 *obj.\_\_proto\_\_ = F.prototype*
  * 绑定 this，然后执行，*F.apply(obj)*
  * 返回一个新的对象，此时 *obj* 对象就是你 *new* 一个函数得到的那个对象
  * 那么我们尝试着实现一个 *new*
  ```js
  function _new() {
    // 创建一个对象
    const obj = {};
    // 获取到我们传入的构造函数，获取arguments的第一项
    const F = [].shift.call(arguments);
    // 连接到原型
    obj.__proto__ = F.prototype;
    // 执行构造函数，绑定this到新对象
    F.apply(obj, arguments);
    // 返回一个对象
    return obj;
  }
  ```

### 总结

* 从图中我们可以发现，所有对象都可以通过原型链最终找到 **Object.prototype**
* **Object.prototype** 是一个对象，但是这个对象却不是 **Object** 创造的，而是引擎自己创建的
* 所以可以这么说：**所有的实例都是对象，但是对象不一定都是实例**
* **Function.prototype** 也是引擎自己创建的。所以 **let fun = Function.prototype.bind** 没有 **prototype** 属性
* 引擎首先创建了 **Object.prototype**，然后创建了 **Function.prototype**，并且通过 **\_\_proto\_\_** 将两者联系了起来
* 所以说：**不是所有的函数都是 new Function() 创造出来的**
* **Function.\_\_proto\_\_ === Function.prototype**
* 所有的构造函数都可以通过原型链找到 **Function.prototype**，并且 **function Function()** 本质上也是一个函数，为了不产生混乱就将 **function Function()** 的 **\_\_proto\_\_** 联系到了 **Function.prototype** 上
* **Object** 是所有对象的父亲，所有对象都可以通过 **\_\_proto\_\_** 找到它
* **Function** 是所有函数的父亲，所有函数都可以通过 **\_\_proto\_\_** 找到它
* **Function.prototype** 和 **Object.prototype** 是两个特殊的对象，他们由引擎来创建
* 除了以上两个特殊对象，其他对象都是通过构造器 **new** 出来的
* 函数的 **prototype** 是一个对象，也就是原型
* 对象的 **\_\_proto\_\_** 指向原型， **\_\_proto\_\_** 将对象和原型连接了起来组合成了原型链

## 继承

### 原型链继承

::: tip 原型链继承
  原型链继承的核心是 `把子类的 prototype 对象的 设置为 父类的实例`
:::

```js {4}
function Parent() {}
function Child() {}
// 继承的关键
Child.prototype = new Parent();
```

**特点和缺点：**

* 父类属性和方法可以被复用（优点）
* 每个实例对 `引用类型属性` 的修改都会被其他的实例共享
  * 不会对父类的属性造成影响，`自身属性或方法与原型链上相同会屏蔽原型链上的属性或方法`
* 每个实例对 `非引用类型属性` 的修改不会影响其他实例
* 子类会丢失自身的 `构造函数`
* 在创建 `Child` 实例的时候，无法向 `Parent` 传参。这样就会使 `Child` 实例没法自定义自己的属性

```js
function Parent() {
  this.name = 'inherit';
  this.colors = ['red', 'green'];
}
Parent.prototype.sayName = function() {
  return this.name;
};
function Child() {}
// 继承的关键
Child.prototype = new Parent();
// 原型链继承会让子类丢失构造函数，所以让构造函数指向自身
Child.prototype.constructor = Child;
const c1 = new Child();
const c2 = new Child();
const p = new Parent();
// 子类修改 引用类型
c1.colors.push('blue');
// 子类修改 非引用类型属性
c1.name = '哈哈哈';
console.log(c1.name, c2.name); // 哈哈哈，inherit
console.log(c1.colors, c2.colors); // ['red', 'green', 'blue']，['red', 'green', 'blue']
// 子类修改引用类型不会对父类造成影响
console.log(p.colors); // ['red', 'green']
console.log(c1.sayName === p.sayName); // true
```

### 借用构造函数

::: tip 借用构造函数
  借用构造函数，也是经典继承，也叫作类式继承，核心是 `在子类中执行父类构造函数，并且绑定this到子类上`，此时就会把父类函数的内容复制了一份到子类。这也是所有继承中唯一用不到 `prototype` 的继承
:::

```js {6}
function Parent(name) {
  this.name = name;
}
function Child(name) {
  // 继承关键
  Parent.call(this, name);
}
```

**特点和缺点：**

* 解决了每个实例对引用类型属性的修改都会被其他的实例共享的问题（优点）
  * 子类之间不会在受对方的影响了
* 子类可以向父类传参（优点）
* 子类不会在丢失自己的构造函数了
* 父类的方法不能复用，每次子类构造实例都得执行一次父类函数（缺点）

```js
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'green'];
}
Parent.prototype.sayName = function() {
  return this.name;
};
function Child(name) {
  Parent.call(this, name);
}
// 子类可以传参
const c1 = new Child('小铭');
const c2 = new Child('小白');
const p = new Parent('父亲');
// 子类修改 引用类型
c1.colors.push('blue');
// 子类修改 非引用类型属性
c1.name = '哈哈哈';
console.log(c1.name, c2.name); // 哈哈哈，小白
console.log(c1.colors, c2.colors); // ['red', 'green', 'blue']，['red', 'green']
console.log(p.colors); // ['red', 'green']
// 父类的方法不能复用了
console.log(c1.sayName()); // Uncaught TypeError: c1.sayName is not a function
```

### 组合继承

::: tip 组合继承
  组合继承，就是融合了原型链继承和借用构造函数两种方法，充分发挥两者的优势
:::

```js
function Parent(name) {
  this.name = name;
}
Parent.prototype.sayName = function() {
  return this.name;
};
function Child(name) {
  // 融合两种继承继承写法
  Parent.call(this, name);
}
// 融合两种继承继承写法
Child.prototype = new Parent();
Child.prototype.constructor = Child;
```

**特点和缺点：**

* 解决了每个实例修改引用类型会影响到其他子类的问题
* 子类可以向父类传参
* 可以实现父类方法的复用
* 需执行两次父类构造函数（缺点）
  * 一是 `Child.prototype = new Parent()`
  * 二是 `Parent.call(this, name)`
  * 造成不必要的浪费

```js
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'green'];
}
Parent.prototype.sayName = function() {
  return this.name;
};
function Child(name) {
  Parent.call(this, name);
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
const c1 = new Child('小铭');
const c2 = new Child('小白');
const p = new Parent('父亲');
// 修改子类的引用属性
c1.colors.push('blue');
console.log(c1.colors, c2.colors); // ['red', 'green', 'blue']，['red', 'green']
console.log(p.colors); // ['red', 'green']
console.log(p.colors === c2.colors); // false
console.log(c1.sayName()); // 小铭
```

### 原型式继承

::: tip 原型式继承
  原型式继承最初由道格拉斯·克罗克福德于 2006 年在一篇题为 《Prototypal Inheritance in JavaScript》(JavaScript 中的原型式继承) 的文章中提出. 他的想法是借助原型可以基于已有的对象创建新对象， 同时还不必因此创建自定义类型&#x20;
  核心：在函数内部先创建一个临时性的构造函数，然后将传入的参数作为这个构造函数的原型，最后返回这个临时构造函数的实例
:::

```js
// 该函数接受一个原型作为参数
function create(o) {
  // 临时性构造函数
  const F = function() {};
  F.prototype = o;
  return new F();
}
```

* 在 **Es5** 中新增了 `Object.create()` 方法规范了原型式继承。
* `Object.create()` 接受两个参数
  * 一是，继承的对象（一般传入一个原型）
  * 二是，拓展的对象（可选）

**特点和缺点：**

* 父类方法可以复用（优点）
* 父类的引用属性会被所有子类所共享，并且子类会修改父类的引用属性（同一个引用地址）
* 子类不能向父类传参

```js
function create(o) {
  const F = function() {};
  F.prototype = o;
  return new F();
}
const parent = {
  name: 'inherit',
  colors: ['red', 'green'],
};
const o1 = create(parent);
// 自己本身没有，那么修改的是原型链上的引用
o1.colors.push('blue');
o1.name = '小铭';
const o2 = create(parent);
console.log(o1, o2); // F {name: "小铭"}，F {}
console.log(o1.colors === o2.colors); // true
console.log(o1.colors === parent.colors); // true
console.log(o1.__proto__.colors === parent.colors); // true
console.log(o1.colors); // ['red', 'green', 'blue']
```

### 寄生式继承

::: tip 寄生式继承
  寄生式继承，也被叫做寄生增强对象，就是在原型继承的基础上，增强对象，返回构造函数
:::

```js {4}
  function createEnhance(o) {
    const obj = Object.create(o)
    // 增强对象
    obj.sayHi = function() { return 'hi }
    return obj
  }
```

* 寄生式继承仅提供一种思路，没什么优点
* 使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。

### 寄生组合继承

::: tip 寄生组合继承
  组合继承的时候，会调用两次父类的构造函数造成浪费，此时寄生组合式继承就完全可以解决这个问题
:::

```js
/**
 * @param {子类构造函数} child
 * @param {父类构造函数} parent
 */
function inheritPrototype(child, parent) {
  // 创建一个临时构造函数
  const F = function() {};
  // 临时类原型对象执向父类的原型对象
  F.prototype = parent.prototype;
  // 子类原型指向 临时类的实例
  child.prototype = new F();
  // 为子类绑定构造函数
  child.prototype.constructor = child;
}
// Es5 写法
function extend(child, parent) {
  child.prototype = Object.create(parent.prototype);
  child.prototype.constructor = child;
}
```

* 这是最成熟的方法，也是现在库实现的方法

### Es6 继承 extends

::: tip Es6 继承
  Es6 继承的结果跟寄生组合继承相似，可以说是寄生组合继承的语法糖。
  但是，寄生组合继承是先创建子类实例对象，然后对其增强；
  Es6 继承是先将父类实例对象的属性和方法，加到 `this` 上面（所以必须先调用 `super` 方法），然后在对子类构造函数修改 `this`
:::

```js
class Parent {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  sayName() {
    return this.name;
  }
}
class Child extends Parent {
  constructor(name, age) {
    // super作为函数来用，相当于构造函数（Parent.call(name)）
    super(name, age);
    // super当做对象来用，相当于此时的this
    console.log(super.sayName()); // '小铭'
    super.sex = 'male';
  }
}

const p = new Parent('父亲', 46);
const c = new Child('小铭', 24);
console.log(c, c.sex); //  Child { name: '小铭', age: 24, sex: 'male' }，'male'
```

### 三大经典继承拓展

* new 运算符的缺点

  * 用构造函数生成的实例对象，有一个缺点，那就是无法共享属性和方法
  * 在 DOG 对象的构造函数中，设置一个实例对象的共有属性 *type*

  ```js
  function DOG(name) {
    this.name = name;
    this.type = '犬科';
  }
  var dogA = new DOG('大毛');
  var dogB = new DOG('二毛');
  // 修改其中一个
  dogB.type = '猫科';
  console.log(dogA, dogB);
  ```

* 因此，有了 *prototype* 属性
  * 所有实例对象要共享的属性和方法，都放到这个 *prototype* 对象里面
  * 那些不需要的共享的属性和方法就放在构造函数里面
  * 实例对象一旦被创建，将自动引用 *prototype* 对象的属性和方法。也就是说，实例对象的属性和方法，分为两种，一种是本地的，一种是引用的
  * 其实就是两个对象共同引用同一个对象，作为自己的共有属性和方法
  ```js
  function DOG(name) {
    this.name = name;
  }
  DOG.prototype = { type: '犬科' };
  var dogA = new DOG('大毛');
  var dogB = new DOG('二毛');
  DOG.prototype.type = '犬科';
  console.log(dogA.type, dogB.type);
  ```

### 原型链继承

* 让子类的原型(*proptype 对象*)指向父类的实例，就实现了原型链继承
* 利用原型让一个引用类型继承另一个引用类型的属性和方法(原型上的属性和方法以及自有属性和方法)
* 拓展一下, 属性分自有数字属性, 原型属性以及静态属性
* 每个构造函数都有一个原型对象, 原型对象包含一个指向构造函数的指针, 而实例都包含一个指向原型对象的内部指针
* 当构造函数的私有属性和原型上的属性同名的时候, 优先访问的是私有属性

```js {10}
function Parent() {
  this.name = '小明';
  this.colors = ['red', 'blue'];
}
function Child() {}
Child.prototype = new Parent();

var c1 = new Child();
c1.colors.push('green');
c1.name = '小白';

var c2 = new Child();
c2.colors = ['a', 'b', 'c', 'd'];
console.log(c2, c1);
```

* 原型链继承会共享父类的属性，所有的子类都会共享一个属性
* 就是说如果你只是拿来使用那么就是共用父类的属性，有一处修改都会发生改变，但是直接修改值类型不会发生改变，因为那就变成自身属性
* 比如说第 10 行修改*name*属性后，其实就是在子类中添加该属性了
* 但是对于对象来说，如果自身拥有那么就会对原型屏蔽，如果自身没有则去查找原型链
* 如果你直接修改父类的属性值，而子类本身没有的话，那么子类所继承的属性都会发生改变
* **缺点**
  1. 重写子类的原型 = 父类的实例, 父类实例的属性变成子类原型的属性, 如果父类包含引用类型的属性, 那么子类所有实例都会共享该属性
  2. 在创建子类实例时，不能向父类的构造函数传递参数
  3. 子类丢失 constructor(让子类原型的 constructor 执行父类)

### 借用构造函数（类式继承）

* 使用 *call* 或 *apply* 方法，将父对象的构造函数绑定到子对象上，就是父对象在子对象内部执行，**this** 指向子对象
* 那不就是子对象上有父对象上的属性和方法了，因为父对象执行的时候，this 执行了子对象

```js {7}
function Parent(name, age) {
  this.name = name;
  this.age = age;
  this.colors = ['red', 'blue'];
}

function Child(name, age) {
  Parent.apply(this, arguments);
}

var c1 = new Child('小明', 24);
var c2 = new Child('小白', 25);
c2.colors.push('green');
console.log(c1, c2);
```

* 如上代码，其实父类执行了一次就是生成了两个属性，父类直接执行的话就是给 *window* 生成了几个属性
* 让父类在子类创建中执行，并且改变其 **this** 为子类 this，那么不就是相当于把父类的拿两句话又写了一遍吗，不就是给子类添加了几个属性嘛
* 这种方法，每次实例化一个对象都是一个独立的对象，他们不会公用属性
* 他是解决了共享问题解决了，每一个属性都是独立的
* 但是我们是基于原型链的，但是我们并没有真正的去利用原型链的共享功能，完全抛弃了它，并且导致每次 *new* 实例的时候，都会去调用父类的构造方法去加到子类的实例上，是完全的 copy paste 过程，这等于舍弃了 js 原型链的精髓部分，这样的代码自然是没有灵魂的~
* **坏处：** 子类不能继承父类原型上的方法, 那么方法就要写在构造函数中, 那么复用代码就无从谈起

### 组合继承

* 将原型链和借用构造函数的技术结合到一起使用, 从而发挥两者之长的一种继承模式.

* 其背后的思路是使用原型链实现对原型属性和方法的继承, 而借用构造函数来实现对实例属性的继承

* 这样既通过在原型上定义方法实现了函数复用, 又能够摆正每个实例都有他自己的属性

* 不要忘了让子类原型的构造函数指向子类的构造函数, 不会还是会丢失

* **优点：** 组合继承解决原型链继承的引用类型原型属性被实例共享问题

* **缺点**

  * 两次调用父类构造函数
  * 子类继承父类的属性, 一类是在子类的实例上, 一类是在子类的原型上(效率低)

* 持续记录中...

---

---
url: /docs/02.服务端/01.linux.md
---

这篇文章涵盖了Linux系统中常见目录、文件管理、搜索、压缩解压等内容。我对其进行了语言优化和排版调整，以提高可读性和流畅性。

## 常见目录

在 `Linux` 中一切皆文件

| 目录      | 作用                                                                                 |
| --------- | ------------------------------------------------------------------------------------ |
| /         | 根目录                                                                               |
| /boot     | 启动目录，存放启动相关文件                                                          |
| /dev      | 设备文件                                                                             |
| /etc      | 配置文件                                                                             |
| /home     | 普通用户的家目录，可供用户操作                                                       |
| /lib      | 系统库文件存放目录                                                             |
| /mnt      | 移动设备挂载目录                                                                      |
| /media    | 光盘挂载目录                                                                          |
| /misc     | 磁带机挂载目录                                                                        |
| /root     | 超级用户家目录，可供用户操作                                                |
| /tmp      | 临时目录，可供用户操作                                                               |
| /proc     | 正在运行的内核信息的映射，主要输出进程信息、内存资源信息和磁盘分区信息等              |
| /sys      | 硬件设备的驱动信息                                                                    |
| /var      | 变量文件存放目录                                                                                 |
| /bin      | 普通的基本命令，如 ls、chmod 等，所有用户都可用                                   |
| /sbin     | 基本的系统命令，如 shutdown、reboot，用于启动系统，修复系统，只有管理员权限才可以运行 |
| /usr      | 系统资源 system resource，后期我们安装的软件都安装在这个文件夹下面                    |
| /usr/bin  | 后期安装的一些软件的运行脚本                                                          |
| /usr/sbin | 放置一些用户安装的系统管理的必备程序                                                  |

## 查看文件

* 在接触Linux系统时，最常用的命令之一是 `ls`，用于查看目录内容。
* `ls` 语法：`ls \[选项\] \[文件或者目录\]`
* `ls` 有很多选项可用：
  * `-a` 显示所有文件，包括隐藏文件（. 开头的文件是隐藏文件）
  * `-l` 显示详细信息
  * `-d` 查看目录本身的属性而不是子文件
  * `-h` 人性化的方式显示文件大小（human）
  * `-i` 显示 inode（i 节点，文件的节点），每个节点

## 文件搜索

### locate

* 在后台数据库中按文件名称搜索，速度比较快
* 数据保存在 `/var/bin/mlocate` 后台数据库中，每天更新一次
* 可以 `updatedb` 命令立即更新数据库
* 只能搜索文件名
* `/etc/updatedb.conf` 建立索引的配置文件
  * PRUNE\_BIND\_MOUNTS = yes 全部生效，开启搜索限制
  * PRUNEFS 不搜索文件系统
  * PRUNENANMES 忽略的文件类型
  * PRUNEPATHS 忽略的路径

### whereis

* 搜索命令所在的路径以及帮助文档所在的位置
* 常用选项：
  * `-b`：只查找可执行文件
  * `-m`：只查找帮助文档

### which

* 查看命令的具体路径，尤其是外部安装的命令
* 无法查看 `shell` 自带的命令，如 `which、cd` 等

### 环境变量

* `/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin` 是系统搜索命令的路径
* 使用 `echo $PATH` 命令可以看到这个路径，多个路径用 `:` 隔开

### find

* 文件搜索命令，用法：`find` \[查找范围] \[搜索范围]

* 注意：`find` 是磁盘搜索，资源消耗大，建议避免大范围搜索

* 可以使用通配符
  * \* 匹配任意内容
  * ? 匹配任意一个字符
  * \[] 匹配任意一个中括号内的字符

* 参数 `-i` 可以做到区分大小写（Linux 是区分大小写的，Windows 不区分大小写）

* 根据大小搜索，`k` 小写，`M` 大写

  | 参数 | 含义    |
  | ---- | ------- |
  | -8k  | 小于 8k |
  | 8k   | 等于 8k |
  | +8k  | 大于 8k |
  | +8M  | 大于 8M |

* 用法还有很多，这些基本够用了，其他的用到在记录吧

```sh
  # 普通用法
  find /root -name 1.txt
  # 通配符用法
  find /root -name *.txt
  find /root -name [cdef12].txt
  # 不区分大小写
  find /root -iname a.txt
  # 按照大小搜索
  find /tmp -size -100k
```

### grep

* 在当前文件中匹配符合条件的字符串，语法 `grep \[option\] '搜寻字符串' 文件名`
* 可以组合使用一些参数
  * `-i` 忽略大小写（ignore）
  * `-v` 排除指定字符串，或者说取反操作
* 与 find 的区别：
  * find：在系统中搜索符合条件的文件名，如果需要匹配，使用通配符匹配
  * grep：在文件中搜索符合条件的字符串，如果需要匹配，使用正则表达式进行匹配

```sh
  grep mlocate install.log
  # 还可以使用管道符
  cat install.log | grep mlocate
```

## 压缩解压缩

### zip 格式

压缩文件或者目录，是一种压缩格式

* 压缩文件 `zip 压缩文件名.zip 源文件`
* 压缩目录 `zip -r 压缩目录名.zip 源文件`
* 解压 `unzip 压缩目录名.zip`

```sh
  # 压缩文件
  zip a.txt.zip a.txt
  # 压缩文件夹
  zip -r book.zip book
  # 解压
  unzip a.txt.zip
```

### gzip 格式

gzip 为高压，可以把文件压缩的更小，对目录压缩是`压缩目录下的所有文件`

| 命令                      | 示例                     | 含义                                                               |
| ------------------------- | ------------------------ | ------------------------------------------------------------------ |
| gzip 源文件               | gzip a.txt               | 压缩为 `.gz` 格式的文件，源文件会消失                              |
| gzip -c 源文件 > 压缩文件 | gzip -c a.txt > a.txt.gz | 压缩为 `.gz` 格式的文件，会保留源文件                              |
| gzip -r 目录              | gzip -r xx               | 把目录下的每个子文件都变成压缩包，并且删除源文件，当前目录没有变化 |
| gzip -d 压缩目录名        | gzip -d a.txt.gz         | 解压文件，不保留压缩包                                             |
| gunzip 压缩文件           | gunzip a.txt.gz          | 解压文件，不保留压缩包                                             |

```sh
# 压缩文件
gzip a.txt
# 压缩文件夹
gzip -r book
# 解压
gzip -dr book
# or，压缩或者解压目录都需要加上 -r 参数
gunzip -r book
```

### bz2 格式

bzip2 是一个压缩能力更强的压缩程序，不过出来的比较晚，所以用的没有 `gzip` 和 `zip` 多，但也不少

注意： `bzip2 不能压缩目录`

| 命令                | 示例               | 含义                                   |
| ------------------- | ------------------ | -------------------------------------- |
| bzip2 源文件        | bzip2 a.txt        | 压缩为 `.bz2` 结尾的文件，不保留源文件 |
| bzip2 -k 源文件     | bzip2 -k a.txt     | 压缩为 `.bz2` 结尾的文件，保留源文件   |
| bzip2 -d 压缩文件名 | bzip2 -d a.txt.bz2 | 解压文件，不保留压缩包                 |
| bunzip2 压缩文件名  | bunzip2 1.txt.bz2  | 解压文件，保留压缩包                   |

### tar

打包命令，只打包不压缩

#### 1. 打包

* 用法：`tar -cvf 打包文件名 源文件`
  * -c 打包
  * -v 显示过程
  * -f 指定打包后的文件名

```sh
  tar -cvf book.tar book
```

#### 2. 解打包

`-c` 是打包， `-x` 是解包，只需要把参数换一下即可

```sh
tar -xvf book.tar
```

### tar.gz 压缩格式

`zip` 可以压缩目录但压缩率不高， `gzip` 和 `bzip2` 压缩效率高但不支持目录压缩

所有可以先打包为 `.tar` 格式，在压缩为 `.gz` 格式

`-z` 压缩为 `.tar.gz` 格式 `-x` 解压缩 `.tar.gz` 格式

| 命令                              | 示例                        | 含义                                       |
| --------------------------------- | --------------------------- | ------------------------------------------ |
| tar -zcvf 压缩包名.tar.gz 源文件  | tar -zcvf book.tar.gz book  | 先打包为 `.tar` 格式，在压缩为 `.gz` 格式  |
| tar -zxvf 压缩包名.tar.gz         | tar -zxvf book.tar.gz       | 解压 `.tar.gz` 压缩包                      |
| tar -jcvf 压缩包名.tar.bz2 源文件 | tar -jcvf book.tar.bz2 book | 先打包为 `.tar` 格式，在压缩为 `.bz2` 格式 |
| tar -jxvf 压缩包名.tar.bz2        | tar -jxvf book.tar.bz2      | 解压 `.tar.bz2` 压缩包                     |

## 关机和重启

### shutdown

* 关机命令，参数后面需要加一个时间
  * `-c` 取消前一个关机命令
  * `-h` 关机
  * `-r` 重启

```sh
  # 设置一个重启时间
  shutdown -r 6:00
  # 取消上一个关机命令
  shutdown -c
```

### init

切换工作模式

* 关机 `init 0`
* 重启 `init 6`

### logout

`logout` 退出登录

## 查看登录用户信息

### w

查看登录用户信息

* USER：登录用户名
* TTY：录的终端 `tty1` 本地 `pts/0` 远程终端
* FROM：登录的 IP
* LOGIN：登录时间
* IDLE：用户闲置时间
* JCPU：该终端所有进程占用的时间
* PCPU：当前进程所占用的时间
* WHAT：正在执行的命令

```sh
[root@localhost ~]# w
 09:51:40 up 7 min,  2 users,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     tty1     -                09:45    6:17   0.01s  0.01s -bash
root     pts/0    192.168.1.105    09:45    0.00s  0.02s  0.00s w
```

### who

查看登录用户信息，比 `w` 显示的少，意思差不多

* USER 登录的用户名
* TTY 登录的终端 `tty1` 本地 `pts/0` 远程终端
* LOGIN 登录时间（登录 IP）

```sh
[root@localhost ~]# who
root     tty1         2020-01-29 09:45
root     pts/0        2020-01-29 09:45 (192.168.1.105)
```

### last

* `last` 查看当前登录和过去登录的用户信息

  * 显示字段分别为：用户名、登录终端、登录 IP、登录时间、退出时间（在线时间）

* `lastlog` 查看所有用户的最后一次登录时间

  * 显示字段分别为：用户名、登录终端、登录 IP、最后一次登录时间

## 磁盘管理

### df

查看磁盘分区使用情况

| 参数 | 描述                      |
| ---- |-------------------------|
| -i   | 仅显示本地磁盘 inode 信息（默认）    |
| -a   | 显示所有文件系统的使用情况           |
| -h   | 以 1024 进制计算最合适的单位显示 |
| -H   | 以 1000 进制计算最合适的单位显示 |
| -T   | 显示磁盘类型                  |
| -t   | 显示指定类型文件系统的磁盘分区         |
| -x   | 不显示指定类型文件系统的磁盘分区        |

### du

统计磁盘上的文件大小

| 参数 | 描述                   |
| ---- | ---------------------- |
| -b   | 以 byte 为单位统计文件 |
| -k   | 以 KB 为单位统计文件   |
| -m   | 以 MB 为单位统计文件   |
| -h   | 以 1024 为单位统计文件 |
| -H   | 以 1000 为单位统计文件 |
| -s   | 统计单个文件           |
|-s	| 统计单个文件 |
|-c	| 统计文件总和 |
|-a	| 显示所有文件 |
|-T	| 显示磁盘类型 |
|-t	| 显示指定类型文件系统 |
|-x	| 不显示指定类型文件系统 |

## 进程管理

* `ps` 查看进程信息。
* 常用选项：
  * -A 显示所有进程
  * -a 显示所有终端相关进程
  * -u 显示用户相关进程
  * -x 显示后台进程

```shell
# 查看所有进程
ps -A
# 查看某个用户的进程
ps -u root
```

### top

* 动态显示进程信息
* 常用选项：
  * q 退出
  * k 终止进程
  * r 重新设定优先级
  * h 查看帮助

### kill

* 终止进程
* 常用选项：
  * -9 强制终止
  * -15 正常终止

## 网络管理

### ifconfig

用于显示或配置网络接口

```sh
# 查看网络接口信息
ifconfig
# 启用网络接口
ifconfig eth0 up
# 禁用网络接口
ifconfig eth0 down
# 配置 IP 地址
ifconfig eth0 192.168.1.100
```

### ping

用于测试网络连接

```
# ping IP 地址
ping 192.168.1.1
# ping 域名
ping chengyuming.cn
```

### netstat

* `netstat` 用于显示网络连接、路由、协议、接口信息
* 常用选项：
  * -a 显示所有连接
  * -t 显示 TCP 连接
  * -u 显示 UDP 连接
  * -n 显示数字地址

### nslookup

用于查找域名的 IP 地址

```shell
nslookup chengyuming.cn
```

## 文件查看和管理

### cat

* `cat` 用于连接文件并打印到标准输出设备上
* 用法：`cat 文件名`，也可以加参数 `-n` 对输出行进行编号

### more

`more` 类似于 `cat` ，但可以进行翻页处理， `空格` 往后翻页， `b` 往前翻页

### head

`head` 用来显示前几行的文字区块

```sh
# 显示 a.txt 中前十行的内容
head -10 a.txt
```

### tail

`head` 显示前几行， `tail` 显示最后几行

* `tail` 有一个常用的参数 `-f` 用于可以查阅正在改变的文件，经常被用作来查看系统日志
  * `-f` 循环读取
  * `-n` 行号，显示文件尾部 `n` 行的内容

```sh
# 查看安装日志
tail -f install.log
```

## vi 编译器

> `vi` 编译器是 `Linux` 中的编译器，类似于 `Windows` 中的记事本， `Vim` 是 `vi` 编译器的升级版，不需要鼠标只用键盘就可以

### 操作模式

三种操作模式：

1. 刚开始打开的时候不能输入东西，写东西写不进去，此时属于命令模式，命令模式是不能直接编辑的；
2. 进入编辑模式有四种方式，输入 `a`、`i`、`o`、`s` 即可进入输入模式（append、insert），`ESC` 键退出编辑模式
3. 在命令模式下，按下 `:` 键进入底行模式，在底行模式下，按两次 `ESC` 键退出底行模式

| 模式名   | 含义                     |
| -------- | ------------------------ |
| 命令模式 | 等待输入的模式           |
| 输入模式 | 编辑模式，用于输入文本   |
| 底行模式 | 可以输入指令、搜索、保存 |

### 打开文件

输入 `vi 文件名` 即可打开文件，默认定位到第一行，也可以输入 `vi +n 文件名` 打开文件定位到第 `n` 行

### 底行模式

| 命令   | 含义                          |
| ------ | ----------------------------- |
| :w     | 把文件写入保存到硬盘中        |
| :q     | 退出当前 vi 编译器打开的文件  |
| :!     | 强制保存                      |
| :n     | 下一个                        |
| : N    | 上一个                        |
| : 数字 | 快速定位到当前文件第几行      |
| /xxx   | 从光标位置开始搜索 xxx 字符串 |
| ?xxx   | 从光标位置开始向前搜索        |

命令可以组合使用，比如 `:q!` 就是强制退出 vi 编译器

### 命令模式

#### 1. 翻页

| 命令     | 含义       |
| -------- | ---------- |
| ctrl + f | 向下翻页   |
| ctrl + b | 向上翻页   |
| ctrl + d | 向下翻半页 |
| ctrl + u | 向上翻半页 |

#### 2. 插入

| 命令 | 含义                         |
| ---- | ---------------------------- |
| i    | 在当前位置插入（insert）     |
| a    | 在当前光标右边插入（append） |
| A    | 在当前光标所在行的行末尾插入 |
| o    | 在光标所在行下面插入新的一行 |
| O    | 在光标所在行上面插入新的一行 |
| s    | 删除当前光标位置的内容并插入 |

#### 3. 删除

* 字符删除

  | 命令 | 含义                                  |
  | ---- | ------------------------------------- |
  | x    | 删除当前字符                          |
  | dw   | 删除一个单词（delete word），包括空格 |
  | de   | 删除一个单词，不包括空格              |
  | d$  | 从当前位置删到行尾                    |

* 行删除

  | 命令 | 含义           |
  | ---- | -------------- |
  | dd   | 删除光标所在行 |
  | 2dd  | 删除光标两行   |

#### 4. 撤销

| 命令     | 含义                           |
| -------- | ------------------------------ |
| u        | 撤销最后一次执行的命令（undo） |
| U        | 恢复该行的原始状态             |
| ctrl + r | 恢复重做命令                   |

#### 5. 剪切

| 命令 | 含义                     |
| ---- | ------------------------ |
| dd   | 删除光标所在行           |
| yy   | 复制所在行               |
| p    | 在光标所在行下方粘贴一行 |
| P    | 在光标所在行上方粘贴一行 |

#### 6. 替换

| 命令 | 含义                        |
| ---- | --------------------------- |
| r    | 替换当前位置字符（replace） |
| cw   | 修改单词（change word）     |
| c$  | 修改当前位置到行尾          |

#### 7. 跳转指定行

| 命令             | 含义                                     |
| ---------------- | ---------------------------------------- |
| ctrl + g         | 显示当前编辑文件中当前光标所在的位置信息 |
| shift + g        | 跳到最后一行                             |
| 数字 + shift + g | 跳转到数字对应的行数                     |

#### 8. 搜索

| 命令       | 含义                                           |
| ---------- | ---------------------------------------------- |
| /          | 输入 / + 字符串 可以在文件中查找包含该字符串的 |
| n          | 查找上一个                                     |
| shift + n  | 查找上一个                                     |
| ?          | 逆向查找字符串                                 |
| shift + %  | 可以将光标移动到匹配的括号上                   |
| shift + $ | 可以将光标移动到行尾                           |

#### 9. 修正错误

| 命令                            | 含义                             |
| ------------------------------- | -------------------------------- |
| :s/老字符/新字符   | 把光标所在行的老字符替换成新字符 |
| :s/老字符/新字符/g | 把所在行的所有老字符替换成新字符 |

## 参考文献

本文章整理自珠峰培训架构课程

---

---
url: /docs/01.前端/03. 工作技巧/mapbox.md
---

> [中文版](https://www.mapbox.cn/mapbox-gl-js/api/#map) [英文版](https://docs.mapbox.com/mapbox-gl-js/api/?q=addlayer\&size=n_10_n)

## 底图渲染

* 初次渲染地图很简单，按照官网的配置
* 我们需要一个地图渲染容器，需要用到 mapbox-gl 库，有时候你可能需要准备一个开发者 token，那我们开始吧
* 首先我们实例化一个 Map 类，在 mapbox-gl 里面有个 Map 类，该类接受一个 options 配置对象作为初始化地图的条件

```js
import mapboxgl from 'mapbox-gl';
const options = {
  container: '底图容器',
  style: '您的底图json',
  // 经度越大越靠左，纬度越大越靠下
  center: [108.5, 38], // 初始化地图的中心点
  zoom: 3.9, // 缩放比例
  bearing: 0, // 地图的初始方位角（旋转度）
  pitch: 0, // 地图的初始倾斜度，按偏离屏幕水平面的度数计量（0-60）
  doubleClickZoom: false, // 取消双击缩放
  dragRotate: false, // 取消地图旋转
};
const map = new mapboxgl.Map(options);
```

## 添加控制器

* 实例 map 的方法，map.addControl()
* 接受两个参数，**要添加的控制器** 和 **添加的位置** *('top-left' , 'top-right' , 'bottom-left' , and 'bottom-right' 。默认为 'top-right' )*

```js
  // 添加地图导航空间（放大缩小）
  map.addControl(new mapboxgl.NavigationControl(), 'top-left');
  // 添加比例尺
  const scale = new mapboxgl.ScaleControl({
    maxWidth: 80,
    unit: 'imperial'
  })
  map.addControl(scale)
  scale.setUnit('metric')
  ...
```

## 添加/移除标记

* 在 mapbox-gl 类中有 Marker 类，专门用来处理标记
* 该类接受两个参数，element 和 options
* 只是添加一个标记，但是添加到哪就需要你来设置了
* 移除标记就是移除该类的实例

```js
// 全局可修改的marker
let marker = null;
function addMarker(LngLat, el, options) {
  if (marker) {
    marker.remove();
  }
  marker = new mapboxgl.Marker(el, options).setLngLat(LngLat).addTo(map);
}
```

## 地图移动

### flyTo 地图飞行

* 对地图中心、缩放级别、方位角和倾斜度做任意组合改变， 使其沿着一条曲线动态地变化并引发飞行效果。 该动态转换能够无缝引入缩放和平移，使用户即使在穿越了很长的距离后也能保持方位角不变
* 接收两个参数， **options**和**传递的其他属性**
* **options.curve** \[number] (default 1.42)：缩放曲线效果
* **options.speed** \[number] (default 1.2)：飞行速度
* **options.center** ：飞行后的中心点，类似于初始化地图的 center
* **options.zoom** ：飞行后缩放级别

```js
map.flyTo({
  center: [108.5, 38],
  zoom: 10,
  speed: 5,
  curve: 1,
  easing(t) {
    return t;
  },
});
```

### jumpTo 跳跃

* 地图移动的方法之一
* 参数和 flyTo 一样，**options**和**传递的其他属性**
* **options.center** (LngLatLike) : 目的地中心。
* **options.zoom** (number) : 目的地的缩放级别。
* **options.bearing** (number) : 目的地的方位角（bearing，rotation），按照逆时针偏离正北方的度数计算。
* **options.pitch** (number) : 目的地的倾斜度（pitch，tilt），单位为度。
* **options.around** (LngLatLike) : zoom 指定之后， around 将决定缩放中心（默认为地图中心）。

### easeTo 动态转换

* 地图移动的方法之一，参数同上

## Layer 和 Source

* Layer 是图层，Source 是数据源
* Layer 和 Source 需要相辅相成，一个负责界面呈现，一个是数据
* Source 支持：vector、raster、geojson、image、video。
  * geojson 处理各种矢量类型，包括集合
  * vector 主要解决矢量瓦片
  * raster 解决目前常用的栅格化瓦片
  * video 的加入使得功能更加的现代化
  * mapbox 在 style 里面，为 source 定义了一个 type 属性，来说明这些类型。
* Layer 分为：background、fill、line、symbol、raster、circle，除了 background 类型的 layer 不需要绑定 source 之外。其他的都需要有 source。
  * fill 只负责填充
  * line 只负责线条
  * symbol 处理 sprite 图，文字等
  * raster 只负责图片
  * circle 负责点
  * Filter 设置展示的过滤条件，定制化显示

### 添加/删除 Layer

* 有这么一个需求，我输入一个经纬度或者一个别的什么条件来查到这个点在地图上的位置，并且根据这个区域的 admincode 或者别的什么条件圈出该区逇范围

* 如下图，左边是效果，右边是该区域的数据，原地图是没有那个紫色的边框的，我们要查出来后给该区域添加上

* 那么我么需要用到 addLayer 方法，添加 layer，但是我们需要获取到底图的数据

* queryRenderedFeatures()，查询渲染后的功能信息，该返回一个 GeoJSON Feature Object 数据，表明满足查询参数的可见要素。[传送门](https://www.mapbox.cn/mapbox-gl-js/api/#map#queryrenderedfeatures)

* 我们使用该方法传递 layerId，获取到我们要的数据

* 开始添加 layer，map.addLayer() 接收一个配置对象，配置对象规则如下
  * 样式的 layer 属性将列出该样式中所有可用的图层。图层类型由 *type* 属性规定，且指定方式必须为 background, fill, line, symbol, raster, circle, fill-extrusion
  * 除了 background 类型的图层，其它每一个图层都需要参考一个数据源。 图层从数据源获取数据，选择性地筛选要素，然后定义为这些要素添加样式的方式。
  * 具体信息查看 [这里](https://www.mapbox.cn/mapbox-gl-js/style-spec/#layers)

* 我们的代码最终如下

```js
  drawLine(admincode) {
    // 添加前先删除之前的
    let _layer = map.getLayer('data_town_polygon')
    if (_layer) {
      map.removeLayer(_layer.id)
      map.removeSource(_layer.source)
    }
    const layer = {
      // 唯一ID，不可重复
      id: 'data_town_polygon',
      // 我们是画线，所以选择line
      type: 'line',
      source: {
        type: 'vector',
        tiles: ['http://10.125.214.22:8080/data/town/{z}/{x}/{y}.pbf']
      },
      'source-layer': 'town_polygon',
      'layout':{
        visibility:'visible'
      },
      // 定义layer的样式规则
      'paint': {
        'line-color': '#4D2EA5',
        'line-width': 5,
        'line-opacity': [
          'case',
          ['boolean', ['feature-state', 'hover'], false],
          1, 0.6
        ]
      },
      // 定义过滤条件，这里是传递过来的admincode
      filter: ['==', 'admincode', admincode]
    }
    map.addLayer(layer)
  }
```

## 地图事件

### on -> load 事件

* 该事件一般用作地图渲染完毕处理一些事情

### on -> click 事件

* 鼠标单击事件，对原生的 click 做了很好的封装
* 比如说我们可以，获取到经纬度，点信息，我们可以根据点信息获取 feature 信息

```js
// 截取一段根据事件对象获取到的点信息来画地图
this.map.on('click', async (ev: any) => {
  if (this.isMouseGet) {
    const features: any[] = this.map.queryRenderedFeatures(ev.point);
    console.log(features, 'sss');
    if (!features.length) return this.$message.warning('未获取到该区域的数据');
    await this.drawLine(features[0].properties['admin_code']);
    const areaInfo: any = {};
    Object.entries(features[0].properties).forEach((item: any) => {
      areaInfo[toHump(item[0])] = item[1];
    });
    this.info = areaInfo;
    // @ts-ignore
    this.$refs.dialog.handleDialogOpen(this.info);
  }
});
```

### 改变鼠标手型

* *map* 的实例有个 *getCanvas()* 方法可以获取到 *canvas* 地图上的 *canvas* 元素
* 此时我们可以调用它的 *style.cursor* 为其赋值，便可以改变地图上的鼠标手型

```js
this.map.getCanvas().style.cursor = 'pointer';
```

* 关于鼠标手型，可以看下[这里](http://www.hangge.com/blog/cache/detail_2065.html)，这里列出来所有的鼠标手型以及长什么样子

---

---
url: /docs/02.服务端/02.mysql.md
---

## 数据库操作

> 进入数据库之后，我们要先看看我们都有哪些数据库，然后要使用哪个数据库，数据库有哪些表，要对哪些表做一些操作之类，这里记录下基本操作，数据库操作结尾一定要加分号，表示一句话的结束。

### 基本操作

```sql
  -- 创建数据库
  CREATE database_name;
  -- 查看数据库信息
  SHOW CREATE DATABASE database_name;
  -- 设置为 utf-8 格式的
  SET names utf8;
  -- 查看数据库
  SHOW DATABASES;
  -- 使用数据库，use 数据库名
  USE database_name;
  -- 创建表
  CREATE TABLE table_name (
    id    int(10),
    name  varchar(20),
    age   int(10)
  );
  -- 查看该数据库下所有的表
  SHOW TABLES;
  -- 查看表信息
  SHOW CREATE TABLE table_name;
  -- 修改表名
  ALTER TABLE table_name RENAME TO table_name_1;
  -- 不加 to 关键字也可以
  ALTER TABLE table_name_1 RENAME table_name;
  -- 查看字段信息
  DESC table_name;
  -- 添加字段，对字段操作需要加字段类型
  ALTER TABLE table_name ADD field_name INT;
  -- 修改字段名，以及字段类型
  ALTER TABLE table_name CHANGE field_name field_name_1 VARCHAR(255);
  -- 删除字段
  ALTER TABLE table_name DROP field_name_1;
  -- 删除表
  DROP TABLE table_name;
  -- 删除数据库
  DROP DATABASE database_name;
```

### 导出数据

导出数据不需要进去数据，直接在数据库外执行命令即可

```sh
  # 导出数据，mysqldump -uroot -p 数据库名 > 导出到的位置
  mysqldump -uroot -p database_name > database_name.sql
  # 敲回车会提示你输入密码
```

### 导入数据

导入数据需要进入数据库，然后创建对应的数据库，并且设置其 `name`

```sql
  -- 创建对应的数据库
  CREATE DATABASE database_name;
  -- 设置其 name 属性
  SET NAMES utf8;
  -- 使用数据库
  USE database_name;
  -- 导入数据，source 导入的SQL文件地址
  source /root/database_name.sql;
  -- 或者直接进入 SQL 文件，全部复制，然后数据库中直接粘贴也是可以的
  -- 再或者在 SQL 外面执行以下命令也可以 mysql -u用户名 -p密码 数据库名 < 数据库名.sql
  mysql -uroot -p database_name < database_name.sql
```

## 数据操作

### insert 语句

* 基本语法一：**INSERT INTO table\_name VALUES (value1, value2, ....)**，这种语法需要与表中的字段一一对应上，按顺序插入的
* 基本语法二：**INSERT INTO table\_name (column\_name1, column\_name2,...) VALUES (value1, value2, ....)**，这种语法只需要前后对应上就可以

```sql
  INSERT INTO `user` (username, sex) VALUES ('insert', 1)
```

### delete 语句

* 基本语法：**DELETE FROM table\_name WHERE some\_column=some\_value**
* 一般我们不会真正删除数据库里的数据，我们会有一个假删的动作，就是给数据一个状态，然后删除就是改变它的状态，比如说加个**is\_del**字段

```sql
  DELETE from `user` WHERE username='insert' AND sex='1'
```

### update 语句

* 基本语法：**UPDATE table\_name SET column1=value1,column2=value2,... WHERE some\_column=some\_value;**

```sql
  -- 更新 head_pic 字段值为 没有图片，在条件为 username='cym' 和 sex='1'
  UPDATE `user` SET head_pic='没有图片' WHERE username='cym' AND sex='1'
```

### select 查询语句

* 基本语法：**SELECT column\_name, column\_name, ... FROM table\_name \[WHERE column\_name=value AND column\_name=value ...]**

```sql
-- 基本写法
  SELECT realname, username FROM `user`
  SELECT * FROM `user`
  SELECT * FROM `user` WHERE realname='小铭' AND username='cym'
```

* 查询总条数：**SELECT COUNT(expr) FROM table\_name**
* SELECT COUNT()语句返回一个字段，默认是 COUNT(你传入的字段)，你可以加个 as 一个变量，让他把返回的值返回到你提供的变量里面
* 当然后面也可以传递条件跟基本语法一样

```sql
  -- 查询总条数
  SELECT COUNT(id) FROM `user`
  SELECT COUNT(id) AS total FROM `user`
  SELECT COUNT(*) AS total FROM `user`
```

* 根据一个范围查询：根据时间范围查询也是一个条件，所以也放在*WHERE*子句后面，多个查询条件*AND*分隔
* 语法：**BETWEEN a AND b，在范围 a 和 b 之间，查询，a 需要小于 b**

```sql
  -- 根据时间范围查询
  SELECT COUNT(*) AS total FROM `daily` WHERE create_time BETWEEN '2019-07-05 20:57:40' AND '2019-07-10 22:22:56'
  SELECT * FROM `daily` WHERE create_time BETWEEN '2019-07-05 20:57:40' AND '2019-07-13 22:28:56' AND username='guest'
```

* 查询限制，分页查询：**LIMIT from size**
* limit 之后紧跟两个值，从第几条开始，查询几条

```sql
  -- 从第5条开始查询2条数据
  SELECT * FROM `daily` LIMIT 5, 2
```

* 查询后排序：**ORDER BY column\_name \[desc]**
* 加上 **desc** 是倒序

```sql
  SELECT * FROM `daily` ORDER BY create_time DESC
  SELECT * FROM `daily` ORDER BY create_time LIMIT 5, 2
  -- 注意他们的顺序，limit永远在最后面，where永远在前面
  SELECT * FROM `daily` WHERE username='cym' ORDER BY create_time DESC LIMIT 5, 2
```

* 查询完整语法规则：**select \[distinct] 字段 1 \[as 别名], ..., 字段 n \[as 别名] from \[库名.]表名
  \[
  where 约束条件
  group by 分组依据
  having 过滤条件
  order by 排序的字段
  limit 限制显示的条数
  ];**
  * 查表中所有字段用 \_ 表示 *(select \_ from ...)*
  * 条件的书写规则严格按照语法顺序书写，可以缺省，但不可以错序
  * 约束条件的流程：*from -> where -> group by -> having -> distinct -> order by -> limit*
  * 字段可以起别名
  * 字段可以直接做运算 *select age + 1 'new\_age' from emp;*
  * 分组后的条件均可以使用聚合函数

### select 语句拓展

* 模糊查询语法：**like '%关键字%'**，like 后面跟着模糊查询条件，关键字写在 **%%** 中

```sql
  SELECT *  FROM `user` WHERE `user`.realname LIKE '%程%'
  SELECT *  FROM `user` WHERE username LIKE '%c%'
```

* 显示 null 值：**column\_name is null**

```sql
  -- 只查看realname是null的
  SELECT * FROM `user` WHERE realname IS NULL
  -- realname根据输入的任意字符模糊查询，也可以是null
  SELECT * FROM `user` WHERE realname LIKE '%%' OR realname IS NULL
  -- 同一个级别的语句要括起来
  SELECT * FROM `user` WHERE `username` LIKE '%%' AND (`realname` LIKE '%%' OR `realname` IS NULL) ORDER BY create_time desc LIMIT 0, 10
```

* 查询当天、昨天、近一周、近 30 天、本月、上月数据
  * 在**mysql**中有**TO\_DAYS(date)**&#x51FD;数，接受一个日期，返回一个天数，从公元 0 年到现在的天数
  * NOW()返回当前的时间
  * 根据这个我们可以拓展一下返回一个时间范围内的数据，看下面的例子

```sql
  -- @return { days: 737641 }，也就是从公元0年到今天（2019-08-05）过去的天数是 737641 天
  SELECT TO_DAYS(NOW()) AS days;
  -- @return { curTime: 2019-08-05 22:18:07 }
  SELECT NOW() AS curTime;
  -- @return { curYear: 2019.551 }
  SELECT TO_DAYS(NOW()) / 365.25 AS curYear;
  -- @return { tenDaysAgo: 737631 }，返回十天前的时间，比
  SELECT TO_DAYS(NOW()) - 10 AS tenDaysAgo;
  -- 接下来放到业务里面实践下
  -- 返回近一周的 list 集合
  SELECT * FROM `daily` WHERE TO_DAYS(create_time) >= (TO_DAYS(NOW()) - 7);
  -- 也可以这么写
  SELECT * FROM `daily` WHERE DATE_SUB(CURDATE(), INTERVAL 7 DAY) <= DATE(create_time);
  -- 近30天
  SELECT * FROM `dayly` WHERE DATE_SUB(CURDATE(), INTERVAL 30 DAY) <= DATE(create_time);
  -- 近一个月，date_format() 接受两个参数，格式化的时间和格式
  SELECT * FROM `daily` WHERE DATE_FORMAT(create_time, '%Y%m') = DATE_FORMAT(CURDATE(), '%Y%m');
  -- 上个月，period_diff() 时间差异函数接受两个参数，要对比的时间
  SELECT * FROM `daily` WHERE PERIOD_DIFF(DATE_FORMAT(NOW(), '%Y%m'), DATE_FORMAT(create_time, '%Y%m')) = 1;
```

---

---
url: /docs/02.服务端/Nginx 相关/nginx.md
---

## 安装

* 安装就暂时略过了，记录一下配置

## 常用命令

* 做了软链接或者配置了 nginx 的环境变量可以用以下语法，没有话就需要指定到 nginx 所在的目录
* **nginx -s stop** 停止 nginx
* **nginx -s quit** 退出 nginx
* **nginx -s reload** 重新加载配置（修改配置文件后）
* **nginx -s reopen** 重启 nginx
* **nginx -v** 查看版本
* **nginx -t** 查看配置文件目录，检测配置文件是否有语法错误，然后退出

## nginx.conf 配置文件

::: tip
Nginx 配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL 匹配特定位置后的设置），每部分包含若干个指令。main 部分设置的指令将影响其它所有部分的设置；server 部分的指令主要用于指定虚拟主机域名、IP 和端口；upstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location 部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。他们之间的关系式：server 继承 main，location 继承 server；upstream 既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。
:::

## main 全局配置

> nginx 在运行时与具体业务（比如 http 服务或者 email 服务代理）无关的参数，比如工作进程数、运行身份等

### woker\_processes

* 在配置文件的顶级*main*部分，worker 角色的工作进程的个数，master 进程是接收并分配请求给 worker 处理。这个数据简单一点可以设置为 CPU 的核数 *grep ^processor /proc/cpuinfo | wc -l*，也是*auto*值。如果开启了 ssl 和 gzip 更应该设置成与逻辑 CPU 数量一样甚至为 2 倍，可以减少 I/O 操作，如果 nginx 服务器还有其他服务，可以适当减少。

### worker\_cpu\_affinity

* 也是写在 main 部分。在高并发情况下，通过设置 cpu 粘性来降低由于多 CPU 核切换造成的寄存器等现场重建带来的性能损耗。如*worker\_cpu\_affinity 0001 0010 0100 1000*; （四核）。

### worker\_connections 2048

* 在 **events** 部分。每一个 worker 进程能并发处理（发起）的最大连接数（包括与客户端或后端被代理服务器间等所有的连接数）。
* nginx 作为反向代理服务器，计算公式 \_最大连接数 = worker\_processes \_ worker\_connections / 4\*，所以这里客户端最大连接数是 1024，这个可以增加到 8192 都没关系，但是不能超过后面的 \*worker\_rlimit\_nofile\*。
* 当 nginx 作为 http 服务器时，计算公式都除以 2

### worker\_rlimit\_nofile 10240

* 写在 main 部分。默认是没有设置，可以限制为操作系统最大的限制 65535。

### use epoll

* 写在 events 部分。在 Linux 操作系统下，nginx 默认使用 epoll 事件模型，得益于此，nginx 在 Linux 操作系统下效率相当高。同时 Nginx 在 OpenBSD 或 FreeBSD 操作系统上采用类似于 epoll 的高效事件模型 kqueue。在操作系统不支持这些高效模型时才使用 select。

## http 服务器

> 与提供 http 服务相关的一些配置参数。例如：是否使用*keeplive*，是否使用*gzip*进行压缩等

### sendfile on

* 开启高效的文件传输模式，sendfile 指令指定 nginx 是否调用 sendfile 函数来传输文件，减少用户空间到内核空间的上下文切换。
* 对于普通应用设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，减低系统的负载

### keeplive\_timeout 65

* 长连接超时时间，单位是秒。
* 这个参数很敏感，涉及浏览器的种类、后端服务器的超时设置、操作系统的设置，可以另外起一片文章了。长连接请求大量小文件的时候，可以减少重建连接的开销，但假如有大文件上传，65s 内没上传完成会导致失败。如果设置时间过长，用户又多，长时间保持连接会占用大量资源。

### send\_timeout

* 用于指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx 将会关闭连接。

### client\_max\_body\_size 10m

* 允许客户端请求的最大单文件字节数。如果有上传较大文件，请设置它的限制值

### client\_body\_buffer\_size 128k

* 缓冲区代理缓冲用户端请求的最大字节数

### 模块 http\_proxy

> 这个模块实现的是 nginx 作为反向代理服务器的功能，包括缓存功能（[传送门](http://seanlook.com/2015/06/02/nginx-cache-check/)）

* *proxy\_connect\_timeout 60*

  * nginx 跟后端服务器连接超时时间(代理连接超时)

* *proxy\_read\_timeout 60*

  * 连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时)

* *proxy\_buffer\_size 4k*

  * 设置代理服务器（nginx）从后端 realserver 读取并保存用户头信息的缓冲区大小，默认与 proxy\_buffers 大小相同，其实可以将这个指令值设的小一点

* *proxy\_buffers 4 32k*

  * proxy\_buffers 缓冲区，nginx 针对单个连接缓存来自后端 realserver 的响应，网页平均在 32k 以下的话，这样设置

* *proxy\_busy\_buffers\_size 64k*

  * 高负荷下缓冲大小（proxy\_buffers\*2）

* *proxy\_max\_temp\_file\_size*

  * 当 proxy\_buffers 放不下后端服务器的响应内容时，会将一部分保存到硬盘的临时文件中，这个值用来设置最大临时文件大小，默认 1024M，它与 proxy\_cache 没有关系。大于这个值，将从 upstream 服务器传回。设置为 0 禁用。

* *proxy\_temp\_file\_write\_size 64k*

  * 当缓存被代理的服务器响应到临时文件时，这个选项限制每次写临时文件的大小。proxy\_temp\_path（可以在编译的时候）指定写到哪那个目录。

* *proxy\_pass，proxy\_redirect* 见 [location](#location) 部分。

### 模块 http\_gzip

* gzip on：开启 gzip 压缩输出，减少网络传输。
  * **gzip\_min\_length 1k**：设置允许压缩的页面最小字节数，页面字节数从 header 头得 content-length 中进行获取。默认值是 20。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大。
  * **gzip\_buffers 4 16k**：设置系统获取几个单位的缓存用于存储 gzip 的压缩结果数据流。4 16k 代表以 16k 为单位，安装原始数据大小以 16k 为单位的 4 倍申请内存。
  * **gzip\_http\_version 1.0**：用于识别 http 协议的版本，早期的浏览器不支持 Gzip 压缩，用户就会看到乱码，所以为了支持前期版本加上了这个选项，如果你用了 Nginx 的反向代理并期望也启用 Gzip 压缩的话，由于末端通信是 http/1.0，故请设置为 1.0。
  * **gzip\_comp\_level 6**：gzip 压缩比，1 压缩比最小处理速度最快，9 压缩比最大但处理速度最慢(传输快但比较消耗 cpu)
  * **gzip\_types** ：匹配 mime 类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。
  * **gzip\_proxied any**：Nginx 作为反向代理的时候启用，决定开启或者关闭后端服务器返回的结果是否压缩，匹配的前提是后端服务器必须要返回包含”Via”的 header 头。
  * **gzip\_vary on**：和 http 头有关系，会在响应头加个 Vary: Accept-Encoding ，可以让前端的缓存服务器缓存经过 gzip 压缩的页面，例如，用 Squid 缓存经过 Nginx 压缩的数据。

## server 虚拟主机

::: tip
http 服务上支持若干个虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务代理时，也可以建立多个 server。每个 server 通过监听地址或端口来区分
:::

### listen

* 监听端口，默认 80，小于 1024 的要以 root 启动。可以为 listen \*:80、listen 127.0.0.1:80 形式。

### server\_name

* 服务器名，如 localhost、www.example.com，可以通过正则匹配

### 模块 http\_stream

* 这个模块通过一个简单的调度算法来实现客户端 IP 到后端服务器的负载均衡，upstream 后接负载均衡器的名字，后端 realserver 以 host:port options; 方式组织在 {} 中。如果后端被代理的只有一台，也可以直接写在 proxy\_pass 。

## location

> http 服务中，某些特定的 URL 对应的一系列配置项。

### root

* root /root/project/main;
* 定义服务器的默认网站根目录位置。如果 **location** URL 配置的是子目录或文件，root 没什么作用，一般放在*server*指令里面或者 / 下
* 也可以写成**alias**，来匹配，alias /root/cym/project/daily-admin/，但是 location / 不可以写成 alias，否则会是 403

### index;

* index index.html index.htm;
* 定义路径下默认访问的文件名

### proxy\_pass

* proxy\_pass http://127.0.0.1:3000/api/;

* 请求转向 *http://127.0.0.1:3000/api/*，即反向代理，对应*upstream*负载均衡器

* proxy\_pass http://wanfangdata.com.cn/;

* 访问代理到 *http://wanfangdata.com.cn/* 网站

* 关于 location 匹配规则的写法，可以说尤为关键且基础的，参考文章 [nginx 配置 location 总结及 rewrite 规则写法](http://seanlook.com/2015/05/17/nginx-location-rewrite/);

* [本文章参考 *seanlook* 的笔记](http://seanlook.com/2015/05/17/nginx-install-and-config/)

---

---
url: /docs/02.服务端/node/process-undone.md
---

## 进程对象属性

| 属性       | 说明                                         |
|----------|--------------------------------------------|
| execPath | 可执行文件的绝对路径，如 `/usr/local/bin/node`         |
| version  | 版本号                                        |
| versions | 依赖库的版本号                                    |
| platform | 运行平台 darwin(Mac)、freebsd、linux、sunos、win32 |
| stdin    | 标准输入流可读流，默认暂停状态                            |
| stdout   | 标准输出流可写流，同步操作                              |
| stderr   | 错误输出可写流，同步操作                               |
| argv     | 命令行参数，属性为数组                                |
| env      | 操作系统的环境信息                                  |
| pid      | 应用程序的进程 id                                 |
| title    | 窗口标题                                       |
| arch     | 处理器架构 arm ia32 x64                         |

## 方法

### memoryUsage

查看内存的使用情况，会返回一个对象，node v8 引擎内存使用量是有上限的，32 位最多是 0.7G；64 位最多使用 1.7G

* rss（resident set size）：所有内存占用，包括指令区和堆栈
* heapTotal：堆占用的内存，包括用到的和未用到的
* heapUsed：用到堆的部分
* external：v8 引擎内部的 C++ 占用的内存（buffer 是单独分配的，属于 external 内存）

### nextTick

用于将一个函数推迟到代码所书写的下一个同步方法执行完毕或者异步方法的回调函数开始执行前调用

### chdir

chdir 用于修改 node 应用程序中使用的当前工作目录，使用方法： `process.chdir(directory)`

### cwd

返回当前目录

### exit

退出 node 应用程序的进程

### kill

用于向进程发送一个信号

* SIGINT 程序终止（interrupt）信号，在用户输入 INTR 字符（Ctrl + c）时发出，用户通知前台进程组终止进程
* SIGTERM 程序结束（terminate）信号，该信号可以被阻塞和处理，通常用来要求程序自己正常退出，shell 命令 kill 缺省产生这个信号

用法： `process.kill(pid, [signal])`

* pid 是进程 id，整数类型
* signal 发送的信号，默认是 SIGTERM

### uptime

返回当前程序的运行时间

### hrtime

测试一个代码段的运行时间，返回两个时间，第一个单位是秒，第二个是纳秒，类似于 `console.timeEnd`

```js
const time = process.hrtime();
let num = 0;
while (num <= 10000000000) {
  num++;
}
const diff = process.hrtime(time);

console.log(`该程序执行耗时 %d 秒`, diff[0]);
```

### exit 事件

当 node 程序退出时会触发进程对象的 exit 事件，可以通过指定事件回调来指定进程退出时所执行的处理

```js
process.on('exit', () => console.log('node 程序退出了'));
process.exit();
```

### uncaughtException 事件

当应用程序抛出一个未被捕获的异常时触发进程对象的 `uncaughtException` 事件，一般不用

## 子进程

> 在 node 中，只有一个线程执行所有操作，如果某个操作需要大量消耗 CPU 资源的情况下，后续操作都要等待&#x20;
> 所以在 node 中提供了一个 `child_process` 模块，通过他可以开启多个子进程，在多个子进程之间可以共享内存空间，可以通过子进程的互相通信来实现信息的交换

### spawn

#### 语法

```sh
child_process.spawn(command, [args], [options])
```

* command：必须指定的参数，指定需要执行的命令
* args：数组，存放了所有运行该命令需要的参数
* options：对象，用于指定开启子进程时使用的选项

### fork 开启子进程

---

---
url: /docs/02.服务端/redis.md
---

## 安装

* 官网有 Linux 的详细教程，安装省略，记录一下基本配置以及基础用法

## 简介

> Redis 是一个开源的，内存数据结构存储，用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA 脚本（Lua scripting）， LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。（摘自 Redis 官网）

* **Redis** 是 `ket-value` 数据库。效率快，但功能单一；
* 常用做集中式会话管理（部署了负载均衡的服务之后，可用作 **redis** 来存储 *session*，可保证 *session* 不用换一个服务请求一次）
* 用作缓存服务器（**Redis** 读取特别快：SET 操作每秒钟 110000 次，GET 操作每秒钟 81000 次。）

## 基本命令

```sh
  # 启动redis，window启动方式
  redis-server redis.window.conf
  # Linux启动
  redis-server
  # 启动客户端
  redis-cli
```

### 客户端命令

> 执行了 `redis-cli` 之后的命令

### 修改配置，查看某个配置

> 以下命令推荐使用大写，便于区分变量和命令

* 可用到 `config get | set configName`

```sh
  # 查看端口的配置
  config get port
  # 强制关闭Redis快照导致不能持久化。
  config set stop-writes-on-bgsave-error no
```

### 设置值

* `get、set` 命令设置值，语法 `set kyeName value | get keyName`

```sh
  # 设置成功会返回 ok
  set name chengyuming
  # 获取成功会返回之前设置的值，若没有设置过，则返回 (nil)
  get name
```

* `del` 删除值

```sh
  set testKey chengyuming
  del testKey     # 返回 1，则删除成功，返回 0，删除失败
```

* `getrange` 命令获取值的范围，语法 `getrange keyName start end`

```sh
  # 获取全部是从 0 到 -1，返回 chengyuming，所以是从0开始
  getrange name 0 -1
```

* `incr|incrby、decr|decrby` 递增递减命令，语法：`incr keyName | incrby keyName number`

```sh
  # 递增递减，只对number类型的数据有效
  set age 9
  # 递增
  incr age      # 返回 10
  incrby age 2  # 返回 12
  # 递减
  decr age      # 返回 11
  decrby age 5  # 返回 6
```

* `type keyName` 查看变量类型

```sh
  type name     # string
```

### 设置过期时间

> 设置了过期时间后，变量会到期自动删除，这也是 redis 作为缓存数据库的一个优势，设置很简单只需要加 **expire** 就行

* `expire kyeName expireTime` 设置过期时间，单位秒
* 请求数据的时候先查看 **redis** 是否保存有数据，如果有则读取 **redis** 数据，没有则为 **redis** 存储数据，并且设置过期时间

```sh
  # 设置 name 30秒之后过期
  expire name 30      # 设置成功返回 1，失败返回 0，redis返回的 1 代表成功，0 代表失败
```

### 哈希值

> 一个字符串类型的 key 和 value 的映射表，特别适合用于存储对象，语法也很简单，就是在 get 之前加一个 h，hget

* 设置哈希值`hset | hmset` ，语法：`hset obj keyName value | hset obj key1 value1 key2 value2 ...`

```sh
  # 设置单个哈希值
  hset person1 name chengyuming
  hset person1 age 24
  hset person1 sex 1
  # 设置多个哈希值
  hset person2 name chengyuming age 24 sex 1
```

* 获取哈希值删除哈希值也差不多

```sh
  # 获取单个哈希值
  hget person1 name
  hget person1 age
  hget person1 sex
  # 获取多个哈希值
  hmget person1 name age
  # 获取所有值
  hgetall person2     # 返回 "name" "chengyuming" "age" "24" "sex" "1"
  # 删除哈希值
  hdel person name
```

* 获取所有的 **key**，`hkeys objName`

```sh
  # 获取所有的 key
  hkeys person1
```

### list 基本操作

* `lpush` 命令，语法：`lpush listName value` ，从左边添加一个值
* `rpush` 命令，语法：`rpush listName value` ，从右边添加一个值
* `lpop` 命令，语法：`lpop listName` ，从左边弹出一个值
* `rpop` 命令，语法：`rpop listName` ，从右边弹出一个值
* `lrange` 命令，语法：`lrange listName start end` ，查看 list 的在 start 与 end 范围内的值
* `lindex` 命令，语法：`lindex listName index` ，查看 list 索引为 index 的值
* `llen` 命令，语法：`llen listName` ，查看 list 的长度
* `lrem` 命令，语法：`lrem listName length item` ，从左边开始删除几个删除谁，如果 length 是负数则从右边开始删除

```sh
  # 添加值，返回添加后的length长度
  lpush ids 2
  lpush ids 1
  rpush ids 3
  rpush ids 4
  rpush ids 1
  rpush ids 1
  rpush ids 1
  # 查看list所有的值
  lrange ids 0 -1   # 返回 "1" "2" "3" "4" "1" "1" "1"
  # 查看索引为 3 的值
  lindex ids 3      # 返回 4
  # 删除最后的三个1，那就是从右边开始删除，所以传递负数
  lrem ids -3 1     # 返回删除的长度 3
  # 在查看下list
  lrange ids 0 -1   # 返回 "1" "2" "3" "4"
```

...

### 放到代码中怎么玩

> 放到代码中其实也是一样，一看代码便知

```js
const redis = require('docs/02.服务端/redis');
// 拿到客户端
const client = redis.createClient(6379, 'localhost');
// 监听错误事件
client.on('error', err => {
  console.log(err);
});

// 异步的
client.set('home', 'beijing', (err, result) => {
  if (err) throw err;
  console.log(result);
});
// hash
/**
 * person = {
 *   username: 'chengyuming',
 *   age: '24'
 * }
 */
client.hmset('person1', 'username', 'chengyuming', 'age', '24', (err, result) => {
  if (err) throw err;
  console.log(result);
});
client.hkeys('person1', (err, result) => {
  if (err) throw err;
  console.log(result);
  result.forEach(key => {
    client.hget('person1', key, (err, value) => {
      console.log(key, value, '嘿嘿和');
    });
  });
});
```

## Redis 发布订阅

> 有很多人订阅了你的产品，当你产品上线后，你需要通知他们上线了，那么这会用到发布订阅，对于 **Redis** 来说发布订阅很简单

* 我们只需要在订阅的频道，使用 `subscribe channelName` 即可订阅
* 发布频道在发布消息的时候，就可以直接发布 `publish channelName` 即可发布消息，此时所有订阅过得人都会收到通知
* 下面用代码演示一下

```js
const redis = require('docs/02.服务端/redis');
const subClient1 = redis.createClient(6379, 'localhost');
const subClient2 = redis.createClient(6379, 'localhost');
const pubClient = redis.createClient(6379, 'localhost');
// 订阅消息
subClient1.subscribe('food');
subClient2.subscribe('drink');
// 监听发布的消息之后要做什么
subClient1.on('message', (channel, message) => {
  console.log(channel, message);
  // 取消订阅
  subClient1.unsubscribe('food');
});
subClient2.on('message', (channel, message) => {
  console.log(channel, message);
});
// 发布消息
setTimeout(() => {
  pubClient.publish('food', '面包');
  pubClient.publish('drink', '可乐');
});
setTimeout(() => {
  pubClient.publish('food', '面包');
  pubClient.publish('drink', '可乐');
}, 1000);
```

## 事务

### MySQL 事务

> 举个栗子来说下 MySQL 的事务吧，别说那么多繁琐的概念了

```sh
  # 比如说转账，张三有1000元，李四有1000元，张三要转给李四500元
  # 那么就是
  #   张三: 1000 - 500 = 500 元
  #   李四: 1000 + 500 = 1500 元
  # 这个过程要么全部成功，要么全部失败，你不能给张三扣了，但是没有给李四加上去
```

### Redis 事务

> 对于 **Redis** 来说事务就是执行一个批量的脚本，那么就会用到 **multi** 和 **exec** 命令

* `multi` 命令开始事务
* 执行一些其他命令，但是这些命令都不会立即执行，会返回一个队列（QUEUED）
* 等到你执行 `exec` 命令之后，这些命令开始执行

```sh
  # 开始事务
  multi   # 返回 ok
  # 执行其他命令
  set name chengyuming    # 返回 QUEUED
  set age 24              # 返回 QUEUED
  # 执行
  exec                    # 返回 ok ok
```

* 放到代码中，来看一下

```js
const redis = require('docs/02.服务端/redis');
const client = redis.createClient(6379, 'localhost');
// 开启事务
client
  .multi()
  .set('k3', 'v3')
  .set('k4', 'v4')
  .get('k4')
  .exec((err, result) => {
    if (err) throw err;
    // 返回 [ 'OK', 'OK', 'v4' ]
    console.log(result);
  });
client.on('error', err => {
  console.log(err);
});
```

## 备份与恢复

> 对于 **Redis** 的备份与恢复特别简单，备份只需要输入 **save** 命令即可完成备份，此时会在 **Redis** 的安装目录下生成一个 **dump.rdb** 文件这就是 **Redis** 的备份文件，你可以把它拿到别的地方，等下次想恢复到这个版本的数据的时候，直接在启动 **Redis** 前把该文件 copy 到 **Redis** 的安装目录就可以了

* 可能会遇到输入 save 命令返回一个 error 的问题，那是你权限不够，提升下权限就可以解决
* **Redis** 就先记录这些，以后在做补充

---

---
url: /docs/@pages/riskLinkPage.md
---


---

---
url: /docs/@pages/loginPage.md
---


---

---
url: /docs/views/plugins/vscode.md
---

## vscode 插件可以做什么

vscode 编辑器是可以高度自定义的，使用 vscode 插件几乎可以对 vscode 编辑器进行说有形式的自定义。

[vscode 插件开发文档](https://code.visualstudio.com/api)，[中文文档](https://liiked.github.io/VS-Code-Extension-Doc-ZH)

vscode 插件可以实现自定义指令、快捷键、自定义菜单项、自定义跳转、自动补全、悬浮提示、新增语言支持、语法检查、语法高亮、代码格式化等

## 如何创建插件

我们使用官方来生成 vscode 插件模板项目

```sh
# 安装 yo 和 generator-code
npm install -g yo generator-code
# 使用脚手架创建项目
yo code
```

### yo 介绍

Yeoman 是一个通用的脚手架系统允许创建任何的 app 。它可以迅速的搭建一个新项目，并且能够简化了现有项目的维护。他可以构建任何语言的项目

Yeoman 它自己不能做任何操作。 每个操作都是由 generators 基本插件在 Yeoman 环境所完成的。 这里有 很多公共的 generators 并且它很容易 创建一个 generator 去匹配任何工作流。

yo 是 Yeoman 命令行工具，它允许项目利用脚手架模板来创建。

yo 创建项目依赖于安装的 generators，比如 `generator-code`

安装完成之后就可以使用 `yo code` 快速生成一个项目

yo 也提供了一系列指令供我们使用

* `yo --help`：查看帮助文档
* `yo --generators`：列出所有安装的 generators
* `yo --version`：得到他的最新版本
* `yo doctor`：故障排查

也可以配合安装的 generators 来使用一些命令，比如 `yo code --help`

## 项目介绍

使用 `yo code` 生成一个项目后，核心文件就是 `package.json` 和 `extension.js` 两个文件。

package.json 是整个插件工程的配置文件，extension.js 则是工程的入口文件。

### package.json 介绍

```json
{
	"name": "fecym-plugin",             # 插件名称
	"displayName": "fecym-plugin",      # 显示在插件市场的名称
	"description": "",                  # 插件描述
	"version": "0.0.1",                 # 插件版本号
	"engines": { "vscode": "^1.54.0" },
	"categories": ["Other"],
	"activationEvents": [               # 插件激活数组（在什么情况下插件会被激活，需要与extension.js中的注册函数保持一致）
		"onCommand:fecym-plugin.helloWorld"
	],
	"main": "./extension.js",           # 插件入口文件
	"contributes": {                    # 插件贡献点（最重要的配置项）
		"commands": [                     # 命令，通过 command + shift + p 输入的
			{
				"command": "fecym-plugin.helloWorld",		# 需要与 activationEvents 的命令保持一致
				"title": "Hello World"									# 真正输入的命令，可以与其他不保持一致
			}
		]
	},
	...
}
```

### activationEvents

`activationEvents` 配置项配置插件的激活数组，即在什么情况下插件会被激活，目前支持以下几种配置：

* onLanguage：在打开对应语言文件时
* onCommand：在执行对应命令时
* onDebug：在 debug 会话开始前
* onDebugInitialConfigurations：在初始化 debug 设置前
* onDebugResolve：在 debug 设置处理完之前
* workspaceContains：打开一个文件夹后，如果文件夹内包含设置的文件名模式时
* onFileSystem：打开文件或文件夹，是来自设置的类型或协议时
* onView：侧边栏设置的 id 项目展开时
* onUri：在基于 vscode 或 vscode-inside 协议的 URL 打开时
* onWebviewPanel：在打开设置的 webview 时
* \*：在打开 vscode 的时候，如果不是一般不建议这么设置

### contributes

contributes 是整个插件的贡献点，contributes 字段可以设置的 key 也就显示了

* configuration：通过这个配置项我们可以设置一个属性，这个属性我们可以在 `vscode` 的 `setting.json` 中设置，然后在插件工程中可以读取用户设置的这个值，进行相应的逻辑
* commands：命令，通过 command + shift + p 进行输入来实现
* menus：设置右键菜单
* keybindings：设置快捷键
* languages：设置语言特点，包括语言的后缀
* grammars：可以在这个配置项里设置描述语言的语法文件的路径，vscode 可以根据这个来实现语法高亮
* snippets：设置语法片段相关的路径
  ...

### extension.js

extension.js 是插件工程的入口文件，当插件被激活（触发 activationEvents 时），extension.js 文件开始执行

在 extension.js 中对需要功能进行注册，主要使用 vscode.commands.register 相关的 api 来为 package.json 中的 contributes 配置项的事件绑定方法

相关的 api 主要有：

* vscode.languages.registerCompletionItemProvider()
* vscode.languages.registerCodeActionsProvider()
* vscode.languages.registerCodeLensProvider()
* vscode.languages.registerHoverProvider()
* vscode.commands.registerCommand()
  ...

下面是 `yo code` 生成的 extension.js 中的代码

```js
const vscode = require('vscode');

function activate(context) {
  // 当扩展被激活时，这行代码只会被执行一次
  console.log('Congratulations, your extension "fecym-plugin" is now active!');
  // commandId参数必须与package.json中的command字段匹配
  // 为命令绑定事件，输入命令时执行该函数
  let disposable = vscode.commands.registerCommand('fecym-plugin.helloWorld', function() {
    // 控制台输入 hello Word 执行这里的函数
    // 向用户展示一个消息框
    vscode.window.showInformationMessage('Hello World from first-plugin!');
  });
  // 事件入栈
  context.subscriptions.push(disposable);
}

// 插件释放时执行
function deactivate() {
  console.log('插件释放');
}

module.exports = { activate, deactivate };
```

## 运行插件

在项目中按下 `F5` 便可以运行插件，第一次可能需要在 extension.js 文件下按下 `F5`，此时会打开一个新的 vscode 窗口，此时按下 `F1` 火折子 command + shift + p 可以打开命令框，输入 `hello world` 命令，便可以看到在 vscode 的界面的右下角弹出一个弹框 `Hello World from first-plugin!`，这就是在 extension.js 中为 `helloWorld` 注册的事件

## Command 配置

### 命令

配置一个命令只需要以下几步：

* 在 `package.json` 中

1. 在 `activationEvents` 中添加一项要注册的命令事件名称
2. 在 `contributes.commands` 中添加一项，`command` 和 `title`，`command` 的值要与 `activationEvents` 中的事件名称保持一致，`title` 的值是注册成功后真正要执行的命令

* 在 `extension.js` 文件里面的 `activate` 方法中使用 `registerCommand` 注册命令（需要与`activationEvents` 中新增的事件名称保持一致），最后事件入栈（所有注册类的 API 执行后都要将将结果放到 context.subscriptions 中去）

* 配置好后，按照 `运行插件` 的步骤就可以输入我们新注册的命令来看到效果了

### 右键菜单

我们可以为我们的命令配置右键菜单，直接使用右键菜单执行我们的命令，只需要在 `package.json` 中的 `contributes` 配置 `menus` 即可

```json
{
  "menus": {
    "editor/context": [
      {
        "when": "editorFocus",
        "command": "fecym-plugin.fecym",
        "alt": "",
        "group": "navigation"
      }
    ]
  }
}
```

* `editor/context`：定义菜单出现在哪里。这里是定义出现在编辑标题菜单栏
* `when`：菜单出现的时机
* `command`：点击菜单后执行的命令
* `alt`：按住 `alt` 在选择菜单时执行的命令
* `group`：定义菜单分组

菜单配置详细请查看[这里](https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/extensibility-reference/contribution-points?id=contributesmenus)

### 快捷键

同样也可以设置快捷键来执行我们的命令，同样是在 `contributes` 中配置 `keybindings`

```json
{
  "keybindings": [
    {
      "command": "fecym-plugin.fecym",
      "key": "ctrl+5",
      "mac": "cmd+5",
      "when": "editorTextFocus"
    }
  ]
}
```

* `command`：快捷键要执行的指令
* `key`：window 电脑对应的快捷键
* `mac`：Mac 电脑对应的快捷键
* `when`：快捷键出现的时机，这里是当编辑器焦点在某个文本中

更多请查看[这里](https://code.visualstudio.com/docs/getstarted/keybindings)

## 插件生命周期

## 发布

## 插件默认配置

## 常见编辑器 api

---

---
url: /docs/01.前端/02. 代码实现/vue-undone.md
---

## 数据劫持

### 对象的劫持

2.x 版本的数据劫持是根据 Object.defineProperty 来实现的

```js
function observe(data) {
  // 不是对象直接返回
  if (!(typeof data === 'object' && data !== null)) return;
  return observer(data);
}
function observer(data) {
  if (Array.isArray(data)) {
    observeArray(data);
  } else {
    observeObject(data);
  }
}
function observeObject(data) {
  const keys = Object.keys(data);
  keys.forEach(key => {
    const value = data[key];
    defineReactive(data, key, value);
  });
}
// 数组劫持下面继续
function observeArray(data) {
  data.forEach(item => observe(item));
}
function defineReactive(data, key, value) {
  // 如果value是对象的话递归处理，外层已经判断过是不是对象了，所以可以直接直接执行
  observe(value);
  Object.defineProperty(data, key, {
    get() {
      return value;
    },
    set(newVal) {
      // 如果设置的新值没有变化，则不处理
      if (newVal === value) return;
      observe(newVal);
      value = newVal;
    },
  });
}
```

### 数组的劫持

* 如果是对数组进行监测的话还要按照上面的套路处理就会对数据的索引进行检测，但是对数组的索引进行监测意义不大，还会导致性能问题
* 而且我们在开发中也很少去操作索引，一般是使用数组的 api 来操作数组的，而操作这些 api 也会导致数组的成员的变更，所以需要重写这些 api
* 常见的数组 7 个 api：`push、shift、unshift、pop、reverse、sort、splice` 会导致数组发生改变，那我们就重写这几个就可以
* 写法用到装饰器模式，对数组 api 进行一层包装
* 我们可以把上面的 observe 改写为类的写法，对每一个进行监听过的属性设置一个标识
* 如下代码及注释，然后在 Observe 类中引入新的数组方法，便可以实现对数组的监听

```js
// 重写数组 api
const oldArrayMethods = Array.prototype;
// 利用原型链的查找逻辑，先查找重写的，如果没有找到则向上查找
// arrayMethods.__proto__ = oldArrayMethods
const arrayMethods = Object.create(oldArrayMethods);
const methods = ['push', 'shift', 'unshift', 'pop', 'sort', 'splice', 'reverse'];

methods.forEach(method => {
  arrayMethods[method] = function(...args) {
    // 执行原始的数组中的方法 --> AOP 思想
    const result = oldArrayMethods[method].apply(this, args);
    // push 和 unshift 可能会添加一个对象，还需要继续监听
    let inserted;
    // 在 Observe 类中存入的，为了得到类的方法，也为了说明这个对象被监听过了
    const ob = this.__ob__;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      // splice 也可能新增一个值或者替换一个值  arr.splice(0, 1, { name: 2 })
      // 那么传入的第三个参数往后就是要替换的或者追加的值
      case 'splice':
        inserted = args.slice(2);
        break;
      default:
        break;
    }
    if (inserted) {
      // 将新增属性继续观测
      ob.observeArray(inserted);
    }
    return result;
  };
});
```

### 改良后完整写法

```js {12}
class Observe {
  constructor(data) {
    // 给每一个监控的对象，都增加一个 __ob__ 属性，表示这个对象已经被监控了
    // 防止监听自身死循环
    Object.defineProperty(data, '__ob__', {
      enumerable: false,
      configurable: false,
      value: this,
    });
    if (Array.isArray(data)) {
      // 重写原型方法
      data.__proto__ = arrayMethods;
      this.observeArray(data);
    } else {
      this.observeObject(data);
    }
  }
  observeArray(value) {
    for (let i = 0; i < value.length; i++) {
      observe(value[i]);
    }
  }
  observeObject(data) {
    const keys = Object.keys(data);
    keys.forEach(key => {
      const value = data[key];
      defineReactive(data, key, value);
    });
  }
}

function observe(data) {
  // 不是对象直接返回
  if (!(typeof data === 'object' && data !== null)) return;
  return new Observe(data);
}
function defineReactive(data, key, value) {
  // 如果value是对象的话递归处理，外层已经判断过是不是对象了，所以可以直接直接执行
  observe(value);
  Object.defineProperty(data, key, {
    get() {
      return value;
    },
    set(newVal) {
      // 如果设置的新值没有变化，则不处理
      if (newVal === value) return;
      observe(newVal);
      value = newVal;
    },
  });
}
```

### 测试用例

```js
var o = {
  age: 11,
  name: 'cym',
  address: {
    number: 0,
    name: 'xxxx',
  },
  names: [
    {
      a: 1,
    },
    {
      b: 2,
    },
  ],
};

observe(o);
console.log(o);
o.names.push({ c: 3 });
console.log(o);
```

---

---
url: /docs/03.工具/Webpack 相关/vue.md
---

## 从 0 开始搭建 vue 项目

`webpack` 打包部署 js 项目从以下几个方面考虑：

* js 的处理：转换 ES6 代码，解决浏览器兼容问题
* css 的处理：编译 css，自动添加前缀，抽取 css 到独立文件
* html 的处理：复制并压缩 html 文件
* dist 的清理：打包前清理源目录文件
* assets 的处理：静态资源处理
* server 的启用：development 模式下启动服务器并实时刷新

## 一、项目结构

::: tip 项目结构
我们按照 vue-cli 的目录结构来新建一些目录，然后 webpack 做相应的配置，打开控制台
:::

```sh
  cd 切换到你要把项目新建到的地方
  # 新建项目目录
  mkdir webpack-pit && cd webpack-pit
  # 初始化项目
  npm init -y
  # 新建基本结构
  mkdir src public
  # 新建基本配置文件
  touch webpack.config.js babel.config.js postcss.config.js .gitignore
  # 打开src目录，新建main.js，作为项目的主入口
  cd src && touch main.js
  # src作为我们编写的主文件，模拟vue的项目目录新建以下文件及文件夹
  mkdir assets components styles views
  # 最终生成以下目录结构
  ├── public
  │   ├── favicon.ico
  │   └── index.html      # html 模板
  ├── src
  │   ├── assets          # 静态资源
  │   ├── views
  │   ├── components      # 组件
  │   │   └── App.vue
  │   ├── styles
  │   │   └── index.scss
  │   ├── main.js         # 入口文件
  │   └── App.vue
  ├── babel.config.js     # babel7配置文件
  ├── package-lock.json   # npm包锁
  ├── package.json        # 项目配置文件
  ├── postcss.config.js   # css配置文件
  └── webpack.config.js   # 项目打包机主文件
```

## 二、简单配置 webpack

::: tip 简单配置 `webpack`
简单配置下 `webpack，先把项目跑起来，下载` `webpack` 依赖
:::

* 首先我们需要用到 `webpack、webpack-cli、webpack-dev-server`，那么我们执行以下命令

  * `webpack` 用来打包项目，`webpack-dev-server` 用来本地开发，`webpack-cli` 必不可少

  ```sh
    yarn add webpack webpack-cli webpack-dev-server --save-dev
  ```

* 我们要编译 `html`，需要用到 `html-webpack-plugin` 插件，每次打包我们需要在 `build` 之前先删除之前打包后的文件因为 `hash` 的存在会导致文件冲突，所以我们安装以下两个插件

  ```sh
    yarn add html-webpack-plugin html-loader clean-webpack-plugin --save-dev
  ```

* `html-loader` 是 `babel` 的一个 `loader` 用来编译 `html`

* `clean-webpack-plugin` 用来对打包之前的删除操作，因为新版本的原因，引入方式有点不一样

  ```javascript
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');
  ```

* `webpack` 处理 `html、css、js`，就会处理路径，我们会用到 `path` 模块，一般会写一个 `resolve` 方法来处理路径
  ```javascript
    yarn add path --save-dev
    const resolve = dir => path.join(__dirname, dir)
  ```

* `webpack` 必须配置的几项，`entry、output`
  * entry 顾名思义配置文件主入口的，他的配置方式多种多样，详细了解 `webpack` 的介绍 [传送门](/views/webpack/webpack-1/#一、entry)
  * 我们先简单的配置以下，使 `js` 和 `html` 耦合到一起，`entry` 我们选对象语法
  ```javascript
  entry: {
    app: resolve('./src/main.js');
  }
  ```
  * `output` 就是对象语法，必要的有两个配置项，`path、filename` 还有一个可有可无 `publicPath` 打包后静态资源文件夹的目录
  * `path` 是打包后的目录，若没有这个目录 `webpack` 会自己新建，`filename` 是打包后的文件名字，语法如下
  * `hash` 介绍看 `webpack` 的介绍 [传送门](/views/webpack/#四、hash、chunkhash-和-contenthash)
  ```javascript
   output: {
     path: resolve('love'),
     filename: 'js/[name].[hash].js'
   }
  ```
  * 配置开发环境下的 `node` `服务器，devserver`
  ```javascript
    devServer: {
      contentBase: resolve('public'), // 服务器根目录
      compress: true,                 // 开启gzip
      host: 'localhost',
      port: '8880',
      open: true,                     // 自动打开网站
      hot: true,                      // 开启热加载
      inline: true,                   // 热加载方式
      overlay: {
        warnings: true,
        errors: false
      }
    },
  ```
  * 配置 plugins，先介绍两个插件 html-webpack-plugin 和 clean-webpack-plugin，配置如下
  * HtmlWebpackPlugin 详细配置看这里 [传送门](https://github.com/jantimon/html-webpack-plugin)
  * CleanWebpackPlugin 详细配置看这里 [传送门](https://github.com/johnagan/clean-webpack-plugin)
  ```javascript{11}
    plugins: [
      new CleanWebpackPlugin(),
      // 处理html
      new HtmlWebpackPlugin({
        template: resolve('public/index.html'),  // 源模板文件，可以是ejs、pug等模板文件
        filename: 'index.html',                  // 输出的文件
        title: 'webpack构建项目',                 // html的title
        inject: true,                            // 是否动态注入
        hash: true,                              // 开启hash
        favicon: resolve('public/favicon.ico'),
        // 推荐你不要设置，有坑
        chunks: ['app'],                         // 注入的脚本，跟entry里面要对应上
        showErrors: true                         // 报错了是否展示
      })
  ```
  ::: danger 不推荐设置 `chunks`
  项目中之前设置了 `chunks` 打包后对应某个模块，但是我们用到了分离插件，导致分离后的东西，动态的我们不确定名字，导致不去加载那个文件，导致页面不渲染，这个属性不设置，也不会不错，他会动态的都给你加上去
  :::

* 最后我们修改下 `package.json` 的启动脚本，然后我们可以在 `main.js` 下写一些执行脚本，就可以看到效果了

* `--mode development` 设置 `webpack` 运行时的环境为 `development`，`--progress` 不用说了吧

```JSON
  "scripts": {
    "start": "webpack-dev-server --mode development --progress",
    "build": "webpack --mode production --progress"
  }
```

## 三、开始配置 vue

::: tip 配置 `vue`
配置 `vue`，需要下载 `vue` 核心的插件 `vue-loader vue-template-compiler`，以及我们将要用到的 `sass` 的配置
:::

```sh
  yarn add vue --save
  yarn add vue-loader vue-template-compiler --save-dev
```

* 配置 `vue`
  * `vue` 核心插件下载完之后在 `vue-loader` 下面的 `lib` 里面有他的插件配置，我们取出来就可以直接用
  ```javascript
    const VueLoaderPlugin = require('vue-loader/lib/plugin')
    ...省略上万行代码
    plugins: [ new VueLoaderPlugin() ]
  ```
  * 然后我们配置 `module`，配置 `vue` 文件怎么执行
  ```javascript
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader',
      },
    ];
  }
  ```
  * 然后我们在相应的地方写上我们改写的代码，此时就可以运行代码了
    * 在 `public` 下面的 `index.html` 里面写下
    ```html
    <div id="root"></div>
    ```
    * 在 `main.js` 里面引入 `vue`，并简单配置下 `vue`
    ```js
      import Vue form 'vue'
      import App from './App.vue'
      new Vue({
        render: h => h(App)
      }).$mount('#root')
    ```
    * 在 `App.vue` 里面写下
    ```html
    <template>
      <div id="root">
        hello world
        <router-view />
      </div>
    </template>
    <script>
      export default {
        name: 'app',
      };
    </script>
    ```
  * 此时 `vue` 最基本的功能就配置完成了
* 接下来我们配置 `css` 预编译 `scss`，还有 `css` 的兼容那个 `postcss` 自动填充浏览器前缀
  * `css loader` 介绍请看这里 [传送门](/views/webpack/#六、webpack-处理-css-的一些介绍)
  * 首先需要几个插件 `style-loader css-loader postcss-loader scss-loader`
  * `webpack` 的模块的执行顺序是倒着来的，我们也要倒着来配置
  ```sh
    yarn add node-sass sass-loader postcss-loader style-loader css-loader --save-dev
    yarn add --dev autoprefixer
    # css loader配置
    {
      test: /\.(sa|sc|c)ss$/,
      loader: ['style-loader', 'css-loader', 'postcss-loader', 'sass-loader']
    }
  ```
  * `postcss` 是 `css` 后处理器 `postcss.config.js` 的配置如下
  ```javascript
  module.exports = {
    plugins: {
      autoprefixer: {},
    },
  };
  ```
* 可能会用到对一些文件的打包，比如说图片转 `base64`，解析字体，我们会用到 `file-loader`
  ```javascript
    yarn add file-loader --save-dev
    # 配置如下
    {
      test: /\.(png|svg|jpg|gif)$/,
      loader: 'file-loader',
      options: {
        limit: 5000,
        // 分离图片至imgs文件夹
        name: "imgs/[name].[ext]",
      }
    }
  ```
* 附上源码地址：<https://gitee.com/cym_git/webpack-pit.git> 请选择 basic 分支
* 基础篇完结

## 四、编译 js

::: tip 编译 js
忘了重要的一项，忘记了编译 js 了，我说怎么缺点什么呢
:::

* 编译 js 我选择了 `preset-env` 插件，为什么？[传送门](https://zhuanlan.zhihu.com/p/29506685)
* 而且我试了用了 `@babel/preset-es2015` 但是还是一直报找不到这个模块
* 最终选择了`@babel/preset-env` 插件

```sh
  yarn add --save-dev @babel/core @babel/preset-env babel-loader
```

* `babel-loader` 默认下载就是 `babel7` 的插件，我们选择了 `babel7` 的插件，因为 babel 已经是最稳定的插件了
* 用了 `babel7` 之后 `babel` 配置文件是 `babel.config.js` 和 `.babelrc` 都无所谓了，不过 `.babelrc` 要求必须是严格的 `JSON` 语法
* 当我们配置了 `babel.config.js` 之后还是报了一个错
* 那我们按照他的提示下载并且配置该插件就好

```sh
  yarn add @babel/plugin-syntax-dynamic-import
```

* 并附上 `babel.config.js` 的配置

```javascript
module.exports = {
  presets: ['@babel/preset-env'],
  plugins: ['@babel/plugin-syntax-dynamic-import'],
};
```

* 如果您喜欢用 `.babelrc` 配置的话也是可以，下面是 `.babelrc` 的配置

```JSON
  {
    "presets": ["@babel/preset-env"],
    "plugins": ["@babel/plugin-syntax-dynamic-import"]
  }
```

* 编译 `beble` 的 `loader` 配置如下，我们只编译 `src` 目录下的文件，减少文件搜索范围

```javascript
  {
    test: /\.js$/,
    loader: 'babel-loader',
    include: [
      resolve('src'),
      resolve('node_modules/webpack-dev-server/client')
    ]
  },
```

## 五、项目优化

### 分离 css

* 插件是 `mini-css-extract-plugin`，该插件必须是 `webpack4.0` 以上才支持

```shell
  # 下载插件
  yarn add mini-css-extract-plugin
```

* 插件介绍：
  * 在 `plugins` 数组中直接 `new MiniCSSExtractPlugin` 就可以，它接受一个 `options` 作为一个参数
  * `filename` 和 `chunkFilename`，这两项都是可选的，类似于 `webpackOptions.output`
  * 简单配置如下 [传送门](https://webpack.js.org/plugins/mini-css-extract-plugin/)
  ```javascript
  new MiniCssExtractPlugin({
    filename: 'css/[name].[hash].css',
    chunkFilename: 'css/[id].[hash].css',
  });
  ```
  * 配置完后，需要修改 `module` 里面配置 `css` 的参数，修改为以下配置
  ```javascript
    {
      test: /\.(sa|sc|c)ss$/,
      use: [
        {
          loader: MiniCssExtractPlugin.loader,
          options: {
            // publicPath: '../',
            reloadAll: true
          }
        },
        'css-loader',
        'postcss-loader',
        'sass-loader'
      ]
    },
  ```

### 分离不常变化的文件

* `node_modules` 下面的模块，引用别人的库，我们是不需要编译，所以我们把它们分离出来，这是我们需要配置 `optimization` 配置项
* 这么配置以下，会看到项目下面会打包出一个 `vendor.js` 文件
* 具体配置参照 [传送门](https://imweb.io/topic/5b66dd601402769b60847149)

```javascript
optimization: {
  // 分离chunks
  splitChunks: isProduction
    ? {
        chunks: 'all',
        cacheGroups: {
          vendor: {
            name: 'vendor',
            test: /[\\/]node_modules[\\/]/,
            priority: 10,
            chunks: 'initial', // 只打包初始时依赖的第三方
          },
        },
      }
    : undefined;
}
```

* 如果项目使用包模块多的话，我们可以把大点的包都分离出来，`cacheGroup` 就是配置的关键，可以卓个分离分离
* 比如说你想把 `vue、vue-router` 分离出来，或者你用了 `element、echarts` 因为打包后单个包太大，你想要分割代码，那就配置 `cacheGroup`
* 它是 `webpack` 自带的插件，不需要引入直接就可以用，简单配置如下

```JavaScript
  {
    chunks: 'all',
    cacheGroups: {
      libs: {
        name: 'chunk-libs',
        test: /[\\/]node_modules[\\/]/,
        priority: 10,
        chunks: 'initial' // 只打包初始时依赖的第三方
      },
      vue: {
        name: 'vue',
        test: /[\\/]node_modules[\\/]vue[\\/]/,
        priority: 11,
      },
      // 单独分离vue-router
      // vueRouter: {
      //   name: 'vue-router',
      //   test: /[\\/]node_modules[\\/]vue-router[\\/]/,
      //   priority: 12,
      // }
    }
  }
```

### 压缩 js 和压缩 css

* 需要两个插件 `optimize-css-assets-webpack-plugin` 和 `uglifyjs-webpack-plugin`

```sh
  yarn add --save-dev uglifyjs-webpack-plugin
  yarn add optimize-css-assets-webpack-plugin
```

* 压缩文件出现的情况下都在生产环境下，开发环境是不需要的，所以我们可以下判断
* `OptimizeCSSAssetsWebpackPlugin` 插件基本不需要配置，直接实例化传入一个空的 `options` 就可以
* `UgligyjsWebpackPlugin` 有个坑，配置完毕后，项目打包报错了

### 去除无用的 css

* 需要用到两个插件 `PurgecssPlugin` 和 `glob`

```sh
  yarn add glob-all --save-dev
  yarn add purgecss-webpack-plugin -D
```

* 简单配置如下

```javascript
  new PurgecssPlugin({
    paths: glob.sync([
      path.join(__dirname, './src/index.html'),
      path.join(__dirname, './**/*.vue'),
      path.join(__dirname, './src/**/*.js')
    ])
  }),
```

### 开启 gzip

* 需要用到插件 `CompressionWebpackPlugin`

```sh
  yarn add -D compression-webpack-plugin
```

* 简单配置入下，这样配置下打包后项目就会生成 gz 压缩包

```javascript
  new CompressionWebpackPlugin({
    algorithm: 'gzip',
    test: new RegExp('\\.(' + ['js', 'css'].join('|') + ')$'),
    threshold: 10240,
    minRatio: 0.8
  }),
```

### 显示打包进度和打包时间

* 需要用到两个插件 `progress-bar-webpack-plugin chalk`
* [ProgressBarPlugin](https://www.npmjs.com/package/progress-bar-webpack-plugin) 是用来配置进度条的，[chalk](https://www.npmjs.com/package/chalk) 是用来定义展示的颜色的

```js
  // 打包时间
  new ProgressBarPlugin({
    format: '  编译进度：[:bar] ' + chalk.green.bold(':percent') + ' (已用时 :elapsed 秒)',
    clear: false
  }),
```

### 友好的错误提示

* 在 `webpack` 中编译过程中终端会输出很多信息的，看着很别扭，此时可以用到一个插件来很友好的显示
* 在开发环境下展示的 `log` 我们完全可以把 **devServer.quiet** 设置为 **true**，此时整个世界都安静了
* 模拟 `vue-cli` 中编译过程中输出的信息，我们用到 `friendly-errors-webpack-plugin` 插件
* 经测试，貌似只对开发环境管用，那么我们就模拟下 `vue-cli` 的展示
* 在 `plugins` 添加一下代码 [传送门](https://blog.csdn.net/kai_vin/article/details/89025966)

```js
  new FriendlyErrorsWebpackPlugin({
    compilationSuccessInfo: {
      messages: [`
        App running at:
        - Local:   ${chalk.hex('#66D9EF')('http://localhost:' + PORT)}
        - Network: ${chalk.hex('#66D9EF')('http://' + networkIp + ':' + PORT)}
      `],
      clearConsole: true,
      onErrors: (severity, errors) => {
        if (severity !== 'error') return
        const error = errors[0]
        const filename = error.file && error.file.split('!').pop()
        notifier.notify({
          title: packageConfig.name,
          message: severity + ': ' + error.name,
          subtitle: filename || '',
          // icon: path.join(__dirname, 'logo.png')
        })
      }
    }
  }),
```

* `networkIp` 是我们自己编写的一个利用 `os` 模块获取本机 `ip` 的方法，具体实现如下
* 获取 `networkInterfaces` 对象，里面有 `ip` 的各种格式，筛选出我们要的那个就可以了

```js
const interfaces = require('os').networkInterfaces();
const getNetworkIp = () => {
  let IpAddress = '';
  for (let devName in interfaces) {
    let iface = interfaces[devName];
    iface.forEach(ipInfo => {
      if (ipInfo.family === 'IPv4' && ipInfo.address !== '127.0.0.1' && !ipInfo.internal) {
        IpAddress = ipInfo.address;
      }
    });
  }
  return IpAddress;
};
module.exports = getNetworkIp;
```

* 最终实现的效果如下所示

## 六、Source Map

::: tip 为什么要用 `source maps`
因为 `webpack` 对源代码进行打包后，会对源代码进行压缩、精简、甚至变量名替换，在浏览器中，无法对代码逐行打断点进行调试，所有需要使用 `source maps` 进行调试，它使得我们在浏览器中可以看到源代码，进而逐行打断点调试。
:::

* 使用方法很简单，只需要在配置中添加 `devtool` 属性，赋值一个字符串或者布尔值即可 [传送门](https://www.webpackjs.com/configuration/devtool/)
* 使用 inline-source-map 不会对生产环境造成影响

```js
  devtool: 'inline-source-map',
```

* 到此告一段落了，项目地址还是原来的地址，但是分支换成了 develop [传送门](https://gitee.com/cym_git/webpack-pit.git)

:tada: :100:

---

---
url: /docs/03.工具/Webpack 相关/webpack-1.md
---

## webpack 介绍

Webpack 可以直接执行 webpack 命令进行打包，也可以通过手动配置实现更复杂的打包需求。配置文件为 webpack.config.js，可以导出一个对象或函数，函数接受两个参数：env（环境对象）和 argv（描述传递给 webpack 选项的 map 对象）。

来看一下这两个参数：

```js
  // 在 webpack.config.js 中输入以下代码
  module.exports = function(env, argv) {
    console.log(env, argv)
  }
  // 在控制台执行
  webpack --env=chengyuming
```

* 让 `webpack` 正常启动，至少需要两个 `npm` 包，`webpack、webpack-cli`

### 一、entry

> Webpack 采用模块化思想，所有文件和配置都是模块。entry 是顶层入口，Webpack 从入口开始，遍历和递归解析所有入口依赖的模块。

* `entry` 用法如下

- 当然也可以采用动态配置 `entry`， 采用箭头函数动态返回。

* 关于 `entry`， 我们要记住， 他有多种配置类型， 而且可以动态配置， 还可以为入口设置别名呐。
* 也可以引用定义三方模块的打包，配置如下

```js
  entry: {
    app: path.resolve('./src/main.js'),
    // 配置公共文件
    vender: ['./src/jquery.js']
  },
```

### 二、output

* `output` 是一个对象，里面包含一些列输出配置项
* 常用的语法如下：

```js
  output: {
    // 打包后的位置，必须是绝对地址
    path: path.resolve('./dist'),
    // 打包后的文件名，[name] 对应 entry 的名字
    filename: 'js/[name].[chunkHash].js',
    // 打包后静态资源的位置，cdn 的配置
    publicPath: '.'
  },
```

### 三、mode

> `webpack` 有三种 `mode`：`development`、`production`、`none`

* development：会将 `process.env.NODE_ENV` 的值设置为 `development`，启用 `NamedChunksPlugin` 和 `NamedModulesPlugin`。代码不压缩
* production：会将 `DefinePlugin` 中 `process.env.NODE_ENV` 的值设置为 `production`。启用 `FlagDependencyUsagePlugin`, `FlagIncludedChunksPlugin`, `ModuleConcatenationPlugin`, `NoEmitOnErrorsPlugin`, `OccurrenceOrderPlugin`, `SideEffectsFlagPlugin` 和 `TerserPlugin`。
* none：不使用任何默认优化。
* 如果没有设置，`webpack` 会把 `mode` 默认设置为 `production`，并发出警告。
* 我们可以通过控制台中输入 `--mode=development` 来设置 `webpack` 的模式，也可以在 `webpack.config.js` 中设置 `mode: development`
* 设置 `NODE_ENV` 并不会自动地设置 `mode`。
* 如下，一个简单的 web 打包机就配置成功了，编译、优化就是 `modules`、`plugins`、`optimization` 配置的事情，配置规则在基础篇已经介绍过了

```js
const path = require('path');
module.exports = function(env, argv) {
  return {
    mode: argv.mode || 'development',
    entry: path.resolve('./src/main'),
    output: {
      path: path.resolve('./dist'),
      filename: '[name].[hash].js',
    },
  };
};
```

### 四、module

#### 配置 loader

> 配置 `loader` 就是配置一堆规则，所以要放在 `module.rules` 中，先看一段代码

```javascript
  module: {
    rules: [{
      test: /\.js$/,
      include: path.resolve(__dirname, 'src'),
      // use可以是普通字符串数组，也可以是对象数组
      use: ['babel-loader?cacheDirectory'],
      use: [{
        loader: 'babel-loader',
        options: {
            cacheDirectory: true, //
        },
        enforce: 'post'
      }]
    },
    {
      test: /\.scss$/,
      use: ['style-loader', 'css-loader', 'sass-loader'],
      exclude: path.resolve(__dirname, 'node_modules')
    },
    {
      // 对非文本文件采用 file-loader 加载
      test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
      use: ['file-loader'],
    }，
      //配置更多的其他loader
    ]
  }
```

::: tip 属性说明

1. `test/include/exclude`： 表示匹配到 `loader` 的文件或者文件范围；
2. `use`: 表示使用什么 `loader`， 它可以是一个字符串数组， 也可以是对象数组， 那多个 `loader` 时， 执行顺序是从右向左， 当然， 也可以使用 `enforce` 强制让某个 `loader` 的执行顺序放到最前面或者最后面；
3. `cacheDirectory`： 表示传给 `babel-loader` 的参数， 用于缓存 `babel` 的编译结果， 加快编译速度。
4. `enforce`：`post` 表示将改 `loader` 的执行顺序放到最前面，`pre` 则相反.
5. 多个 `loader` 时处理顺序：从后到前，即先交给 `sass-loader` 处理， 再将结果交给 `css-loader`, 最后交给 `style-loader`
   :::

#### 配置 noParse

::: tip noParse
`noParse` 可以用于让 `webpack` 忽略哪些没有采用模块化的文件， 不对这些文件进行编译处理， 这样做可以提高构建性能， 因为例如一些库： 如 `jquery` 本身是没有采用模块化标注的， 让 `webpack` 去解析这些文件即耗时， 也没什么意义。
:::

```javascript
  module: {
    rules: [],
    noParse: /jquery/,
    noParse: content => {
      return /jquery/.test(content);
    }
  }
```

::: tip 说明：

* `noParse` 的值可以是正则表达式， 也可以是一个函数；
* 被忽略的文件里不应该包含 `import、require、define` 等模块化语句， 不然会导致在构建出的代码中包含无法在浏览器环境下执行的模块化语句
  :::

#### 配置 parser

::: tip parser
因为 `Webpack` 是以模块化的 `JavaScript` 文件为入口的，所以内置了对模块化 `JavaScript` 的解析功能，支持 `AMD`, `CommonJS`、`SystemJS`、`ES6`。`parser` 属性可以更细粒度地配置哪些模块语法被解析、哪些不被解析。同 `noParse` 配置项的区别在于，`parser` 可以精确到语法层面，而 `noParse`只能控制哪些文件不被解析。
:::

```javascript
  module: {
    rules: [
      test: /\.js$/，
      use: ['babel-loader'],
      parse: [
        amd: false，                  // 禁用AMD
        commonjs: false,              // 禁用 CommonJS
        system: false,                // 禁用 SystemJS
        harmony: false，              // 禁用 ES6 import/export
        requireinclude: false,        // 禁用require.include
        requireEnsure: false,         // 禁用require.ensure
        requireContext: false,        // 禁用require.context
        browserify: false,            // 禁用
        browserify requireJs: false,  // 禁用 requirejs: false, //禁用requirejs
      ]
    ]
  }
```

::: tip 说明：

* `parse` 和 `noParse` 同级的属性，当然也可以嵌套到 `rules`，表示针对与某个 `loader` 应用到该属性的规则。
* 目前只要明白 `parse` 属性，是用于声明哪些模块语法被解析，哪些不被解析即可。
  :::

#### 单个规则配置多个 loader， 语法需要使用 use， 如图

```JavaScript
  {
    test: /\.(sa|sc|c)ss$/,
    use: [
      {
        loader: MiniCssExtractPlugin.loader,
        options: {
          // publicPath: '../',
          reloadAll: true
        }
      },
      'css-loader',
      'postcss-loader',
      'sass-loader'
    ]
  },
```

#### oneOf

每个文件对于 rules 中所有规则都会遍历一遍，使用 oneOf 就可以解决该问题，只要匹配一个即可退出（在 oneOf 中不能两个配置处理同一种类型文件）

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        // 优先执行
        enforce: 'pre',
        loader: 'eslint-loader',
        options: {
          fix: true
        }
      },
      {
        // 以下 loader 只会匹配一个
        oneOf: [
          ...,
          {},
          {}
        ]
      }
    ]
  }
}
```

### 五、resolve

::: tip resolve
`resolve` 配置 `webpack` 去寻找模块对应的文件，我们平常通过 `import` 导入的模块，`resolve` 可以告诉 `webpack` 如何去解析导入的模块
:::

#### 1. alias：配置路径别名

```javascript
  resolve: {
    alias: {
      '@': path.join(__dirname, '..', 'src')
    }
  }
```

#### 2. extensions：用于配置模块文件的后缀列表

> 用来配置文件可以不写后缀名

```javascript
resolve: {
  extension: ['.js', '.json', '.vue', '.jsx'];
}
```

#### 3. modules

::: tip
`resolve.modules` 配置的 `webpack` 默认会去 `node_modules` 目录下寻找，假如项目中遇到一些模块大量依赖和导入由于 其他模块 的位置不定， 针对不同的文件都要计算被导入的模块文件的相对路径，这个路径 有时会很长，例如：就像 `import ······ '../../../components/module-a.js'`，这时可以利用 `modules` 配置项优化。假如那些被大量导入的模块都在 `./src/components` 目录下，则将 `modules` 配置成这样
:::

```js
resolve: {
  modules: ['./src/components', 'node_modules'];
}
// 然后引入模块就会去这两个目录中寻找
import moduleA from 'module-a'; // module-a.js 在 ./src/components 目录下
```

::: warning
此时我们就可以简单的通过 `import ······ 'module-a'` 导入
注意： `modules` 和 `alisa` 的区别：`modules` 是用来配置一些公共模块，这些公共模块和 `node_modules` 类似，配置以后，我们就可以直接引用模块，前面不需要再加路径，而 `alias` 作用是配置路径别名，目的是可以让路径简化。两者是不一样的。&#x20;
除此之外，还有：&#x20;

1. `descriptionFiles`：配置描述第三方模块的文件名称：默认是 `package.json`
2. `enforceExtension`：配置后缀名是否必须加上
   :::

### 六、plugin

::: tip plugin

* `plugins` 其实包括 `webpack` 本身自带的插件，也有开源的其他插件，都可以使用，它的作用就是解决 `loader` 之外的其他任何相关构建的事情。
* `plugin` 的值是一个数组，可以传入多个插件实例，用法是直接 `new` 一个插件然后传入相应的配置即可
* `plugin` 如何配置并不是难点，难点是我们需要清楚常用的一些插件分别解决了什么样的问题，以及这些插件的配置项
  :::

```js
plugins: [
  // 处理vue
  new VueLoaderPlugin(),
  // 分离css，只需要传入相应的配置即可
  new MiniCssExtractPlugin({
    filename: 'css/[name].[hash].css',
    chunkFilename: 'css/[id].[hash].css',
  }),
];
```

### 七、optimization

::: tip optimization
`optimization` 很明显是优化代码的，比如说我们的压缩代码，就是在这里面配置，从 `webpack4` 开始，如果 `mode` 是 `production` 模式会默认压缩代码，具体可查看[官网文档](https://webpack.docschina.org/configuration/optimization/)
:::

```js
  optimization: {
    // 简单配置压缩代码
    minimize: true,
    // 分离代码
    splitChunks: {
      chunk: 'all',
      cacheGroups: {
        libs: {
          name: 'chunk-libs',
          test: /[\\/]node_modules[\\/]/,
          priority: 10,
          chunks: 'initial' // 只打包初始时依赖的第三方
        },
        vue: {
          name: 'vue',
          test: /[\\/]node_modules[\\/]vue[\\/]/,
          priority: 11,
        },
        vueRouter: {
          name: 'vue-router',
          test: /[\\/]node_modules[\\/]vue-router[\\/]/,
          priority: 12,
        }
      }
    }
  }
```

### 八、devServer

::: tip devServer
`devServer` 主要用于本地开发的时候，配置本地服务的各种特性，常用的配置如下
:::

* hot： 是否开启模块热替换
* inline:  是否开启实时刷新， 即代码更改以后， 浏览器自动刷新
* contentBase: 用于配置本地服务的文件根目录
* header: 设置请求头
* host: 设置域名
* port:  设置端口
* allowedHosts: 只有请求的域名在该属性所配置的范围内， 才可以访问。
* https:  使用使用 https 服务， 默认为 false
* compress:  是否启用 Gzip 压缩， 默认为 false.
* open: // 是否开启新窗口
* devtool: 配置 webpack 是否生成 source Map， 以方便调试。
* watch: 默认为 true， 表示是否监听文件修改以后， 自动编译。

### 附上一个简单的配置

```js
const path = require('path');
const HTMLWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = function(env, argv) {
  return {
    mode: argv.mode || 'development',
    entry: path.resolve('./src/main'),
    output: {
      path: path.resolve('./dist'),
      filename: 'js/[name].[chunkHash].js',
      publicPath: '.',
    },
    module: {
      rules: [
        // 使用MiniCssExtractPlugin插件后的配置
        {
          test: /\.(sa|sc|c)ss$/,
          use: [
            {
              loader: MiniCssExtractPlugin.loader,
              options: {
                reloadAll: true,
              },
            },
            'css-loader',
          ],
        },
      ],
    },
    plugins: [
      // 配置HTML
      new HTMLWebpackPlugin({
        // 源文件模板
        template: path.resolve('./public/index.html'),
        // 输出文件
        filename: 'index.html',
        title: 'fecym',
        inject: true,
        hash: true,
        showErrors: true,
      }),
      // 分离css
      new MiniCssExtractPlugin({
        filename: 'css/[name].[hash].css',
        chunkFilename: 'css/[id].[hash].css',
      }),
    ],
    optimization: {
      minimize: true,
      runtimeChunk: {
        name: entryPoint => `runtime~${entryPoint.name}`,
      },
    },
  };
};
```

## webpack 一些概念

### 一、module，chunk 和 bundle

1. 对于同逻辑代码，当我们手写下一个个文件，他们都是 `module`；
2. 当我们写的 `module` 源文件传到 `webpack` 进行打包时，`webpack` 会根据文件引用关系生成 `chunk` 文件，`webpack` 会对这个 `chunk` 文件进行一些操作；
3. `webpack` 处理好 `chunk` 文件后，最后会输出 `bundle` 文件，这个 `bundle` 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。

总结：`module、chunk、bundle` 其实就是同一份逻辑代码在不同转换场景下取了不同的名字：我们直接写出来的是 `module`，`webpack` 处理时是 `chunk`，最后在浏览器中可以直接运行的是 `bundle`

* module：我们手写的文件。
* chunk：Webpack 根据文件引用关系生成的中间文件。
* bundle：Webpack 处理后输出的最终文件，可直接在浏览器中运行。

### 二、filename 和 chunkFilename

1. `filename` 是一个很常见的配置，就是对应于 `entry` 里面的输入文件，经过 `webpack` 打包后输出文件的文件名；
2. `chunkFilename` 指未被列在 `entry` 中，却又需要被打包出来的 `chunk` 文件的名称。一般来说：这个 `chunk` 文件指的是要懒加载的代码（可以在 `output` 里面配置）
3. 总结：`filename` 指列在 `entry` 中，打包后输出的文件的名称；`chunkFilename` 指未被列在 `entry` 中，却又需要被打包出来的文件的名称

### 三、预请求和预加载

1. `preload chunk` 会在父 `chunk` 加载时，以并行方式开始加载。 `prefetch chunk` 会在父 `chunk` 加载结束后开始加载。
   `preload chunk` 具有中等优先级，并立即下载。`prefetch chunk` 在浏览器闲置时下载。
2. `preload chunk` 会在父 `chunk` 中立即请求，用于当下时刻。`prefetch chunk` 会用于未来的某个时刻。
3. 总结：`webpackChunkName` 是为预加载的文件取别名。`webpackPrefetch` 会在浏览器闲置时下载文件，`webpackPreload` 会在父 `chunk` 加载时并行下载文件。

### 四、hash、chunkHash 和 contentHash

> 哈希一般是结合 `CDN` 缓存来使用的。 如果文件内容改变的话， 那么对应文件哈希值也会改变， 对应的 `HTML` 引用的 `URL` 地址也会改变， 触发 `CDN` 服务器从源服务器上拉取对应数据， 进而更新本地缓存。

* hash： 计算是跟整个项目的构建相关，所有的文件共享一个 `hash`，一个文件发生改变，其他都会改变，`hash` 值是一个。
* chunkHash：跟 `hash` 差不多。区别在与 `chunkHash` 所有公共库的代码文件都用一个 `hash`，公共库的代码用一个 `hash`，当我们更新普通模块内容的时候，其他模块的 `hash` 值发生改变，但是公共模块的 `hash` 不会受到影响

```js
  // 简单配置如下
  {
    entry: {
      app: path.resolve('./src/main.js'),
      // 配置公共文件
      vender: ['./src/jquery.js']
    },
    output: {
      path: path.resolve('./love'),
      filename: 'js/[name].[chunkHash].js'
    },
  }
```

* contenthash：所有的文件的 `hash` 都是不一样的，哪个文件被改变，哪个文件的 `hash` 发生改变。 `index.js` 和 `index.css` 同为一个 `chunk`，如果 `index.js` 内容发生变化，但是 `index.css` 没有变化，打包后他们的 `hash` 都发生变化，这对 `css` 文件来说是一种浪费。 `contentHash` 将根据资源内容创建出唯一 `hash`，也就是说内容不变，`hash` 不变

* 总结：`hash` 要变一起变；`chunkhash` 公共内容 `hash` 不发生改变，其他一起变；`contenthash` 哪个文件内容发生变化，那么对应的 `hash` 才发生改变

### 五、webpack 指纹占位符

webpack 中有一些指纹占位符，比如以下配置：

```js
new MiniCssExtractPlugin({
  filename: 'css/[name].[hash].css',
  chunkFilename: 'css/[id].[hash].css',
}),
```

中括号中 `[name].[hash]`，其实就是一些占位符，其中 name 代表文件名称，hash 代码构建时生成的 hash 值，下面是完整的占位符表示

| 占位符名称  | 含义                                                          |
| ----------- | ------------------------------------------------------------- |
| name        | 文件名称                                                      |
| ext         | 资源后缀名                                                    |
| path        | 文件的相对路径                                                |
| folder      | 文件所在的文件夹                                              |
| hash        | 每次构建时生成一个唯一的 hash 值                     |
| chunkhash   | 根据 chunk 生成 hash 值，来源于同一个 chunk，则 hash 值就一样 |
| contenthash | 根据内容生成 hash 值，文件内容相同 hash 值就相同              |

### 六、path、publicPath、contentBase

> output.publicPath 和 devServer.publicPath

* output.publicPath：引用资源的前缀。
  * 就是项目要扔到服务器的哪个地址里面
* devServer.publicPath：静态文件的位置。
  * 表示的是打包生成的 静态文件 所在的位置
  * 配置了 `devServer.publicPath` 之后，打完包的项目会自动在请求地址上加上配置的那个文件夹名字
  * 比如说配置了 `address_v2`，那么此时请求的所有文件资源都是携带这个 `address_v2`，也就是说在你的请求地址最后面要加上`address_v2`，那么在服务器上也需要放这么一个文件夹，用来放置你打包完的项目
* devServer.contentBase：本地服务根目录。

### 七、webpack 处理 css 的一些介绍

> css loader （包括前处理器和后处理器）

* css 基础 loader

  * css-loader 和 style-loader

* css 前处理 less 两件套

  * less 和 less-loader

* css 前处理 sass 两件套

  * node-sass 和 sass-loader

* css 后处理 postcss 两件套

  * postcss-loader 和 autoprefixer
  * postcss 需要配置， 需要一个 postcss.config.js 配置文件

```javascript
module.exports = {
  plugins: [require('autoprefixer')],
};
```

本篇到此基本也就告一段落了，下一篇介绍 webpack 常用配置以及可能遇到的坑

---

---
url: /docs/03.工具/Webpack 相关/webpack-2.md
---

## 安装

* 推荐本地安装，不推荐全局安装
* 安装本地 Webpack：npm i webpack webpack-cli -D

## webpack 可以进行 0 配置

* 不需要配置任何东西，直接执行 webpack 就可以打包我们的代码
* 打包工具 -> 输出后的结果 (js 模块)
* 打包（支持 js 模块化）

## 手动配置 webpack

* 默认配置文件是 webpack.config.js
* 但是如果你不想使用这个文件也是可以的，可以使用 `--config webpack.other.js` 来让 webpack 使用其他的配置文件

## 传参

* 如果需要在命令行后面传参，需要使用 `--`

```sh
npm run build -- --config ./basics/webpack.config.js
```

## 配置 HTML

* 配置 HTML 需要用到 html-webpack-plugin 插件
* 基本用法如下：

```js
plugins: [
    new htmlWebpackPlugin({
      // 模板放的位置
      template: resolveFile('./src/index.html'),
      // 打包后的名字
      filename: 'index.html',
      minify: {
        // 删除属性的双引号
        removeAttributeQuotes: true,
        // 折叠空行
        collapseWhitespace: true,
      },
      hash: true,
    }),
  ],
```

## 配置 css

* 配置 css 需要配置 module，需要给 module 配置规则，所以需要在 rules 中配置
* loader 执行顺序，从右往左，从下到上
* style-loader 是将样式写入 style 标签里面
* css-loader 解析 @import 这种语法的
* 如果不想让 css 写入到 style 标签里面，需要抽离 css ，使用 mini-css-extract-plugin，然后替换 style-loader，并且配置 plugins

```js
new MiniCssExtractPlugin({
  // 抽离出来的文件名字
  filename: 'css/[name].[hash:8].css',
}),
```

* 自动添加浏览器前缀需要用到 autoprefixer 和 postcss-loader 两个插件
* 处理浏览器前缀，需要在解析 css 之前加上前缀，所以 post-loader 的顺序要写在 css-loader 后面
* 并且需要配置一个 postcss.config.js 配置文件（使用 post-loader 就会调用这个文件），当然也可以直接在 loader 的 options 里面配置

```js
{
  loader: 'postcss-loader',
  options: {
    ident: 'postcss',
    plugins: [require('autoprefixer')],
  },
},
```

* 压缩 css 需要使用插件 optimize-css-assets-webpack-plugin，[mini-css-extract-plugin](https://www.npmjs.com/package/mini-css-extract-plugin) 官网推荐的，这个需要配置在 optimization 里面，但是使用了它之后 js 就不会压缩了，还需要使用另外一个插件 uglifyjs-webpack-plugin 来压缩 js

```js
optimization: {
  minimizer: [
    // 压缩 css 需要使用它
    new OptimizeCssAssetsPlugin({}),
    // 然后还要手动压缩一下 js
    new UglifyJsPlugin({
      cache: true,
      // 使用多线程压缩，并发数量默认为 os.cpus().length - 1
      parallel: true,
      sourceMap: true
    }),
  ],
},
```

## 编译 js

* 编译 js 需要用到 babel-loader，然后需要 babel 的核心模块 @babel/core，需要一个转换 es5 的模块 @babel/preset-env，所以需要执行下面的命令

```sh
npm i babel-loader @babel/core @babel/preset-env -D
```

* @babel/preset-env 是需要放在 presets 里面的
* @babel/plugin-proposal-decorators [类的装饰器](https://babeljs.io/docs/en/babel-plugin-proposal-decorators#simple-class-decorator)

```js
plugins: [
  [
    '@babel/plugin-proposal-decorators',
    {legacy: false, decoratorsBeforeExport: true},
  ],
  // ['@babel/plugin-proposal-class-properties', {loose: true}],
],
```

* @babel/plugin-transform-runtime 这个包用来节省代码大小，可以把公共代码抽离出来
* @babel/runtime 生产时需要依赖这个包

```sh
npm install --save-dev @babel/plugin-transform-runtime
npm install --save @babel/runtime
```

* 默认 babel 不会编译 es6 以上的语法，此时需要加入 @babel/polyfill 模块来编译

```sh
npm install --save @babel/polyfill
```

### eslint

* 安装 eslint，然后在官网上找到 demo 进去可以自己根据情况配置一份 eslint 的配置，然后下载下来，放到根目录下面 .eslintrc.json

* loader 是从下到上从左到右的执行，eslint 也是校验 js 的，所以有 eslint-loader，但是校验语法我们要保证在最前面执行，所以可以增加配置项 enforce

```js
{
  // loader 是从下到上从左到右的执行
  test: /\.js$/,
  // 使用 enforce 可以改变 loader 的执行顺序，让监测代码保持最早先执行
  enforce: 'pre', // previous   post
  use: ['eslint-loader'],
},
{
  test: /\.js$/,
  use: ['babel-loader'],
  // 减少代码查找体积
  include: resolveFile('../'),
  // 排除编译代码的路径
  exclude: /node_modules/,
},
```

### 三方模块的处理

* loader 有几种类型，pre 在前面执行的 loader、normal 普通的 loader、内联 loader、后置 loader（postoader）
* 内联 loader ，比如说 jQuery 模块，我们想把 & 暴露到全局，比如说 window 对象上面，此时我们可以使用 expose-loader

```js
// import $ from 'jquery'
// 暴露给全局
import $ from 'expose-loader?$!jquery';
```

* 也可以直接在 webpack 中配置

```js
{
  test: require.resolve('jquery'),
  // 同 import $ from 'expose-loader?$!jquery' 写法
  use: 'expose-loader?$'
},
```

* 但是我们可能想把 $ 注入到所有的文件中，不需要每个文件都单独引一次了
* 那就需要在 plugins 中配置一个 webpack 自带的插件 ProvidePlugin

```js
// 全局注入
new webpack.ProvidePlugin({
  // 在每个模块中都注入 $
  $: 'jquery',
});
```

* 假如 cdn 引入了 jQuery，在项目中我又写了 import $ from 'jquery'。此时会把 jQuery 在打包到项目中，配置 externals 可以解决这个问题

```js
externals: {
  // cdn 引入了，但是我又 import $ from 'jquery'，这样会把 jQuery 有打包进去
  // 这么配置可以解决这个问题
  jquery: 'jQuery'
},
```

### 引入一个模块三种方法

1. expose-loader 暴露给 window
2. ProvidePlugin 注入到所有文件
3. externals 引入不打包

## 打包图片

### 引入图片

* 使用图片有三种情况

  * 在 js 中创建图片引入
  * 在 css 的 background 中使用
  * `<img src="" alt="">` 直接引入

### file-loader

* 处理图片我们可以用 file-loader 来处理文件

* file-loader 会在内部生成一张图片到 打包后的 目录下，并保持原来的名字

  * 如果在 HTML 中引入图片，但是打包完图片之后原 HTML 中的图片是找不到的，此时我们可以用 html-withimg-loader 来编译

    * 在这里可能会出一个问题 file-loader 4.2 的时候是没有这个问题的，但是 file-loader 5.0 以上会出现，图片地址返回了一个对象
    * `<img src={"default":"3e5e5663e90681a73033ca3e3ac17655.png"} alt="">`
    * 此时我们需要在 file-loader 中配置 options: {esModule: false} 便可以[解决这个问题](https://blog.csdn.net/qq_38702877/article/details/103384626)

    ```js
    {
      test: /\.(png|gif|jpg|bmp)$/,
      use: [{loader: 'file-loader', options: {esModule: false}}],
    }
    ```

* file-loader 主要作用是将这些文件复制到输出目录，并返回相对 URL，以便在代码中引用

  ```js
    module.exports = {
      module: {
        rules: [
          {
            test: /\.(png|jpg|gif|svg|eot|ttf|woff|woff2)$/, // 匹配需要处理的文件类型
            use: [
              {
                loader: 'file-loader',
                options: {
                  name: '[name].[hash:8].[ext]', // 生成文件的命名规则
                  outputPath: 'assets/', // 输出目录
                  publicPath: 'assets/', // 公共路径
                },
              },
            ],
          },
        ],
      },
  };
  ```

### url-loader

* 一般情况下图片处理不会使用 file-loader，一般使用 url-loader
* url-loader 可以做一个限制，当图片小于多少 k 的时候我们可以减少 http 请求，只用使用 base64 来转换图片，可用通过 name 来控制图片打包完后放到哪

```js
{
  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
  use: [
    {
      loader: 'url-loader',
      options: {
        // limit: 200 * 1024,
        limit: 200,
        esModule: false,
        name: 'img/[name].[hash:8].[ext]',
        // 只有图片需要配置 cdn
        // publicPath: '.'
      },
    },
  ],
},
```

### 背景图片地址对不上问题

* 当我们把 css、js、图片都分开打包放到不同的目录下面之后，发现了一个问题

  * css 中引入的背景图最后找图片去 css/ 目录下找 img 目录了所以图片找不到了
  * 此时我们可以在 MiniCssExtractPlugin.loader 中配置，publicPath 便可以[解决这个问题](https://blog.csdn.net/a806488840/article/details/80920291)

  ```js
  {
    test: /\.(le|c|sc|sa)ss$/,
    use: [
      {
        loader: MiniCssExtractPlugin.loader,
        options: {
          publicPath: '..',
        },
      },
      'css-loader',
      'postcss-loader',
    ],
  },
  ```

### html-withing-loader 引发的问题

* 使用 html-withing-loader 或者 html-loader 之后，html-webpack-plugin 的注入就会失效，此时假如我们注入好多东西就可能出问题
* 所以这两个 loader 用的时候考虑以下，因为他们是处理 HTML 中引入图片问题的
* 我们也可以不使用这个 loader，直接在 HTML 引入图片我们也可以直接注入一些变量引图片进来
* 直接使用 require 把图片引进来，对了新版本的需要加 default 哦

```html
<body>
  <img src="<%= require('../../images/webpack-resolve.png').default %>" alt="" />
</body>
```

### cdn 配置

* 假如项目中静态资源使用了 cdn，我们需要让项目中静态资源自动加上 cdn 的前缀，我们可以在 output.publicPath 中配置
* 如果只有图片配置了 cdn 我们可以在 url-loader 的 options 中单独配置 publicPath 字段

## 代码地址 - 基础相关

代码以存放到 github，[地址](https://github.com/fecym/relearn-webpack.git)，分支是 basis

基础暂时完结，下面是常用配置篇

## 配置多页

* 首先我们需要在 entry 中配置改为一个对象，然后不同页面的逻辑以不同的名字来命令
* 然后修改 output.filename 的配置不使用死的名字，改为 \[name].js
* 最后需要在 HTMLWebpackPlugin 插件中配置，打包后对应的 HTML 文件名字，有多个就多实例化一次 HTMLWebpackPlugin，然后在 配置项里面配置 chunks 配置需要引用的 js 文件

```js
// entry 配置
entry: {
  home: resolve('../src/index.js'),
  other: resolve('../src/other.js'),
},
// output 配置
output: {
  path: resolve('../love/'),
  filename: 'js/[name]-[hash:8].js',
},
// plugins 的配置
plugins: [
  new HTMLWebpackPlugin({
    template: resolve('../src/index.html'),
    filename: 'home.html',
    title: '多页面配置 - home',
    // 注意这个，引入哪个文件配置哪个 chunkname
    chunks: ['home']
  }),
  new HTMLWebpackPlugin({
    template: resolve('../src/index.html'),
    filename: 'other.html',
    title: '多页面配置 - other',
    chunks: ['other']
  })
]
```

## sourceMap

* 当我们代码编译之后出错了，然后查看错误信息，结果都是压缩后的代码，然后我们定位不到问题出在哪里，此时我们可以配置 devtool
* devtool 增加映射，可以帮助我们调试远程代码，他有几个选项
  * source-map：会单独生成一个 sourcemap 文件，出错了会标识当前报错的列和行
  * eval-source-map：不会生产单独的 sourcemap 文件，但是可以显示报错的行和列，集成在打包后的文件中
  * cheap-module-source-map：不会产生行和列，但是是一个单独的映射文件
  * cheap-module-eval-source-map：不会产生行和列，也不会产生文件，集成在打包后的文件中

## watch

* webpack 可以实时去监控我们打包的文件
* 我们只需要在配置中增加 watch: true，便可以，当然也是可以配置一些配置的，需要在 watchOptions 中配置

```js
// 实时去监控我们打包的文件
watch: true,
watchOptions: {
  // 每秒问多少次
  poll: 1000,
  // 防抖，500 ms 后在打包
  aggregateTimeout: 500,
  // 不需要监控那个文件
  ignored: /node_modules/
},
```

## 常用的小插件

* CleanWebpackPlugin
* copyWebpackPlugin
* bannerPlugin

### CleanWebpackPlugin

* 这个插件是一个可以用来删除文件一个插件
* 使用时候需要解构出来，以前版本不需要，目前版本都需要解构出来，配置是一个对象，可以不传递，默认值够用了
* 我还是喜欢使用 `rm -rf file` 来删除文件更加暴力一点

### copyWebpackPlugin

* 该插件可以把项目一些其他的文件原封不动的复制到打包后的目录下面，比如说项目中写了一些文档，我们就可以用这个插件处理一下

```js
// 参数是一个数组
new CopyWebpackPlugin([
  {
    from: resolve('../doc'),
    to: resolve('../love/doc'),
  },
]),
```

### bannerPlugin

* 这个插件是做版权的一个插件，可以让编译后的代码假如作者信息，说明是作者是谁 `/*! make 2020 by chengyuming */`

* 该插件是 webpack 内置的插件

```js
new webpack.BannerPlugin('make 2020 by chengyuming');
```

## 解决跨越

### http-proxy

* 在 node 中有 http-proxy 插件可以做代理，集成到了 webpack 中，可以直接拿来用
* 可以在 devServer 中配置 proxy，把我们的请求地址修改为服务器地址，同时也可以重写地址

```js
  // 后端 api 地址：http:localhost:3000/api/v2/user，
  devServer: {
    port: 8080,
    progress: true,
    open: true,
    contentBase: resolve('../love'),
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        pathRewrite: {
          // 重写地址
          '/api': '/api/v2/'
        }
      }
    }
  },
```

### mock 数据

* 如果只是想单纯的模拟数据，我们可以直接在 sevServer 中提供的钩子函数(before)中进行模拟，因为 webpack 也是 express 框架做的，所以我们可以直接模拟数据
* 在 before 中接受一个参数 app，就是我们的服务器

```js
devServer: {
  port: 8080,
  progress: true,
  open: true,
  contentBase: resolve('../love'),
  // 模拟数据
  before(app) {
    app.get('/api/user', (req, res) => {
      res.json({
        name: 'cym'
      })
    })
  }
},
```

### 使用 node 端跑 webpack

* 有些时候呢，我们有服务端，但是不想用代理来处理跨域，在服务端中启动 webpack，端口用服务端的端口
* 此时我们可以在服务器引入 webpack 把 webpack 以中间件的形式处理，此时需要一个插件 webpack-dev-middleware
* 然后我们把 webpack 处理成中间件然后交给 node 来处理，此时 node 服务跑起来后，webpack 也跑起来了，端口号同 node 服务的端口，此时就不会存在跨越问题了

```js
// node 端代码
const express = require('express');
const app = express();

const webpack = require('webpack');
const middle = require('webpack-dev-middleware');
// 引入 webpack 配置
const config = require('../config/webpack.config-proxy');
// 取得 webpack 的编译结果
const compiler = webpack(config);
// 把 webpack 编译结果处理成中间件交给node来处理
app.use(middle(compiler));

app.get('/api/v2/user', (req, res) => {
  res.json({ name: 'cym' });
});

app.listen(3000);
```

## 缩小查询范围

### extensions

* 在开发中，我们可能有时候不想写后缀名，但是也能找到我们想要的那个文件，此时我们可以配置 `resolve.extensions` 字段，来让 webpack 查找的时候自动配置对应的拓展名

```js
resolve: {
  // 记得加点哦
  extensions: ['.js', '.json', '.ts', '.jsx', '.css', '.scss', '.vue'],
},
```

### modules

* 我们可以在 webpack 中配置查的第三方包的路径，比如说我们 require 的时候默认找到的 node\_modules 下面的文件，也可以让他找其他目录下的文件
* 此时我们就需要在 resolve.modules 中配置，它是一个数组，可以配置多个
* 比如说我们配置了工具函数的文件夹 utils，utils 下面有个 a 方法，我们引用的时候就可以直接引入便可

```js
resolve: {
  modules: [path.resolve('node_modules'), resolve('../src/utils')],
}
// 其他文件
import a from 'a'
```

### alias

* 配置别名可以加快 webpack 查找模块的速度

* 别名是我们经常用的，比如说 src 目录我们会配置成 @，此时都是在 webpack 下面配置的

```js
resolve: {
  alias: {
    bootstrap: path.resolve(__dirname, 'node_modules/bootstrap/dist/css/bootstrap.css'),
    '@': resolve('../src/')
  }
}
```

### mainFields

* 默认情况下，webpack 查找模块，会找模块下面的 package.json 中的 main 字段，main 字段指向哪个地址那就是哪个地址，这个查看顺序其实也是可以更改的，比如说 bootstrap 他会默认找 `dist/js/bootstrap`，但是我们只想用他的样式，我们就需要把它改成默认查找 style 属性 `dist/css/bootstrap.css`

- 此时我们可以通过 mainFields 字段来控制查找的先后顺序

```js
resolve: {
  modules: [path.resolve('node_modules'), resolve('../src/utils')],
  alias: {
    // bootstrap: 'bootstrap/dist/css/bootstrap.css',
    '@': resolve('../src/')
  },
  // 控制查找的先后顺序
  mainFields: ['style', 'main']
},
```

### mainFiles

当目录下没有 package.json 文件时，我们说会默认使用目录下的 index.js 这个文件，其实这个也是可以配置的

```js
resolve: {
  mainFiles: ['index'], // 你可以添加其他默认使用的文件名
},
```

### resolveLoader

`resolveLoader` 用于配置解析 loader 时的 resolve 配置，默认的配置：

```js
module.exports = {
  resolveLoader: {
    modules: ['node_modules'],
    extensions: ['.js', '.json'],
    mainFields: ['loader', 'main'],
  },
};
```

我们可以配置 `resolveLoader.modules` 来减少我们自定义开发 loader 时的位置

```js
resolveLoader: {
  modules: ['node_modules', path.resolve(__dirname, 'loaders')]
},
```

## 环境变量

* 工作中我们经常会根据一些环境变量来区分是开发环境还是生产环境还是其他环境
* 比如说我们请求的接口地址，不同环境可能地址是不一样的，我们就可以根据环境变量来判断
* webpack 内置了一个插件可以帮我们实现这个功能 DefinePlugin 来定义一些常用的环境变量

```js
plugins: [
  new webpack.DefinePlugin({
    // 引号里面放入的其实是一个js的变量
    // DEV: 'dev' // console.log(dev)
    // DEV: '"dev"'
    DEV: JSON.stringify('dev'), // 'dev'
    FLAG: 'true',   // true
    EXPRESSION: '1+1', // 2
    EXPRESSION2: JSON.stringify('1+1'), // '1+1'
  }),
],
```

## 区分环境配置

* 有个 webpack-merge 插件可以帮我们合并配置，此时我们就可以区分环境来做不同的配置文件
* 然后根据传递的参数来启动相应的 webpack 配置文件
* 一般我们会有三个配置文件，开发环境、生产环境以及一个最基本的配置
* 在开发和生产环境的配置中直接把基础配置合并过来就可以了

```js
// 使用 webpack-merge 插件
const { smart } = require('webpack-merge');
const baseConf = require('./webpack.base.config');
module.exports = smart(baseConf, {
  // merge 了最基础的配置然后根据不同环境做不同的配置
});
```

* 然后使用的使用只需要在 package.json 文件中执行 webpack 的时候增加 config 参数来改变 webpack 要执行的配置文件

```json
{
  "scripts": {
    "start": "webpack-dev-server --config ./config/webpack.config-dev.js --mode development",
    "build": "rm -rf ./dist && webpack --config ./config/webpack.config-prod.js --mode production",
    "build:dev": "rm -rf ./dist && webpack --config ./config/webpack.config-prod.js --mode development"
  }
}
```

## 代码地址 - 配置相关

代码以存放到 github，[地址](https://github.com/fecym/relearn-webpack.git)，分支是 config

常用配置篇暂时完结，下面是项目优化篇

## noParse

* 当我们引入一个依赖，知道他里面没有其他的依赖，我们可以告诉 webpack 让他不去解析这个包的依赖关系，从而加速构建或者打包的速度

```js
module: {
  rules: [],
  // noParse: /jquery/,
  noParse: content => {
    return /jquery/.test(content);
  }
}
```

## exclude 和 include

* 可以设置 loader 解析文件要排除的哪些目录，比如 node\_modules
* 有排除就有包含，也可以设置让 loader 解析时只处理特定目录，比如 src 目录

## IgnorePlugin

* 这是 webpack 自带的一款插件，可以忽略掉 模块内部的引用，
* 比如插件 moment，该插件假如我们只用他格式化了一下时间，但是打包后看到项目明显变大了好多
* 它默认引入了所有语言包，可以配置忽略掉

```js
plugins: [new webpack.IgnorePlugin(/\.\/locale/, /moment/)];
```

* 此时我们会发现，之前设置 moment 的语言包实效了，此时我们就需要手动引入以下我们用到的语言包

```js
import moment from 'moment';
// 手动引入中文语言包
import 'moment/locale/zh-cn';
moment.locale('zh-cn');
const current = moment()
  .endOf('day')
  .fromNow();
```

## 动态链接库 DLLPlugin

* 有些第三方库比较大，每次打包都打包他们比较耗时，此时我们可以把第三方包先打包一下

* 这样做呢，每次打包的时候就会先去看看有没有打过包，如果打过了就直接走链接库，不需要给那些提取出来的包在打包了，打包一次可以一直使用，只要包的版本没变就可以一直使用

* 每次打包出来的模块，如果有暴露出来东西，我们可以把暴露出来的东西执行一个值，此时我们可以在 output 里面配置 library 给一个变量来接受

* 默认是用 var 声明了我们传递过去的变量，我们用默认就可以了

* 实现动态链接库需要以下几步：

  * 我们单独穿件一个 webpack 配置文件，作为动态链接库的配置，然后在 entry 中配置要做链接的库的名字或者路径
  * output 中配置打包后的名字和存放位置，定义 library 接受
  * 在 plugins 中配置 manifest.json 的映射地址，附上一个完整配置

  ```js
  const path = require('path');
  const resolve = dir => path.resolve(__dirname, dir);
  const webpack = require('webpack');
  module.exports = {
    entry: {
      react: ['react', 'react-dom'],
    },
    output: {
      filename: '[name].dll.js',
      path: resolve('../public/dll'),
      // 定义一个接受的变量
      library: '_dll_[name]',
      // libraryTarget: 'var', // var、this、umd、commonjs
    },
    plugins: [
      new webpack.DllPlugin({
        // name 要和 library 一样
        name: '_dll_[name]',
        // 映射路径
        path: resolve('../public/dll/[name].manifest.json'),
      }),
    ],
  };
  ```

  * 在主 webpack 配置中，新增动态链接库引用的插件

  ```js
  // 主 webpack 配置
  plugins: [
    // 引用 dll 插件
    new webpack.DllReferencePlugin({
      // 打包的时候先去找这么一个清单，如果找不到了在去打包
      manifest: require('../public/dll/react.manifest.json'),
    }),
  ];
  ```

  * 最后需要在 HTML 中引入打包的这个动态链接库的 js 文件
  * 不可能每次修改都去引，所以我们可以使用一个插件（add-asset-html-webpack-plugin）动态的注入的 HTML 里面

  ```js
  plugins: [
    new AddAssetHtmlPlugin([
      {
        // 要添加到编译中的文件的绝对路径，以及生成的HTML文件。支持 globby 字符串
        filepath: require.resolve(path.resolve(__dirname, '../public/dll/react.dll.js')),
        // 文件输出目录
        outputPath: 'dll',
        // 脚本或链接标记的公共路径
        publicPath: 'dll',
      },
    ]),
  ];
  ```

* 有一个要注意的地方，需要把 AddAssetHtmlPlugin 的配置写在 HTMLWebpackPlugin 插件的后面，不然可能不会把资源注入进去

## happypack

* happypack 可以实现多线程打包
* 之前在匹配的 js 的时候我们用 babel-loader 处理，现在改成 'happypack/loader?id=js' 后面加一个 id
* 然后在 plugins 中配置 happypack 的插件，然后把之前在 loader 中写配置写在 plugins 中，对应好想引的 id 就行
* 如果有多个 loader 需要开启多线程，那就多 new 几个 happypack 的实例即可，如果项目比较小的话，不推荐使用，因为在开启多线程也是需要时间的

```js
module: {
  rules: [
    {
      test: /\.js$/,
      // use: [
      //   {
      //     loader: 'babel-loader',
      //     options: {
      //       presets: ['@babel/preset-env', '@babel/preset-react'],
      //       plugins: ['@babel/plugin-transform-runtime'],
      //     },
      //   },
      // ],
      // 改用happypack
      use: 'Happypack/loader?id=js',
      include: resolve('../src/'),
    },
  ],
},
plugins: [
  new Happypack({
    // id 对应好
    id: 'js',
    // 把 js 写好的放到这里
    use: [
      {
        loader: 'babel-loader',
        options: {
          presets: ['@babel/preset-env', '@babel/preset-react'],
          plugins: ['@babel/plugin-transform-runtime'],
        },
      },
    ],
  }),
],
```

## webpack 自带的优化

* webpack 自身帮我们做了两个优化，都是在生产环境才做的优化
* import 在生产环境下，会自动去除没有删除没用的代码（tree-shaking），require 是不可以的
  * 比如说引用了一个代码，但是没有使用，webpack 打包后自动帮我们删除掉那份代码
* scope hosting 作用域提升，webpack 会帮我优化代码，比如说

```js
// 代码这么写
let a = 1
let b = 2
let c = 3
let d = a + b + c
// 在 webpack 中会自动省略，可以简化代码
console.log(d, '-----------')
// 编译之后的代码
... 省略其他的
})([
  function(e, t, r) {
    'use strict'
    r.r(t)
    console.log(6, '-----------')
  },
])
```

## 分割代码块

* 代码中不同文件出现相同的代码，我们可以把他们抽离出来，在 optimization.splitChunk 中可以配置代码抽离逻辑
* 在以前的配置中叫 commonChunkPlugins，在 webpack4 中改名字了

```js
optimization: {
  // 分割代码块
  splitChunks: {
    // 异步文件可以分割成几个模块
    maxAsyncRequest: 5,
    // 入口文件可以分割成几个模块
    maxInitialRequest: 3,
    // 缓存组
    cacheGroups: {
      // 公共的模块
      common: {
        // 从哪开始找
        chunks: 'initial',
        minSize: 0,
        // 使用多少次抽离
        minChunks: 2,
      },
  }
}
```

* 也可以专门配置第三方模块，而且可以设置权重

```js
// 第三方模块的抽离
vender: {
  // 设置权重
  priority: 1,
  test: /node_modules/,
  // 从哪开始找
  chunks: 'initial',
  minSize: 0,
  // 使用多少次抽离
  minChunks: 2,
}
```

## 懒加载

* webpack 提供了懒加载语法，在 Es 新版本中该语法也成为了规范 `import('./modules.js').then(res => {})`

```js
const btn = document.createElement('button');
btn.addEventListener('click', () => {
  import('./source.js').then(res => {
    console.log(res.default);
  });
});
btn.innerHTML = 'hello';
document.body.append(btn);
```

## 热更新

* 首先可以在 devServer 中配置 hot 为 true 开启热更新，然后在 plugins 里面配置 NamedModulesPlugin 和 HotModuleReplacementPlugin

```js
plugins: [
  // 查看那个模块更新了
  new webpack.NamedModulesPlugin(),
  // webpack 的热更新插件
  new webpack.HotModuleReplacementPlugin()
],
```

```log
# 可以看到 ./optimizers/src/source.js 模块更新了
[HMR] Updated modules:
app-63bb3ae5.js:1 [HMR]  - ./optimizers/src/source.js
```

## 源码地址 - 优化相关

代码以存放到 github，[地址](https://github.com/fecym/relearn-webpack.git)，分支是 optimizers

本篇到此基本也就告一段落了

---

---
url: /docs/03.工具/Webpack 相关/webpack-3.md
---

## 介绍

接前两篇，这篇文章介绍一些使用 Webpack 的小技巧，以及在实际业务场景中如何自定义 Loader 和 Plugin。由于最近工作比较忙，这篇笔记写得断断续续，可能有些杂乱，后续会不断优化。

## 小技巧：require.context

在开发项目时，如果需要引入很多文件，可以使用 require.context 函数创建一个文件引入的上下文。该函数接受三个参数：要搜索的目录、是否搜索子目录、匹配文件的正则表达式。

```js
// 语法如下
require.context(directory, (useSubdirectories = false), (regExp = /^\.\//));
```

* 该方法返回一个 `require` 函数，返回函数可以接受一个参数：`request`（满足 `require.context` 传参的文件地址）
* 返回函数拥有三个属性：`resolve、keys、id`
  * `resolve` 是一个函数，它返回 `request` 被解析后得到的模块 `id`。
  * `keys` 也是一个函数，返回一个数组，由所有可能被上下文模块处理的请求组成（满足 `require.context` 传参的文件相对路径，但是要是传入一个文件地址还是会报错，必须传入一个满足 `require.context` 传参的文件地址）
  * `id` 是上下文模块里面所包含的模块 `id`。它可能在使用 `module.hot.accept` 的时候被用到
* 更多详细信息可以参考[webpack 官网](https://webpack.docschina.org/guides/dependency-management/#require-context)

以 vue 项目来说，有下面目录结构我们来自动引入 route、store 以及自动注册全局组件

```text
  ├── src
  │   ├── views
  │   ├── components
  │   │   ├── Header.vue
  │   │   ├── ...
  │   │   └── other.vue
  │   ├── routes
  │   │   ├── modules
  │   │   │   ├── user.js
  │   │   │   ├── ...
  │   │   │   └── other.js
  │   │   └── index.js
  │   ├── stores
  │   │   ├── modules
  │   │   │   ├── user.js
  │   │   │   ├── ...
  │   │   │   └── other.js
  │   │   └── index.js
  │   └── App.vue
  └── ...
```

### 路由自动引入

自动引入路由，我们可以在 routes 目录下新建一个 requireAll.js，用来写引入路由逻辑

```js
const webpackContext = require.context('./modules', false, /\.js$/);
// 让返回的这个函数执行，并传入相关的每一个文件的地址（由ctx.keys返回的）
const requireAll = ctx => ctx.keys().map(ctx);
// requireAll 执行完毕其实就得到了我们要的 modules 文件下的所有文件，但是我们是 default 里面的内容
const moduleRoutes = requireAll(webpackContext).map(route => route.default);
// 考虑到有的路由可能定义为对象的情况
const routes = [];
moduleRoutes.forEach(moduleRoute => {
  // 考虑路由定义为对象的情况
  const moduleRoutes = Array.isArray(moduleRoute) ? moduleRoute : [moduleRoute];
  routes.push(...moduleRoutes);
});
// 最后暴露出去
export default routes;
```

### 全局组件注册

> 全局注册组件也是利用 `require.context` 来实现的，得到一个文件数组后，利用 `Vue.component` 注册一下即可

`假如有以下目录，components` 目录下的组件在全局都可通用

```js
import Vue from 'vue';
const webpackContext = require.context('../components', false, /\.vue$/);
const requireAll = ctx => ctx.keys().map(ctx);
// 文件名字处理为大写
const dealName = name => (name ? name.replace(/\w/, v => v.toUpperCase()) : '');
requireAll(webpackContext).forEach(componentModule => {
  // 因为是 export default 导出的模块
  const { default: component } = componentModule;
  // 文件所在的地址，我们要取到文件的名字，来定义文件的 name
  const { __file: file } = component;
  // 如果有name属性直接取name属性，没有我们需要处理文件地址的最后一段作为文件的name，且要大写
  const name = dealName(component.name) || dealName(file.slice(file.lastIndexOf('/') + 1, -4));
  Vue.component(name, component);
});
```

### 自动引入 vuex

```js
// 获取文件
const modulesFiles = require.context('./modules', false, /\.js$/);
// 处理 modules
const modules = modulesFiles.keys().reduce((modules, modulePath) => {
  // set './app.js' => 'app'
  const moduleName = modulePath.replace(/^\.\/(.*)\.\w+$/, '$1');
  // 获取模块
  const value = modulesFiles(modulePath);
  // 最终得到我们要的结果
  modules[moduleName] = value.default;
  return modules;
}, {});

export default modules;
```

## webpack loader

webpack 中 loader 用于对模块的源代码进行转换。loader 可以使你在 import 或 "load(加载)" 模块时预处理文件。因此，loader 类似于其他构建工具中"任务(task)"，并提供了处理前端构建步骤的得力方式。

loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript 或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS 文件！（摘自官网）

使用方法可以参考之前的文章或者查看[官网](https://webpack.docschina.org/concepts/loaders/)

接下来，我们开始开发 loader，新建一个项目，项目目录如下：

```text
  ├── loaders             # 我们自定义的 loader
  │   └── ...             # 各种 loader
  ├── src
  │   └── index.js        # 入口文件
  ├── babel.config.js     # babel配置文件
  ├── package.json        # 项目配置文件
  └── webpack.config.js   # webpack 配置
```

我们先在 loaders 目录下新建一个 loader1.js 作为我们的第一个 loader 来做开发

一个 loader 本质就是一个方法，接受一个参数，该参数就是根据正则规则匹配到得源代码的字符串形式，在这个函数我们可以处理这个源代码，然后返回一个我们处理好的结果，`该方法必须有返回值`

```js
// loader1.js
function loader(source) {
  // source 就是获取到的源代码
  console.log('loader -> source', source);
  return source;
}

module.exports = loader;
```

### 使用

在 webpack 中，loader 是配置在 module.rules 中，module.rules 的含义是创建模块的规则，module.rules 的值是一个数组，数组里每一项都描述了如何去处理部分文件。`loader` 就像一个翻译员，能将源文件经过转换后输出新的结果，并且一个文件还可以链式地经过多个翻译员翻译。

```js
module.exports = {
  // 省略其他配置
  module: {
    rules: [{ test: /\.js$/, use: 'babel-loader' }],
  },
};
```

loader 也支持传参，可以写在 use.options 中，也可以 ? 拼接参数

```js
module.exports = {
  // 省略其他配置
  module: {
    rules: [
      {
        test: /\.js$/,
        // use: 'babel-loader?a=b',
        use: {
          loader: 'babel-loader',
          options: { presets: ['@babel/preset-env'] },
        },
      },
    ],
  },
};
```

一般使用的话，我们只需要在 use 的时候写 loader 的名字（默认会在 node\_modules 下查找）或者写 loader 的路径，因为我们这个不是 npm 包是本地开发的，所以需要些绝对路径

```js
module.exports = {
  // 省略其他配置
  module: {
    rules: [
      {
        test: /\.js$/,
        use: path.resolve(__dirname, 'loaders', 'loader1.js'),
      },
    ],
  },
};
```

这么配置，在 rules 规则中显的比较臃肿，我们可以考虑配置 `resolveLoader`

`resolveLoader` 是专门用来解析 loader 的，跟 resolve 不一样的是 resolve 是专门用来解析模块的

我们可以在 webpack 中配置别名

```js
module.exports = {
  // 省略其他配置
  resolveLoader: {
    alias: {
      loader1: path.resolve(__dirname, 'loaders', 'loader1.js'),
    },
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: 'loader1',
      },
    ],
  },
};
```

其实上面这种写法和直接在 use 里面写路径是一样的，只是配置了别名，还是比较麻烦。其实我们还有更好的方案，配置 modules，配置 webpack 查找的地方，默认情况下是查找 `node_modules` 文件夹下，我们可以在这里把我们的 `loaders` 文件夹补充上，找不到 `node_modules` 后去 `loaders` 文件夹下查找

```js
module.exports = {
  // 省略其他配置
  resolveLoader: {
    modules: ['node_modules', path.resolve(__dirname, 'loaders')],
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: 'loader1',
      },
    ],
  },
};
```

此时，我们就可以直接在 use 的配置项中直接写 loader 的文件名字了，webpack 在 node\_modules 目录下找不到后会自己去我们定义的 `loaders` 中查找

### 执行顺序

loader 执行顺序按照从后往前的顺序逆向执行的，当然 loader 的执行顺序也是可控的， 可以在 loader 中配置 `enforce` 参数为 `pre` 或者 `post` 来控制 loader 的执行的顺序

当然 loader 还有一种[内联 loader](https://webpack.docschina.org/concepts/loaders/#inline)，所以一般 loader 的执行顺序应该是：pre -> normal -> inline -> post

loader 默认是由两部分组成 pitchLoader 和 normalLoader，loader 执行的时候会先走 pitchLoader（从前面走到后面）然后获取到我们的资源，然后在反过来执行（从后执行到前面）

所有的 loader 都是先走 pitch，不管是否配置了 `enforce` 属性，具体可以参考我的代码，代码地址在后面会全部贴出来

但是如果 pitchLoader 写了，并且有返回值，他会跳过后面的 loader 直接执行。

这段内容，先了解一下，具体需要参考代码调试查看结果

### loader 的特点

* 单一职责，一个 `loader` 只做一件事情，正因为职责越单一，所以 `loader` 的组合性强，可配置性好。
* `loader` 支持链式调用，上一个 `loader` 的处理结果可以传给下一个 `loader` 接着处理，上一个 `loader` 的参数 options 可以传递给下一个 loader，直到最后一个 loader，返回 webpack 所期望的 js 代码
* loader 是一个纯函数，不能有状态(外界的状态)

### 开发一个 loader

我们来实现一个比较常见的功能删除代码中所有 console 打印，我们使用 ast 来实现这个功能，整个过程我们分为以下几步：

* 新建一个 removeConsole.js 文件
* 在 [`astexplorer`](https://astexplorer.net/) 中分析 `console` 语法树，找到 `console` 相关的特征
* 在代码中匹配到 console 语句，然后移除即可

最重要的阶段是分析语法树，我们是要分析 console 相关的执行语句，删除控制台中所有 console 的输出(log、error、warning 等)，所以拿 `console.log()` 为例分析语法树，下图为 console.log() 解析后的语法树

在语法树中我们发现 `console.log()` 是一个调用表达式 `CallExpression`，`CallExpression` 的 `callee` 是个成语表达式 `MemberExpression`，成语对象的标识符 `Identifier` 是 `console`，既然我们找到它了，那么在这个节点把它移除掉就可以。所以我们就可以按照写 ast 的那套流程在代码中这么写，最后把我们写好的这个 `removeConsole` loader 配置到 webpack 中就可以使用了

```js
const babel = require('@babel/core');
const t = require('@babel/types');

function loader(source) {
  const removeConsolePlugin = {
    visitor: {
      CallExpression(path) {
        const { callee } = path.node;
        if (t.isMemberExpression(callee) && t.isIdentifier(callee.object, { name: 'console' })) {
          path.remove();
        }
      },
    },
  };
  const ret = babel.transform(source, { plugins: [removeConsolePlugin] });
  return ret.code;
}

module.exports = loader;
```

如果你还不熟悉 ast 的话，可以查看我之前写过一篇[`关于 ast 的文章`](https://chengyuming.cn/views/webpack/AST.html)

### 异步写法

loader 也可以使用异步写法，只需要使用 `this.async` 来获取 callback 函数即可，我们使用异步的方式重新写一下 `removeConsole` 这个 loader ，这次使用正则替换内容

```js
function loader(source) {
  // 异步写法
  const callback = this.async();
  const consoleReg = /console\..+\(.+\)/g;
  const result = source.replace(consoleReg, '');
  callback(null, result);
}
module.exports = loader;
```

### loader 之间的关系

* 当我们编译 `js` 的时候我们会用 `babel-loader` 和 `@babel/core` 最少两个依赖，编译 `less` 的时候，会用 `less-loader` 和 `less` 最少两个包，为什么呢？

* 比如说 `@babel/core` 和 `babel-loader` 的关系，`@babel/core` 是核心编译 `babel-loader` 是把接受到的 `ctx` 传给`@babel/core`

```js
// babel-loader 和 @babel/core 的关系
function babelLoader(ctx) {
  return babelCore(ctx);
}
```

### loader-utils

loader 传递的参数可以在编写的 loader 的时候，使用 this.query 获取到传递过来的参数，但是都从 this.query 中获取可能会有点麻烦，所以 webpack 提供了一个库 `loader-utils` 专门处理 loader 的各种工具方法

使用 `loader-utils` 来处理 loader 参数的话，不管传递过来是字符串形式(?a=b)的还是对象形式的({a:b})参数都会给我们转成对象形式的参数，只需要使用他的 getOptions API 即可

模拟一个 babel-loader 的实现，传递参数 `presets: ['@babel/preset-env']`，`babel-loader` 的核心就是使用 babel 的核心转换源代码

```js
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: {
          loader: 'babel-loader',
          options: { presets: ['@babel/preset-env'] },
        },
      },
    ],
  },
};

// babel-loader.js
const loaderUtils = require('loader-utils');
const babel = require('@babel/core');
function loader(source) {
  // loader 传递过来的参数在 this 上可以获取到
  // console.log(this.query);
  const callback = this.async();
  const options = loaderUtils.getOptions(this);
  babel.transform(source, { ...options }, (err, result) => {
    // 可以把 sourceMap 返回去，如果需要 sourceMap，需要设置 devtool为 'source-map',
    callback(err, result.code, result.map);
  });
}

module.exports = loader;
```

### 处理样式

loader 中样式处理常见的有 less-loader、css-loader、style-loader，less-loader 负责把 less 语法编译成 css 代码，style-loader 负责把 css 代码插入到 html 标签内，css-loader 处理的事情比较多，比如背景图的路径处理

他们实现也是蛮简单

```js
// less-loader
const less = require('less');
function loader(source) {
  const callback = this.async();
  less.render(source, (err, result) => {
    callback(err, result.css);
  });
}
module.exports = loader;

// style-loader
function loader(source) {
  const result = `
    const style = document.createElement('style');
    style.innerHTML = ${JSON.stringify(source)};
    document.head.appendChild(style)
  `;
  return result;
}
module.exports = loader;
```

### 处理文件

一般我们使用 loader 来处理文本内容，loader 也是可以用来处理文件(二进制)。比如说 file-loader、url-loader 等，file-loader 作用就是劫持到引入的文件，然后生成新的文件到我们想要处理到的地方(比如 dist 目录)，然后返回一个路径。

在项目中我们可以用会用到各种格式的文件，一些常见的文件我们可以使用各种 loader 来处理，但是不同的业务也可能会遇到其他特殊的文件没有对应的 loader 处理，此时我们可以使用 file-loader 来处理，file-loader 会把源文件拷贝一份到 dist 目录下，不会存在副作用。

例如 create-react-app 脚手架中的 webpack 配置，会把没有匹配到的文件使用 file-loader 来处理

模拟一个 file-loader 的实现

在开发 loader 的时候接收的 source 参数默认会 toString 处理，处理文件或者二进制的时候我们就需要用到的是 buffer，不然就会乱码，此时需要告诉 loader 我们处理的文件内容是二进制

```js
const loaderUtils = require('loader-utils');
function loader(content) {
  console.log('loader -> content', content);
  const fileUrl = loaderUtils.interpolateName(this, '[hash].[ext]', { content });
  console.log('loader -> fileUrl', fileUrl);
  // 把文件发射到dist目录下
  this.emitFile(fileUrl, content);
  return `module.exports="${fileUrl}"`;
}
loader.raw = true;

module.exports = loader;
```

此时引入图片，然后打包结果为

相应的 url-loader 是专门用来处理图片，比如对图片的做一下限制，文件内容小于多少的图片可以直接转 base64

```js
const loaderUtils = require('loader-utils');
const mime = require('mime');
function loader(source) {
  const { limit } = loaderUtils.getOptions(this);
  if (limit > source.length) {
    // base64的格式：data:{文件格式};base64,{文件内容}
    const base64 = `data:${mime.getType(this.resourcePath)};base64,${source.toString('base64')}`;
    return `module.exports = "${base64}"`;
  } else {
    return require('./file-loader').call(this, source);
  }
}
loader.raw = true;

module.exports = loader;
```

此时引入图片文件小于配置的 15kb，文件被打包为 base64

## webpack plugins

webpack 配置中的 `plugins` 是一个数组，接收一组的 plugin，每一个 plugin 是一个类，使用时需要 new 这个插件类。

插件目的在于解决 loader 无法实现的其他事，`plugins` 专注处理 webpack 编译过程中某个特定的任务的功能模块

webpack 打包是一个事件流机制，是将各个插件串联起来，核心是用了 tapable。并且在 webpack 中负责编译的 Compiler 和负责创建 bundles 的 Compilation 都是 tapable 构造函数的实例。

### tapable

tapable 类似于 node 中的 EventEmitter，但更专注于自定义事件的触发和处理。

webpack 通过 tapable 将实现与流程解耦，所有具体实现通过插件的形式存在。tapable 中主要提供了同步与异步两种钩子

```js
const {
  SyncHook,
  SyncBailHook,
  SyncWaterfallHook,
  SyncLoopHook,
  AsyncParallelHook,
  AsyncParallelBailHook,
  AsyncSeriesHook,
  AsyncSeriesBailHook,
  AsyncSeriesWaterfallHook,
} = require('tapable');
```

以最简单的 SyncHook 为例：

```js
const { SyncHook } = require('tapable');
// 创建实例
const syncHook = new SyncHook(['name', 'age']);

// 注册事件
syncHook.tap('one', (name, age) => {
  console.log('one', name, age);
});
syncHook.tap('two', (name, age) => {
  console.log('two', name, age);
});

// 触发事件，让监听函数执行
syncHook.call('fecym', 25);
// one fecym 25
// two fecym 25
```

可以看到当我们执行 syncHook.call 时会依次执行前面 syncHook.tap 中的回调函数。通过 SyncHook 创建同步钩子，使用 tap 注册回调，再调用 call 来触发。这是 tapable 提供的多种钩子中比较简单的一种，通过 EventEmitter 也能轻松的实现这种效果。

其他同步钩子：

* SyncBailHook：类似于 SyncHook，执行过程中注册的回调返回非 undefined 时就停止不在执行。
* SyncWaterfallHook：接受至少一个参数，上一个注册的回调返回值会作为下一个注册的回调的参数。
* SyncLoopHook：有点类似 SyncBailHook，但是是在执行过程中回调返回非 undefined 时继续再次执行当前的回调。

tapable 中还有一些异步钩子，最基本的两个异步钩子分别是 AsyncParallelHook 和 AsyncSeriesHook。其他的异步钩子都是在这两个钩子的基础上添加了一些流程控制，类似于 SyncBailHook 之于 SyncHook 的关系。

具体了解 tapable 可以在下面的[参考链接](#参考链接)中具体查看

### Compiler 和 Compilation

在开发 plugin 时最常用的两个对象是 Compiler 和 Compilation。

Compiler 对象包含了` webpack 环境所有的配置信息`，如 options，loaders, plugins 这些项，该对象在 webpack 启动时候被实例化，它是全局唯一的。可以理解为 webpack 的实例。

Compilation 对象包含了当前的`模块资源、编译生成资源、文件的变化`等。当 webpack 在开发模式下运行时，每当检测到一个文件发生改变的时候，那么一次新的 Compilation 将会被创建。从而生成一组新的编译资源。

Compiler 对象的事件钩子以及作用

| 勾子            | 参数                       | 作用              | 类型  |
| --------------- | -------------------------- | ----------------- | ----- |
| after-plugins   | 设置完一组初始化插件之后   | compiler          | sync  |
| after-resolvers | 设置完 resolvers 之后      | compiler          | sync  |
| run             | 在读取记录之前             | compiler          | async |
| compile         | 在创建新 compilation 之前  | compilationParams | sync  |
| compilation     | compilation 创建完成       | compilation       | sync  |
| emit            | 在生成资源并输出到目录之前 | compilation       | async |
| after-emit      | 在生成资源并输出到目录之后 | compilation       | async |
| done            | 完成编译                   | stats             | sync  |

下面我们通过具体的案例了解一下 Compiler 和 Compilation 的使用。

### 实现一个资源分析插件

实现一个资源分析插件：在打包完成之后，统计所有打包后资源的大小

在 webpack 中使用插件的时候需要 new 这个插件，那么这个插件一定是个类(构造函数)。webpack 执行时，先生成插件的实例对象，之后会调用插件上的 apply 方法，并将 compiler 对象作为参数传递给 apply。因此这个构造函数有个核心的 apply 方法

我们要做一个资源分析的插件，所以是在生成资源后输出到目录之前注册一个事件，这个事件函数接收一个 compilation 对象，compilation.assets 是我们所有的资源文件对象，每一个对象里面都有 source 和 size 方法，我们可以这里面控制输出的资源

```js
class AssetsAnalysePlugin {
  constructor({ filename = 'analyse.md' }) {
    // 接收传递过来的参数
    this.filename = filename;
  }
  apply(compiler) {
    // 因为我们要统计打包后资源的大小，所以在生成资源后输出到目录之前注册事件
    compiler.hooks.emit.tap('AssetsAnalysePlugin', compilation => {
      const assets = compilation.assets;
      // 字符串拼接大法
      let content = `# 资源统计 \r\n\r\n| 资源名称 | 资源大小 |\r\n| ------ | ------ |`;
      let size = 0;
      const assetsEntries = Object.entries(assets);
      assetsEntries.forEach(([filename, fileObj]) => {
        content += `\r\n| ${filename} | ${fileObj.size()} b |`;
        size += fileObj.size();
      });
      content += `\r\n\r\n共有 ${assetsEntries.length} 个资源，共 ${(size / 1024).toFixed(2)} kb`;
      assets[this.filename] = {
        source() {
          return content;
        },
        size() {
          return content.length;
        },
      };
    });
  }
}

module.exports = AssetsAnalysePlugin;
```

用法

```js{10}
module.exports = {
  // ... 其他配置
  plugins: [
    new MiniCssExtractPlugin({ filename: 'css/[name].[hash:6].css' }),
    new HtmlWebpackPlugin({
      template: path.resolve('./public/index.html'),
      filename: 'index.html',
    }),
    // 使用我们的插件
    new AssetsAnalysePlugin({ filename: 'analyse.md' }),
  ],
};
```

### 实现一个静态资源替换插件

再来资源替换插件，熟悉一下 plugin 的开发。把打包后的静态资源替换成我们的 cdn 地址，或者服务器上的绝对地址

```js
// 需求：把所有的引入中的静态资源 static 变成 https://chengyuming.cn/
const fs = require('fs');
class StaticAssetsPlugin {
  constructor({ isProd = true, outputPath = 'dist', staticPath = 'static', cdnAddr = '/' }) {
    this.isProd = isProd;
    this.outputPath = outputPath;
    this.staticPath = staticPath;
    this.cdnAddr = cdnAddr;
  }
  apply(compiler) {
    if (!this.isProd) return;
    compiler.hooks.done.tapAsync('StaticAssetsPlugin', compilation => {
      const outputPath = compiler.options.context + '/' + this.outputPath;
      const assets = compilation.toJson().assets;
      const staticPathReg = new RegExp('([../]+)/' + this.staticPath + '/', 'g');
      assets.forEach(fileObj => {
        const filePath = outputPath + '/' + fileObj.name;
        console.log('apply -> filePath', filePath);
        fs.readFile(filePath, (err, res) => {
          if (err) throw err;
          let result = res.toString();
          result = result.replace(staticPathReg, this.cdnAddr);
          fs.writeFileSync(filePath, result);
        });
      });
    });
  }
}

module.exports = StaticAssetsPlugin;
```

```js
// webpack.config.js
const StaticAssetsPlugin = require('./plugins/StaticAssetsPlugin');
module.exports = function(env, argv) {
  return {
    // ... 其他配置
    plugins: [
      new StaticAssetsPlugin({
        isProd: true,
        outputPath: 'dist',
        staticPath: 'static',
        cdnAddr: 'https://chengyuming.cn/',
      }),
    ],
  };
};
```

```js
// 测试
const webpackContext = require.context('../static/imgs/', false, /\.(jpg|jpeg|png)$/);
const requireAll = ctx => ctx.keys().map(ctx);
const imgs = requireAll(webpackContext).map(r => r.default);

const fragment = document.createDocumentFragment();

imgs.forEach(item => {
  const img = new Image();
  img.src = `<img src="../static/${item}">`;
  fragment.appendChild(img);
});

document.getElementById('root').appendChild(fragment);
```

### 两个插件的结果

最终使用两个插件的结果如下：

`StaticAssetsPlugin` 的结果

`AssetsAnalysePlugin` 的结果

webpack 的 plugin 功能很强大，当然学习成本比较大，当你熟悉之后可以根据业务来实现各种你想要的功能

## 源码地址

代码已存放到 github，[地址](https://github.com/fecym/webpack-share)

## 相关链接

1. [珠峰架构课内容](http://www.zhufengpeixun.cn/)
2. [webpack loader](https://www.webpackjs.com/concepts/loaders/)
3. [webpack plugins](https://www.webpackjs.com/concepts/plugins/)
4. [Webpack 之 loader 配置详解](https://juejin.im/post/6847902222873788430)
5. [关于 tapable 你需要知道这些](https://zhuanlan.zhihu.com/p/79221553)
6. [webpack4 核心模块 tapable 源码解析](https://www.cnblogs.com/tugenhua0707/p/11317557.html)
7. [如何编写一个 WebPack 的插件原理及实践](https://www.cnblogs.com/tugenhua0707/p/11332463.html)
