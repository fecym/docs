import{_ as t,c as l,o,aN as r}from"./chunks/framework.B3J4P44d.js";const i="/docs/imgs/process-tcp-three-1.png",s="/docs/imgs/process-tcp-three-2.png",a="/docs/imgs/process-tcp-four-1.png",n="/docs/imgs/process-tcp-four-2.png",b=JSON.parse('{"title":"浏览器渲染流程","description":"","frontmatter":{"title":"浏览器渲染流程","date":"2019-08-01T00:00:00.000Z","permalink":"/FE/website-render","tags":["基础"],"categories":["前端"]},"headers":[],"relativePath":"01.前端/04. 浏览器/website-render.md","filePath":"01.前端/04. 浏览器/website-render.md","lastUpdated":1761308264000}'),c={name:"01.前端/04. 浏览器/website-render.md"};function g(m,e,h,d,u,p){return o(),l("div",null,e[0]||(e[0]=[r('<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /docs/01.前端/04. 浏览器/website-render.md for this page in Markdown format</div><h1 id="浏览器渲染流程" tabindex="-1">浏览器渲染流程 <a class="header-anchor" href="#浏览器渲染流程" aria-label="Permalink to &quot;浏览器渲染流程&quot;">​</a></h1><h2 id="简单流程" tabindex="-1">简单流程 <a class="header-anchor" href="#简单流程" aria-label="Permalink to &quot;简单流程&quot;">​</a></h2><blockquote><p>从输入 url 到页面呈现会经过几个步骤：DNS 解析 -&gt; TCP 连接 -&gt; 发送 HTTP 请求 -&gt; 服务器处理请求并返回 -&gt; 浏览器解析渲染页面 -&gt; TCP 断开连接</p></blockquote><h2 id="url" tabindex="-1">URL <a class="header-anchor" href="#url" aria-label="Permalink to &quot;URL&quot;">​</a></h2><ul><li><strong>URL</strong>（<em>Uniform Resource Locator</em>），统一资源定位符，用于定位互联网上资源，俗称网址</li><li>一个基本的<strong>URL</strong>由以下几部分组成 <ol><li>协议部分（<em>protocol</em>）：常见的协议有 <em>http、https、ftp、file</em>，其中最常见的类型是 <em>http</em>，而 <em>https</em> 则是进行加密的网络传输</li><li>域名部分（<em>domain</em>）：该 URL 的域名部分为 <em>www.aspxfans.com</em>。一个 URL 中，也可以使用 IP 地址作为域名使用，<em>www</em> 也是 <em>http</em> 的默认主机（<em>host</em>）</li><li>端口部分（<em>port</em>）：跟在域名后面的是端口，域名和端口之间使用<code>:</code>作为分隔符，端口省略则默认为<em>80</em></li><li>目录部分（<em>pathname</em>）：定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）</li><li>参数部分（<em>search</em>）：从<code>?</code>开始到<code>#</code>为止之间的部分为参数部分，又称搜索部分、查询部分，参数可以允许有多个参数，参数与参数之间用<code>&amp;</code>作为分隔符。</li></ol></li></ul><h2 id="域名解析-dns" tabindex="-1">域名解析（DNS） <a class="header-anchor" href="#域名解析-dns" aria-label="Permalink to &quot;域名解析（DNS）&quot;">​</a></h2><blockquote><p>在浏览器输入网址后，首先要经过域名解析，因为不可能直接通过域名找到对应的服务器，而是要通过 <em>IP</em> 地址</p></blockquote><h3 id="什么是域名解析" tabindex="-1">什么是域名解析 <a class="header-anchor" href="#什么是域名解析" aria-label="Permalink to &quot;什么是域名解析&quot;">​</a></h3><blockquote><p><em>DNS</em> 协议提供通过域名查找 <em>IP</em> 地址，或者逆向从 <em>IP</em> 地址反查询域名的服务。<em>DNS</em> 是一个网络服务器，我们的域名解析简单来说就是在 <em>DNS</em> 上记录一条信息 例如：<code>baidu.com 220.114.23.56（服务器外网 IP 地址）80（服务器端口号）</code></p></blockquote><h3 id="浏览器如何通过域名去查询-url-对应的-ip" tabindex="-1">浏览器如何通过域名去查询 URL 对应的 IP <a class="header-anchor" href="#浏览器如何通过域名去查询-url-对应的-ip" aria-label="Permalink to &quot;浏览器如何通过域名去查询 URL 对应的 IP&quot;">​</a></h3><ul><li><p>浏览器缓存：浏览器会按照一定的频率缓存 <em>DNS</em> 记录（缓存时间比较短，大概只有 1 分钟，且只能容纳 1000 条缓存）</p><ul><li>chrome 的 dns 缓存：<code>chrome://net-internals/#dns</code></li></ul></li><li><p>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</p><ul><li>如果在 <em>Windows</em> 系统的<strong>DN</strong>S 缓存也没有找到，那么尝试读取<strong>hosts</strong>文件</li><li>介绍下<strong>hosts</strong>：</li><li>为了提高对经常访问的网络域名的解析效率，可以通过利用 <em>hosts</em> 文件中建立域名和 IP 的映射关系来达到目的</li><li>在进行 <em>DNS</em> 请求以前，<em>Windows</em> 系统会先检查自己 <em>hosts</em> 文件中是否有这个网路域名映射关系，<em>hosts</em> 文件请求级别高于 <em>DNS</em></li><li><em>hosts</em> 文件位置：<code>C:\\Windows\\System32\\drivers\\etc</code></li></ul></li><li><p>路由缓存：路由器中也有 <em>DNS</em> 缓存</p></li><li><p><strong>ISP</strong>的<strong>DNS</strong>服务器：<strong>ISP</strong>是互联网服务提供商（<em>Internet Service Provider</em>）的简称，<strong>ISP</strong>有专门的<strong>DNS</strong>服务器应对<strong>DNS</strong>请求</p></li><li><p>根服务器：<strong>ISP</strong>的<strong>DNS</strong>还找不到的话，就会向根服务器发起请求，进行递归查询（<em>DNS</em> 服务器先问根域名服务器 <code>主域(com)</code> 名服务器的 IP 地址，然后在问<code>子域</code>的 IP 地址）</p></li><li><p>浏览器通过向<strong>DNS</strong>服务器发送域名，<strong>DNS</strong>服务器查询到与域名相对应的<strong>IP</strong>地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给服务器</p></li></ul><h2 id="tcp-三次握手" tabindex="-1">TCP 三次握手 <a class="header-anchor" href="#tcp-三次握手" aria-label="Permalink to &quot;TCP 三次握手&quot;">​</a></h2><blockquote><p>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。</p><ul><li>客户端发送一个带<strong>SYN=1，Seq=X</strong>的数据包到服务器（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li><li>服务器返回一个带<strong>SYN=1，ACK=X+1，Seq=Y</strong>的响应以表示确认信息（第二次握手，由服务器发起，告诉浏览器我准备接收了，你赶紧发送吧）</li><li>客户端再回传一个带<strong>ACK=Y+1，Seq=Z</strong>的数据包，代表握手结束（第三次握手，由浏览器发送，告诉服务器，我马上就发送了，准备接收吧）</li><li>为什么要三次握手？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</li></ul></blockquote><p align="center" class="p-images"><img src="'+i+'"></p><ul><li><strong>客户端</strong>首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示<strong>客户端</strong>自己的初始序号（seq = 0 就代表这是第 0 号帧），这时候<strong>客户端</strong>进入 syn_sent 状态，表示客户端等待服务器的回复</li><li><strong>服务器</strong>监听到连接请求报文后，如同意建立连接，则向<strong>客户端</strong>发送确认。TCP 报文首部中的 SYN 和 ACK 都置 1 ，ack = x + 1 表示期望收到对方下一个报文段的第一个数据字节序号是 x+1，同时表明 x 为止的所有数据都已正确收到（ack=1 其实是 ack=0+1,也就是期望客户端的第 1 个帧），seq = y 表示<strong>服务器</strong>自己的初始序号（seq=0 就代表这是服务器这边发出的第 0 号帧）。这时服务器进入 syn_rcvd，表示服务器已经收到<strong>客户端</strong>的连接请求，等待<strong>客户端</strong>的确认。</li><li><strong>客户端</strong>收到确认后还需再次发送确认，同时携带要发送给<strong>服务器</strong>的数据。ACK 置 1 表示确认号 ack= y + 1 有效（代表期望收到服务器的第 1 个帧），<strong>客户端</strong>自己的序号 seq= x + 1（表示这就是我的第 1 个帧，相对于第 0 个帧来说的），一旦收到<strong>客户端</strong>的确认之后，这个 TCP 连接就进入 Established 状态，就可以发起 http 请求了。</li></ul><p align="center" class="p-images"><img src="'+s+'"></p><h2 id="发送-http-请求" tabindex="-1">发送 HTTP 请求 <a class="header-anchor" href="#发送-http-请求" aria-label="Permalink to &quot;发送 HTTP 请求&quot;">​</a></h2><blockquote><p>TCP 三次握手结束后，开始发送<strong>HTTP</strong>请求报文 请求报文由请求行、请求头、请求体三部分组成</p></blockquote><ul><li>请求行包含请求方法、url、协议版本 <ul><li>请求方法包含 8 中：<em>GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE</em></li><li>url 就是请求地址：由 &lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 组成</li><li>协议版本就是 <em>http</em> 版本号</li></ul></li><li>请求头包含附加信息，由键值对组成，每行一对</li><li>请求体，就是前端的请求参数，不是所有的请求都具有请求数据的</li></ul><h2 id="服务器处理请求并返回-http-报文" tabindex="-1">服务器处理请求并返回 HTTP 报文 <a class="header-anchor" href="#服务器处理请求并返回-http-报文" aria-label="Permalink to &quot;服务器处理请求并返回 HTTP 报文&quot;">​</a></h2><ul><li>响应报文由响应行、响应头、响应主体三个部分组成</li><li>响应行包括：协议版本、状态码、状态描述 <ul><li>状态码规则：</li><li>1xx：指示信息--表示请求已接收，继续处理</li><li>2xx：成功--表示请求已被成功接收、理解、接受</li><li>3xx：重定向--要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误--请求有语法错误或请求无法实现</li><li>5xx：服务器端错误--服务器未能实现合法的请求</li></ul></li><li>响应头包含响应报文的附加信息，由键值对组成</li><li>响应体就是后台返回的数据，并不是所有响应报文都有响应数据</li><li>服务器端 WEB 程序接收到 http 请求以后，就开始处理该请求，处理之后就返回给浏览器 html 文件。</li></ul><h2 id="浏览器解析渲染页面" tabindex="-1">浏览器解析渲染页面 <a class="header-anchor" href="#浏览器解析渲染页面" aria-label="Permalink to &quot;浏览器解析渲染页面&quot;">​</a></h2><blockquote><p>浏览器拿到响应后来的 <strong>HTML</strong> 后，就开始解析其中的 html 代码，浏览器解析渲染页面分为一下五个步骤：</p><ul><li>根据 HTML 解析出 DOM 树</li><li>根据 CSS 解析生成 CSS 规则树</li><li>根据 DOM 树和 CSS 规则树生成渲染树</li><li>根据渲染树计算每个节点的信息</li><li>根据计算好的信息绘制页面</li></ul></blockquote><h3 id="根据-html-解析出-dom-树" tabindex="-1">根据 HTML 解析出 DOM 树 <a class="header-anchor" href="#根据-html-解析出-dom-树" aria-label="Permalink to &quot;根据 HTML 解析出 DOM 树&quot;">​</a></h3><ul><li>根据 HTML 的内容，讲标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即构建完当前节点的所有子节点，在构建下一个兄弟节点</li><li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到<strong>script</strong>标签，则 DOM 树的构建就会暂停，直到脚本执行完毕</li></ul><h3 id="根据-css-解析生成-css-规则树" tabindex="-1">根据 CSS 解析生成 CSS 规则树 <a class="header-anchor" href="#根据-css-解析生成-css-规则树" aria-label="Permalink to &quot;根据 CSS 解析生成 CSS 规则树&quot;">​</a></h3><ul><li>解析 CSS 规则树时，<strong>js</strong>的执行将暂停，直至 CSS 规则树就绪。<a href="/docs/views/basis/css.html#css-加载会造成阻塞吗">查看细节</a></li><li>浏览器就 CSS 规则树生成之前不渲染</li></ul><h3 id="根据-dom-树和-css-规则树生成渲染树" tabindex="-1">根据 DOM 树和 CSS 规则树生成渲染树 <a class="header-anchor" href="#根据-dom-树和-css-规则树生成渲染树" aria-label="Permalink to &quot;根据 DOM 树和 CSS 规则树生成渲染树&quot;">​</a></h3><ul><li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li><li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li></ul><h3 id="根据渲染树计算每一个节点的信息" tabindex="-1">根据渲染树计算每一个节点的信息 <a class="header-anchor" href="#根据渲染树计算每一个节点的信息" aria-label="Permalink to &quot;根据渲染树计算每一个节点的信息&quot;">​</a></h3><ul><li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li><li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li></ul><h3 id="根据计算好的信息绘制页面" tabindex="-1">根据计算好的信息绘制页面 <a class="header-anchor" href="#根据计算好的信息绘制页面" aria-label="Permalink to &quot;根据计算好的信息绘制页面&quot;">​</a></h3><ul><li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li><li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li><li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li></ul><h2 id="断开连接" tabindex="-1">断开连接 <a class="header-anchor" href="#断开连接" aria-label="Permalink to &quot;断开连接&quot;">​</a></h2><blockquote><p>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</p><ul><li>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li><li>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li><li>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li><li>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li></ul></blockquote><p align="center" class="p-images"><img src="'+a+'"></p><p align="center" class="p-images"><img src="'+n+'"></p><ul><li>断开连接端可以是客户端，也可以是<strong>服务端</strong>。假设<strong>客户端</strong>发起中断连接请求：</li><li>第一次挥手：<strong>客户端</strong>先发送 FIN 报文（第 24 帧），用来关闭主动方到被动关闭方的数据传送，也就是<strong>客户端</strong>告诉服务器：我已经不会再给你发数据了(当然，在 fin 包之前发送出去的数据，如果没有收到对应的 ack 确认报文，<strong>客户端</strong>依然会重发这些数据)，但此时<strong>客户端</strong>还可以接受数据。</li><li>第二次挥手：<strong>服务端</strong>接到 FIN 报文后，但是如果还有数据没有发送完成，则不必急着关闭 Socket，可以继续发送数据。所以服务器端先发送 ACK（第 25 帧），告诉<strong>客户端</strong>：请求已经收到了，但是我还没准备好，请继续等待停止的消息。这个时候<strong>客户端</strong>就进入 FIN_WAIT 状态，继续等待<strong>服务端</strong>的 FIN 报文。</li><li>第三次挥手：当<strong>服务端</strong>确定数据已发送完成，则向<strong>客户端</strong>发送 FIN 报文（第 26 帧），告诉<strong>客户端</strong>：服务器这边数据发完了，准备好关闭连接了。</li><li>第四次挥手：<strong>客户端</strong>收到 FIN 报文后，就知道可以关闭连接了，但是他还是不相信网络，所以发送 ACK 后进入 TIME_WAIT 状态（第 27 帧）， <strong>服务端</strong>收到 ACK 后，就知道可以断开连接了。<strong>客户端</strong>等待了 2MSL 后依然没有收到回复，则证明<strong>服务端</strong>已正常关闭，最后，<strong>客户端</strong>也可以关闭连接了至此，TCP 连接就已经完全关闭了！</li></ul><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/57895541" target="_blank" rel="noreferrer">经典面试题：从 URL 输入到页面展现到底发生什么？</a></li><li><a href="https://blog.csdn.net/sinat_21455985/article/details/53508115" target="_blank" rel="noreferrer">访问 Web，tcp 传输全过程（三次握手、请求、数据传输、四次挥手）</a></li></ul>',41)]))}const q=t(c,[["render",g]]);export{b as __pageData,q as default};
