window.__VP_HASH_MAP__=JSON.parse("{\"archives.md\":\"DiLN6JN2\",\"articleoverview.md\":\"BaiZl40g\",\"basic_api.md\":\"DvcHwYjj\",\"basic_array.md\":\"CuMyjC_g\",\"basic_css.md\":\"C14-xWTa\",\"basic_getport.md\":\"3__n9DtF\",\"basic_inherit.md\":\"BDnoqJHq\",\"basic_interview.md\":\"DCTbpdcg\",\"basic_issue.md\":\"CcDvC1fS\",\"basic_js.md\":\"CWfsJVBp\",\"basic_mapbox.md\":\"6HTi8-r2\",\"basic_modulo.md\":\"BfOUfg7K\",\"basic_promise.md\":\"Bxd5jH8f\",\"basic_tree.md\":\"q-9Bs30x\",\"basic_vite-plugin-unique-page-chunks.md\":\"BnXecfho\",\"basic_vue.md\":\"D9rv8_Nf\",\"categories.md\":\"BDHfHiRp\",\"fe_ast.md\":\"iQNqzWIP\",\"fe_cache.md\":\"6guAgGv5\",\"fe_jwt.md\":\"DmWMf4sA\",\"fe_website-render.md\":\"Dpl8U7dp\",\"git_git-1.md\":\"BcJr36Wm\",\"git_git-2.md\":\"C8260aRJ\",\"git_git-submodules.md\":\"DSn9JV7S\",\"index.md\":\"CLlSf1p2\",\"login.md\":\"lRWARfWc\",\"pages_118849.md\":\"CeaN3rzz\",\"pages_87aa9d.md\":\"lxqOHK47\",\"pages_9492f1.md\":\"gWpIA3hP\",\"risk-link.md\":\"Dgr783d7\",\"scriptures_sutra.md\":\"Cm3VYtYA\",\"service_conf.md\":\"B8OGDDzs\",\"service_crypto.md\":\"DHeEcrJ2\",\"service_fs.md\":\"CQUZX3Xd\",\"service_http.md\":\"4MP3jVOD\",\"service_https.md\":\"vdPkaUjn\",\"service_linux.md\":\"CKl0EFdO\",\"service_mysql.md\":\"DaaVxfyi\",\"service_nginx.md\":\"DDkcfuG1\",\"service_process.md\":\"BOP-6H8B\",\"service_proxy.md\":\"8cTXZnYd\",\"service_redis.md\":\"B_-Ev0OP\",\"service_vmware.md\":\"DW0F__ka\",\"tags.md\":\"CADjDn_W\",\"tools_command.md\":\"BZm7fPfL\",\"tools_eslint.md\":\"haegOlgj\",\"tools_npm-cli.md\":\"DbMNU4mg\",\"tools_npm-init.md\":\"BCJ1f2Oc\",\"tools_vue.md\":\"BkLFFzO0\",\"tools_webpack-1.md\":\"Db1dZ_YK\",\"tools_webpack-2.md\":\"-qBRTRXg\",\"tools_webpack-3.md\":\"B72WmK4o\"}");function deserializeFunctions(r){return Array.isArray(r)?r.map(deserializeFunctions):typeof r=="object"&&r!==null?Object.keys(r).reduce((t,n)=>(t[n]=deserializeFunctions(r[n]),t),{}):typeof r=="string"&&r.startsWith("_vp-fn_")?new Function(`return ${r.slice(7)}`)():r};window.__VP_SITE_DATA__=deserializeFunctions(JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"风起代码间\",\"description\":\"fecym 的技术博客：前端工程师，专注 Vue 全家桶与工程化 · 记录编码基础、CSS/HTML/JavaScript、Node、ECharts、Webpack/Vite · 覆盖 Git、Linux、MySQL、Nginx、ESLint、npm、面试与实用技巧\",\"base\":\"/docs/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"teekHome\":false,\"vpHome\":true,\"sidebarTrigger\":true,\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"footerInfo\":{\"theme\":{\"show\":false,\"name\":\"MIT Licensed | Copyright © 2019 - present \"},\"copyright\":{\"show\":true,\"createYear\":2019,\"suffix\":\"fecym · CC BY-NC-SA 4.0\"},\"icpRecord\":{\"name\":\"京ICP备19052475号\",\"link\":\"http://beian.miit.gov.cn\"}},\"codeBlock\":{\"copiedDone\":\"_vp-fn_(TkMessage) => TkMessage.success(\\\"\\\\u590D\\\\u5236\\\\u6210\\\\u529F\\\\uFF01\\\")\"},\"riskLink\":{\"enabled\":false,\"title\":\"即将离开，请注意财产安全\",\"whitelist\":[{}]},\"private\":{\"enabled\":false,\"realm\":{\"common\":[{\"username\":\"fecym\",\"password\":\"12345678910\",\"role\":\"admin\"}]}},\"siteAnalytics\":[{\"provider\":\"google\",\"options\":{\"id\":\"G-YWW3LNBLWQ\"}}],\"articleShare\":{\"enabled\":true},\"comment\":{\"provider\":\"giscus\",\"options\":{\"repo\":\"fecym/docs\",\"repoId\":\"MDEwOlJlcG9zaXRvcnkxOTUxOTUyNjI=\",\"category\":\"Announcements\",\"categoryId\":\"DIC_kwDOC6Jxfs4Cw9xT\"}},\"logo\":\"/logo-mini.svg\",\"darkModeSwitchLabel\":\"主题\",\"sidebarMenuLabel\":\"菜单\",\"returnToTopLabel\":\"返回顶部\",\"lastUpdatedText\":\"上次更新时间\",\"outline\":{\"level\":[2,4],\"label\":\"本页导航\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"前端\",\"link\":\"/basic/interview\",\"activeMatch\":\"/01.前端/\"},{\"text\":\"服务端\",\"link\":\"/service/linux\",\"activeMatch\":\"/02.服务端/\"},{\"text\":\"工具\",\"link\":\"/git/git-1\",\"activeMatch\":\"/03.工具/\"},{\"text\":\"经典\",\"link\":\"/scriptures/sutra\",\"activeMatch\":\"/04.经典摘录/\"},{\"text\":\"归档\",\"link\":\"/archives\"},{\"text\":\"清单\",\"link\":\"/articleOverview\"}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/fecym\"}],\"search\":{\"provider\":\"local\"},\"sidebar\":{\"/basic/\":[{\"text\":\"\",\"items\":[{\"text\":\" 基础\",\"items\":[{\"text\":\"面试题收录\",\"link\":\"/basic/interview.md\"},{\"text\":\"CSS 基础知识\",\"link\":\"/basic/css.md\"},{\"text\":\"JavaScript 继承\",\"link\":\"/basic/inherit.md\"},{\"text\":\"JavaScript 基础知识\",\"link\":\"/basic/js.md\"}]},{\"text\":\" 代码实现\",\"items\":[{\"text\":\"常用 api 的实现\",\"link\":\"/basic/api.md\"},{\"text\":\"数组 api 实现\",\"link\":\"/basic/array.md\"},{\"text\":\"实现一个 Promise\",\"link\":\"/basic/promise.md\"},{\"text\":\"Vue 2.x 版本源码分析\",\"link\":\"/basic/vue.md\"}]},{\"text\":\" 工作技巧\",\"items\":[{\"text\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"link\":\"/basic/modulo.md\"},{\"text\":\"工作遇到的小技巧\",\"link\":\"/basic/issue.md\"},{\"text\":\"如何优雅的解决端口被占用\",\"link\":\"/basic/getport.md\"},{\"text\":\"Mapbox 基本使用\",\"link\":\"/basic/mapbox.md\"},{\"text\":\"树在工作面试中的应用\",\"link\":\"/basic/tree.md\"},{\"text\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"link\":\"/basic/vite-plugin-unique-page-chunks.md\"}]},{\"text\":\" 浏览器\",\"items\":[{\"text\":\"AST 团队分享\",\"link\":\"/FE/ast.md\"},{\"text\":\"浏览器缓存\",\"link\":\"/FE/cache.md\"},{\"text\":\"常见的 HTTP 认证方式\",\"link\":\"/FE/jwt.md\"},{\"text\":\"浏览器渲染流程\",\"link\":\"/FE/website-render.md\"}]}]}],\"/service/\":[{\"text\":\"\",\"items\":[{\"text\":\"Linux 常用命令\",\"link\":\"/service/linux.md\"},{\"text\":\"MySQL 常用操作\",\"link\":\"/service/mysql.md\"},{\"text\":\"Nginx 相关\",\"items\":[{\"text\":\"反向代理与负载均衡\",\"link\":\"/service/proxy.md\"},{\"text\":\"Nginx 常用配置\",\"link\":\"/service/nginx.md\"}]},{\"text\":\"HTTP 笔记\",\"link\":\"/service/http.md\"},{\"text\":\"HTTPS 笔记\",\"link\":\"/service/https.md\"},{\"text\":\"node\",\"items\":[{\"text\":\"加密解密\",\"link\":\"/service/crypto.md\"},{\"text\":\"fs 文件系统\",\"link\":\"/service/fs.md\"},{\"text\":\"Process 对象\",\"link\":\"/service/process.md\"}]},{\"text\":\"Redis 小记\",\"link\":\"/service/redis.md\"},{\"text\":\"记一次购买服务器\",\"link\":\"/service/conf.md\"},{\"text\":\"虚拟机 日记\",\"link\":\"/service/vmware.md\"}]}],\"/git/\":[{\"text\":\"\",\"items\":[{\"text\":\"Git 相关\",\"items\":[{\"text\":\"Git 基础篇\",\"link\":\"/git/git-1.md\"},{\"text\":\"Git 进阶篇\",\"link\":\"/git/git-2.md\"},{\"text\":\"Git 子模块\",\"link\":\"/git/git-submodules.md\"}]},{\"text\":\"Npm 相关\",\"items\":[{\"text\":\"命令行参数是怎么解析的？\",\"link\":\"/tools/command.md\"},{\"text\":\"记一次开发自己的 cli\",\"link\":\"/tools/npm-cli.md\"},{\"text\":\"你应该了解的 npm 知识\",\"link\":\"/tools/npm-init.md\"}]},{\"text\":\"Webpack 相关\",\"items\":[{\"text\":\"一文带你打造eslint工作流\",\"link\":\"/tools/eslint.md\"},{\"text\":\"vue 项目的配置\",\"link\":\"/tools/vue.md\"},{\"text\":\"Webpack 基础篇\",\"link\":\"/tools/webpack-1.md\"},{\"text\":\"Webpack 进阶篇\",\"link\":\"/tools/webpack-2.md\"},{\"text\":\"Webpack 深入篇\",\"link\":\"/tools/webpack-3.md\"}]}]}],\"/scriptures/\":[{\"text\":\"\",\"items\":[{\"text\":\"空性与妙用：从一只杯子看世界本质\",\"link\":\"/scriptures/sutra.md\"}]}],\"/archives.md/\":[{\"text\":\"\",\"items\":[{\"text\":\"分类\",\"link\":\"/categories.md\"},{\"text\":\"loginPage\",\"link\":\"/login.md\"},{\"text\":\"riskLinkPage\",\"link\":\"/risk-link.md\"},{\"text\":\"标签\",\"link\":\"/tags.md\"}]}],\"/pages/\":[{\"text\":\"\",\"items\":[{\"text\":\"plugins\",\"items\":[{\"text\":\"Chrome 插件开发\",\"link\":\"/pages/9492f1.md\"},{\"text\":\"vscode 插件开发\",\"link\":\"/pages/118849.md\"}]}]}]},\"docAnalysisInfo\":{\"fileList\":[{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/01. 基础/1. interview.md\",\"relativePath\":\"01.前端/01. 基础/1. interview.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/01. 基础/css.md\",\"relativePath\":\"01.前端/01. 基础/css.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/01. 基础/inherit.md\",\"relativePath\":\"01.前端/01. 基础/inherit.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/01. 基础/javascript.md\",\"relativePath\":\"01.前端/01. 基础/javascript.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/02. 代码实现/api.md\",\"relativePath\":\"01.前端/02. 代码实现/api.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/02. 代码实现/array.md\",\"relativePath\":\"01.前端/02. 代码实现/array.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/02. 代码实现/promise.md\",\"relativePath\":\"01.前端/02. 代码实现/promise.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/02. 代码实现/vue-undone.md\",\"relativePath\":\"01.前端/02. 代码实现/vue-undone.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/03. 工作技巧/01.modulo.md\",\"relativePath\":\"01.前端/03. 工作技巧/01.modulo.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/03. 工作技巧/02.issue.md\",\"relativePath\":\"01.前端/03. 工作技巧/02.issue.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/03. 工作技巧/getport.md\",\"relativePath\":\"01.前端/03. 工作技巧/getport.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/03. 工作技巧/mapbox.md\",\"relativePath\":\"01.前端/03. 工作技巧/mapbox.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/03. 工作技巧/tree.md\",\"relativePath\":\"01.前端/03. 工作技巧/tree.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.md\",\"relativePath\":\"01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/04. 浏览器/AST.md\",\"relativePath\":\"01.前端/04. 浏览器/AST.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/04. 浏览器/cache.md\",\"relativePath\":\"01.前端/04. 浏览器/cache.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/04. 浏览器/jwt.md\",\"relativePath\":\"01.前端/04. 浏览器/jwt.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/04. 浏览器/website-render.md\",\"relativePath\":\"01.前端/04. 浏览器/website-render.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/01.linux.md\",\"relativePath\":\"02.服务端/01.linux.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/02.mysql.md\",\"relativePath\":\"02.服务端/02.mysql.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/Nginx 相关/nginx-requisite.md\",\"relativePath\":\"02.服务端/Nginx 相关/nginx-requisite.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/Nginx 相关/nginx.md\",\"relativePath\":\"02.服务端/Nginx 相关/nginx.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/http-undone.md\",\"relativePath\":\"02.服务端/http-undone.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/https-undone.md\",\"relativePath\":\"02.服务端/https-undone.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/node/crypto.md\",\"relativePath\":\"02.服务端/node/crypto.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/node/fs.md\",\"relativePath\":\"02.服务端/node/fs.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/node/process-undone.md\",\"relativePath\":\"02.服务端/node/process-undone.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/redis.md\",\"relativePath\":\"02.服务端/redis.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/service-conf.md\",\"relativePath\":\"02.服务端/service-conf.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/vmware-undone.md\",\"relativePath\":\"02.服务端/vmware-undone.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Git 相关/git-1.md\",\"relativePath\":\"03.工具/Git 相关/git-1.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Git 相关/git-2.md\",\"relativePath\":\"03.工具/Git 相关/git-2.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Git 相关/git-submodules.md\",\"relativePath\":\"03.工具/Git 相关/git-submodules.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Npm 相关/command.md\",\"relativePath\":\"03.工具/Npm 相关/command.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Npm 相关/npm-cli.md\",\"relativePath\":\"03.工具/Npm 相关/npm-cli.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Npm 相关/npm-init.md\",\"relativePath\":\"03.工具/Npm 相关/npm-init.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Webpack 相关/lint.md\",\"relativePath\":\"03.工具/Webpack 相关/lint.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Webpack 相关/vue.md\",\"relativePath\":\"03.工具/Webpack 相关/vue.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Webpack 相关/webpack-1.md\",\"relativePath\":\"03.工具/Webpack 相关/webpack-1.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Webpack 相关/webpack-2.md\",\"relativePath\":\"03.工具/Webpack 相关/webpack-2.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Webpack 相关/webpack-3.md\",\"relativePath\":\"03.工具/Webpack 相关/webpack-3.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/04.经典摘录/空性与妙用.md\",\"relativePath\":\"04.经典摘录/空性与妙用.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/intro.md\",\"relativePath\":\"intro.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/views/plugins/chrome.md\",\"relativePath\":\"views/plugins/chrome.md\"},{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/views/plugins/vscode.md\",\"relativePath\":\"views/plugins/vscode.md\"}],\"totalFileWords\":138087,\"eachFileWords\":[{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/01. 基础/1. interview.md\",\"relativePath\":\"01.前端/01. 基础/1. interview.md\"},\"wordCount\":3918,\"readingTime\":\"17m\",\"frontmatter\":{\"title\":\"面试题收录\",\"date\":{},\"permalink\":\"/basic/interview\",\"name\":\"面试题\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/01. 基础/css.md\",\"relativePath\":\"01.前端/01. 基础/css.md\"},\"wordCount\":6717,\"readingTime\":\"29.1m\",\"frontmatter\":{\"title\":\"CSS 基础知识\",\"date\":{},\"permalink\":\"/basic/css\",\"tags\":[\"css\",\"基础\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/01. 基础/inherit.md\",\"relativePath\":\"01.前端/01. 基础/inherit.md\"},\"wordCount\":5663,\"readingTime\":\"22.2m\",\"frontmatter\":{\"title\":\"JavaScript 继承\",\"date\":{},\"permalink\":\"/basic/inherit\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/01. 基础/javascript.md\",\"relativePath\":\"01.前端/01. 基础/javascript.md\"},\"wordCount\":4319,\"readingTime\":\"17.3m\",\"frontmatter\":{\"title\":\"JavaScript 基础知识\",\"date\":{},\"permalink\":\"/basic/js\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/02. 代码实现/api.md\",\"relativePath\":\"01.前端/02. 代码实现/api.md\"},\"wordCount\":2953,\"readingTime\":\"12.6m\",\"frontmatter\":{\"title\":\"常用 api 的实现\",\"date\":{},\"permalink\":\"/basic/api\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/02. 代码实现/array.md\",\"relativePath\":\"01.前端/02. 代码实现/array.md\"},\"wordCount\":3021,\"readingTime\":\"14.7m\",\"frontmatter\":{\"title\":\"数组 api 实现\",\"date\":{},\"permalink\":\"/basic/array\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/02. 代码实现/promise.md\",\"relativePath\":\"01.前端/02. 代码实现/promise.md\"},\"wordCount\":2585,\"readingTime\":\"11.7m\",\"frontmatter\":{\"title\":\"实现一个 Promise\",\"date\":{},\"author\":\"chengyuming\",\"permalink\":\"/basic/promise\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/02. 代码实现/vue-undone.md\",\"relativePath\":\"01.前端/02. 代码实现/vue-undone.md\"},\"wordCount\":871,\"readingTime\":\"3.7m\",\"frontmatter\":{\"title\":\"Vue 2.x 版本源码分析\",\"date\":{},\"author\":\"chengyuming\",\"permalink\":\"/basic/vue\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"vue\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/03. 工作技巧/01.modulo.md\",\"relativePath\":\"01.前端/03. 工作技巧/01.modulo.md\"},\"wordCount\":3746,\"readingTime\":\"14.3m\",\"frontmatter\":{\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":{},\"permalink\":\"/basic/modulo\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/03. 工作技巧/02.issue.md\",\"relativePath\":\"01.前端/03. 工作技巧/02.issue.md\"},\"wordCount\":5873,\"readingTime\":\"24.6m\",\"frontmatter\":{\"title\":\"工作遇到的小技巧\",\"date\":{},\"permalink\":\"/basic/issue\",\"tags\":[\"基础\",\"工作\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/03. 工作技巧/getport.md\",\"relativePath\":\"01.前端/03. 工作技巧/getport.md\"},\"wordCount\":2906,\"readingTime\":\"12.4m\",\"frontmatter\":{\"title\":\"如何优雅的解决端口被占用\",\"date\":{},\"permalink\":\"/basic/getport\",\"tags\":[\"webpack\",\"node\"],\"categories\":[\"前端\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/03. 工作技巧/mapbox.md\",\"relativePath\":\"01.前端/03. 工作技巧/mapbox.md\"},\"wordCount\":1704,\"readingTime\":\"7m\",\"frontmatter\":{\"title\":\"Mapbox 基本使用\",\"date\":{},\"permalink\":\"/basic/mapbox\",\"tags\":[\"可视化\"],\"categories\":[\"前端\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/03. 工作技巧/tree.md\",\"relativePath\":\"01.前端/03. 工作技巧/tree.md\"},\"wordCount\":4487,\"readingTime\":\"18.9m\",\"frontmatter\":{\"title\":\"树在工作面试中的应用\",\"date\":{},\"permalink\":\"/basic/tree\",\"tags\":[\"工作\",\"算法\"],\"categories\":[\"算法\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.md\",\"relativePath\":\"01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.md\"},\"wordCount\":3878,\"readingTime\":\"16.9m\",\"frontmatter\":{\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":{},\"permalink\":\"/basic/vite-plugin-unique-page-chunks\",\"tags\":[\"插件\",\"Vite\"],\"categories\":[\"前端\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/04. 浏览器/AST.md\",\"relativePath\":\"01.前端/04. 浏览器/AST.md\"},\"wordCount\":6153,\"readingTime\":\"26.2m\",\"frontmatter\":{\"title\":\"AST 团队分享\",\"date\":{},\"author\":\"fecym\",\"permalink\":\"/FE/ast\",\"tags\":[\"ast\"],\"categories\":[\"前端\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/04. 浏览器/cache.md\",\"relativePath\":\"01.前端/04. 浏览器/cache.md\"},\"wordCount\":2979,\"readingTime\":\"11.8m\",\"frontmatter\":{\"title\":\"浏览器缓存\",\"date\":{},\"permalink\":\"/FE/cache\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/04. 浏览器/jwt.md\",\"relativePath\":\"01.前端/04. 浏览器/jwt.md\"},\"wordCount\":3044,\"readingTime\":\"11.8m\",\"frontmatter\":{\"title\":\"常见的 HTTP 认证方式\",\"date\":{},\"permalink\":\"/FE/jwt\",\"tags\":[\"http\",\"基础\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/01.前端/04. 浏览器/website-render.md\",\"relativePath\":\"01.前端/04. 浏览器/website-render.md\"},\"wordCount\":3302,\"readingTime\":\"12m\",\"frontmatter\":{\"title\":\"浏览器渲染流程\",\"date\":{},\"permalink\":\"/FE/website-render\",\"tags\":[\"基础\"],\"categories\":[\"前端\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/01.linux.md\",\"relativePath\":\"02.服务端/01.linux.md\"},\"wordCount\":3720,\"readingTime\":\"14.3m\",\"frontmatter\":{\"title\":\"Linux 常用命令\",\"date\":{},\"permalink\":\"/service/linux\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/02.mysql.md\",\"relativePath\":\"02.服务端/02.mysql.md\"},\"wordCount\":1636,\"readingTime\":\"7m\",\"frontmatter\":{\"title\":\"MySQL 常用操作\",\"date\":{},\"permalink\":\"/service/mysql\",\"tags\":[\"MySQL\"],\"categories\":[\"MySQL\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/Nginx 相关/nginx-requisite.md\",\"relativePath\":\"02.服务端/Nginx 相关/nginx-requisite.md\"},\"wordCount\":2609,\"readingTime\":\"9.6m\",\"frontmatter\":{\"title\":\"反向代理与负载均衡\",\"date\":{},\"permalink\":\"/service/proxy\",\"tags\":[\"其他\"],\"categories\":[\"Nginx\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/Nginx 相关/nginx.md\",\"relativePath\":\"02.服务端/Nginx 相关/nginx.md\"},\"wordCount\":2571,\"readingTime\":\"9.7m\",\"frontmatter\":{\"title\":\"Nginx 常用配置\",\"date\":{},\"permalink\":\"/service/nginx\",\"tags\":[\"Nginx\"],\"categories\":[\"Nginx\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/http-undone.md\",\"relativePath\":\"02.服务端/http-undone.md\"},\"wordCount\":494,\"readingTime\":\"1.8m\",\"frontmatter\":{\"title\":\"HTTP 笔记\",\"name\":\"HTTP 笔记\",\"date\":{},\"permalink\":\"/service/http\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/https-undone.md\",\"relativePath\":\"02.服务端/https-undone.md\"},\"wordCount\":195,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"HTTPS 笔记\",\"date\":{},\"permalink\":\"/service/https\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/node/crypto.md\",\"relativePath\":\"02.服务端/node/crypto.md\"},\"wordCount\":757,\"readingTime\":\"3.1m\",\"frontmatter\":{\"title\":\"加密解密\",\"date\":{},\"permalink\":\"/service/crypto\",\"tags\":[\"其他\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"node\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/node/fs.md\",\"relativePath\":\"02.服务端/node/fs.md\"},\"wordCount\":3261,\"readingTime\":\"13m\",\"frontmatter\":{\"title\":\"fs 文件系统\",\"date\":{},\"permalink\":\"/service/fs\",\"tags\":[\"node\"],\"categories\":[\"node\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/node/process-undone.md\",\"relativePath\":\"02.服务端/node/process-undone.md\"},\"wordCount\":803,\"readingTime\":\"3m\",\"frontmatter\":{\"title\":\"Process 对象\",\"date\":{},\"permalink\":\"/service/process\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"node\"],\"categories\":[\"node\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/redis.md\",\"relativePath\":\"02.服务端/redis.md\"},\"wordCount\":1962,\"readingTime\":\"8.1m\",\"frontmatter\":{\"title\":\"Redis 小记\",\"date\":{},\"permalink\":\"/service/redis\",\"tags\":[\"其他\"],\"categories\":[\"Service\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/service-conf.md\",\"relativePath\":\"02.服务端/service-conf.md\"},\"wordCount\":4179,\"readingTime\":\"17.2m\",\"frontmatter\":{\"title\":\"记一次购买服务器\",\"date\":{},\"permalink\":\"/service/conf\",\"tags\":[\"Linux\"],\"categories\":[\"Service\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/02.服务端/vmware-undone.md\",\"relativePath\":\"02.服务端/vmware-undone.md\"},\"wordCount\":414,\"readingTime\":\"1.5m\",\"frontmatter\":{\"title\":\"虚拟机 日记\",\"date\":{},\"permalink\":\"/service/vmware\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"],\"private\":true,\"privateRealm\":\"common\"}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Git 相关/git-1.md\",\"relativePath\":\"03.工具/Git 相关/git-1.md\"},\"wordCount\":5080,\"readingTime\":\"19.4m\",\"frontmatter\":{\"title\":\"Git 基础篇\",\"date\":{},\"permalink\":\"/git/git-1\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Git 相关/git-2.md\",\"relativePath\":\"03.工具/Git 相关/git-2.md\"},\"wordCount\":4740,\"readingTime\":\"19m\",\"frontmatter\":{\"title\":\"Git 进阶篇\",\"date\":{},\"permalink\":\"/git/git-2\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Git 相关/git-submodules.md\",\"relativePath\":\"03.工具/Git 相关/git-submodules.md\"},\"wordCount\":5731,\"readingTime\":\"23.7m\",\"frontmatter\":{\"title\":\"Git 子模块\",\"date\":{},\"permalink\":\"/git/git-submodules\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Npm 相关/command.md\",\"relativePath\":\"03.工具/Npm 相关/command.md\"},\"wordCount\":1206,\"readingTime\":\"4.7m\",\"frontmatter\":{\"title\":\"命令行参数是怎么解析的？\",\"date\":{},\"permalink\":\"/tools/command\",\"tags\":[\"cli\",\"基础\",\"node\"],\"categories\":[\"基础\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Npm 相关/npm-cli.md\",\"relativePath\":\"03.工具/Npm 相关/npm-cli.md\"},\"wordCount\":1689,\"readingTime\":\"6.8m\",\"frontmatter\":{\"title\":\"记一次开发自己的 cli\",\"date\":{},\"permalink\":\"/tools/npm-cli\",\"tags\":[\"cli\",\"node\",\"npm\"],\"categories\":[\"npm\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Npm 相关/npm-init.md\",\"relativePath\":\"03.工具/Npm 相关/npm-init.md\"},\"wordCount\":2809,\"readingTime\":\"12.1m\",\"frontmatter\":{\"title\":\"你应该了解的 npm 知识\",\"date\":{},\"permalink\":\"/tools/npm-init\",\"tags\":[\"npm\"],\"categories\":[\"npm\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Webpack 相关/lint.md\",\"relativePath\":\"03.工具/Webpack 相关/lint.md\"},\"wordCount\":4516,\"readingTime\":\"19m\",\"frontmatter\":{\"title\":\"一文带你打造eslint工作流\",\"date\":{},\"author\":\"fecym\",\"permalink\":\"/tools/eslint\",\"tags\":[\"eslint\",\"node\"],\"categories\":[\"前端\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Webpack 相关/vue.md\",\"relativePath\":\"03.工具/Webpack 相关/vue.md\"},\"wordCount\":3520,\"readingTime\":\"15.1m\",\"frontmatter\":{\"title\":\"vue 项目的配置\",\"date\":{},\"permalink\":\"/tools/vue\",\"tags\":[\"webpack\",\"vue\"],\"categories\":[\"前端\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Webpack 相关/webpack-1.md\",\"relativePath\":\"03.工具/Webpack 相关/webpack-1.md\"},\"wordCount\":3845,\"readingTime\":\"15.4m\",\"frontmatter\":{\"title\":\"Webpack 基础篇\",\"date\":{},\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-1\"}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Webpack 相关/webpack-2.md\",\"relativePath\":\"03.工具/Webpack 相关/webpack-2.md\"},\"wordCount\":5798,\"readingTime\":\"23.5m\",\"frontmatter\":{\"title\":\"Webpack 进阶篇\",\"date\":{},\"tagsPage\":true,\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-2\"}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/03.工具/Webpack 相关/webpack-3.md\",\"relativePath\":\"03.工具/Webpack 相关/webpack-3.md\"},\"wordCount\":5330,\"readingTime\":\"22.3m\",\"frontmatter\":{\"title\":\"Webpack 深入篇\",\"date\":{},\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-3\"}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/04.经典摘录/空性与妙用.md\",\"relativePath\":\"04.经典摘录/空性与妙用.md\"},\"wordCount\":291,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":{},\"permalink\":\"/scriptures/sutra\",\"tags\":[\"人生\"],\"categories\":[\"经典\"]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/intro.md\",\"relativePath\":\"intro.md\"},\"wordCount\":988,\"readingTime\":\"4m\",\"frontmatter\":{\"date\":{},\"title\":\"关于博客\",\"sidebar\":false,\"article\":false,\"outline\":false,\"permalink\":\"/pages/87aa9d\",\"categories\":[null]}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/views/plugins/chrome.md\",\"relativePath\":\"views/plugins/chrome.md\"},\"wordCount\":0,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"Chrome 插件开发\",\"date\":{},\"tags\":[\"插件\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/9492f1\"}},{\"fileInfo\":{\"filePath\":\"/Users/fecym/code/blog/vite-docs/docs/views/plugins/vscode.md\",\"relativePath\":\"views/plugins/vscode.md\"},\"wordCount\":1824,\"readingTime\":\"7.1m\",\"frontmatter\":{\"title\":\"vscode 插件开发\",\"date\":{},\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"插件\"],\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/118849\"}}],\"lastCommitTime\":\"2026-02-12 13:58:56\"},\"catalogues\":{\"arr\":[],\"map\":{},\"inv\":{}},\"posts\":{\"allPosts\":[{\"url\":\"/basic/interview.html\",\"relativePath\":\"/01.前端/01. 基础/1. interview.html\",\"frontmatter\":{\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"permalink\":\"/basic/interview\",\"name\":\"面试题\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"capture\":\"1. 关于函数的 length 属性\\n360 面试过程遇到一个很有趣的问题，是关于函数的 length 属性的，题简写如下\\n```js\\n(() =\\n```\\n我所理解的拥有 `length` 的对象一般都是数组或者类数组对象，或者定义了 `length` 属性的对象，所以我回答说这个应该是 `false` 吧，后来面试告诉我函数是有 `length` 属性的，函数的 `length` 属性就是函数参数的个数，瞬间我恍然大悟，函数的参数就是 `arguments` ，而 `arguments` 也是一个类数组对象所以他是有 `length` 属性的\\n```js\\n// so\\n(() =&gt; 1)\"},{\"url\":\"/basic/css.html\",\"relativePath\":\"/01.前端/01. 基础/css.html\",\"frontmatter\":{\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"permalink\":\"/basic/css\",\"tags\":[\"css\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"capture\":\"css 加载会造成阻塞吗\\n\\n css 加载会造成 DOM 树的阻塞嘛？\\n- 首先，_css_ 加载会阻塞 _DOM_ 树渲染，但是 _css_ 并不会阻塞 _DOM_ 树的解析\\n- 也就是说，你可以在 _css_ 加载完之前可以在 _js_ 中获取到 _DOM_ 元素，但是 _DOM_ 却是没有渲染到页面上，需要等到 _css_ 加载完毕才渲染\\n- 为什么会这样？\\n  - 在你加载 _css_ 的时候，可能会修改 _DOM_ 节点的样式，如果 _css_ 加载不阻塞 _DOM_ 树渲染的话，那么当 _css_ 加载完之后， _DOM_ 树可有又得重绘或者回流了\\n  - 所以干脆先把 _DOM_\"},{\"url\":\"/basic/inherit.html\",\"relativePath\":\"/01.前端/01. 基础/inherit.html\",\"frontmatter\":{\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"permalink\":\"/basic/inherit\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"capture\":\"原型\\n 野史\\n&gt; 根据野史记载，Brendan Eich 用了一周的时间创造了今天的 JavaScript，当 Brendan Eich 在为 JavaScript 设计面向对象系统时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。而且 Brendan Eich 一开始就没有打算在 JavaScript 中加入类的概念，所以 JavaScript 是一门基于原型的语言。在原型编程的思想中，类并不是必须的，对象未必需要从类中创建而来，一个对象是通过另一个对象而得到的。\\n- 在曾探的《设计模式》中提到 JavaScript 中的原型继承会遵循以下这些原型编程的基本规则：\\n \"},{\"url\":\"/basic/js.html\",\"relativePath\":\"/01.前端/01. 基础/javascript.html\",\"frontmatter\":{\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"permalink\":\"/basic/js\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"capture\":\"类型转换\\n 一个有趣的问题\\n&lt;p align=\\\"center\\\" class=\\\"p-images\\\"\\n  &lt;img src=\\\"/imgs/basis-javascript-type-change.jpg\\\" height=\\\"260\\\" /&gt;\\n&lt;/p&gt;\\n&gt; 看到了这个我亲自尝试了下，结果发现自己对 js 基础越来越陌生了，现在好好复习下吧\\n```js\\n0 == '0'; // true\\n0 == []; // true\\n'0' == []; // false\\n```\\n 为什么？\\n&gt; 为什么 '0' == [] 是 false ？&lt;br&gt;\\n&gt; 为\"},{\"url\":\"/basic/api.html\",\"relativePath\":\"/01.前端/02. 代码实现/api.html\",\"frontmatter\":{\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"permalink\":\"/basic/api\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"capture\":\"实现一个 new 操作符\\n&gt; 函数执行前面加个 `new` 做了哪些事情，为啥就会构造一个对象出来\\n- 创建了一个新对象\\n- 链接到了原型\\n- 执行函数，绑定了 this 指向新创建的对象上\\n- 返回一个对象，如果函数中有`return`关键字，看 return 了什么出来，如果是一个对象，那么返回这个对象，如果不是则返回我们新建的这个对象\\n- 实现过程如下：\\n```js\\nfunction New() {\\n  // 创建了一个新对象\\n  const obj = {};\\n  // 取得构造函数\\n  const F = [].shift.call(arguments);\\n  // 链接到了原\"},{\"url\":\"/basic/array.html\",\"relativePath\":\"/01.前端/02. 代码实现/array.html\",\"frontmatter\":{\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"permalink\":\"/basic/array\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"capture\":\"在日常开发中，我们经常使用数组的 API。本文将详细介绍一些常用的数组操作方法，并提供其实现代码。\\n 任意位置插入单个成员\\n数组任意位置插入单个成员，这个 api 几乎可以作为数组插入的一个最基本的方法来处理，实现如下\\n按照数组 api 的规则，我们为数组增加了成员，那么要返回数组的长度\\n```js\\nfunction insert(arr, idx, item) {\\n  // 循环为什么要倒着写？看下面解释\\n  for (let i = arr.length - 1; i \\n    arr[i + 1] = arr[i];\\n  }\\n  arr[idx] = item;\\n  return arr\"},{\"url\":\"/basic/promise.html\",\"relativePath\":\"/01.前端/02. 代码实现/promise.html\",\"frontmatter\":{\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/promise\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"capture\":\"`promise` 的出现改变了以前 js 的回调风格。`promise` 核心是三种状态，`pending、resolve、reject`，状态一旦从 `pending` 变成其他状态则不可逆，其他用法细节将在实现 `promise` 的过程中一步步记录\\n 简单版 promise\\n- 首先我们实现函数异步函数执行的问题\\n```js\\n// 首先是三种状态\\nconst PENDING = 'pending';\\nconst RESOLVED = 'resolve';\\nconst REJECTED = 'reject';\\nfunction Promise(execute) {\\n  this.stat\"},{\"url\":\"/basic/vue.html\",\"relativePath\":\"/01.前端/02. 代码实现/vue-undone.html\",\"frontmatter\":{\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/vue\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"vue\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"capture\":\"数据劫持\\n 对象的劫持\\n2.x 版本的数据劫持是根据 Object.defineProperty 来实现的\\n```js\\nfunction observe(data) {\\n  // 不是对象直接返回\\n  if (!(typeof data === 'object' && data !== null)) return;\\n  return observer(data);\\n}\\nfunction observer(data) {\\n  if (Array.isArray(data)) {\\n    observeArray(data);\\n  } else {\\n    observeObject(data);\"},{\"url\":\"/basic/modulo.html\",\"relativePath\":\"/01.前端/03. 工作技巧/01.modulo.html\",\"frontmatter\":{\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"permalink\":\"/basic/modulo\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"capture\":\"&gt; 最近面试被问到一个倒计时相关问题，又一次用到了取余（Modulo）。说实话，刚入行那会儿，总觉得这玩意儿不就是小学数学里的`求余数`\\n&gt; 吗？除了面试题里用来判断奇偶数，平时好像也没啥大用。\\n&gt;\\n&gt; 但随着代码写得越来越多，逐渐发现 `%` 符号背后其实隐藏着一种处理数据的思维模型——它能把无限延伸的线性世界，折叠成有限可控的\\n周期世界。今天想和大家分享一下我对取余的重新思考，看看它是怎么帮我们优雅地解决那些头疼的边界问题。\\n 重新认识 `%`\\n取余的本质，是将任意数值强行`限定`在一个固定的循环范围内。无论数字跑多远，`% N` 都能让它回归到 `0` 至 `N-\"},{\"url\":\"/basic/issue.html\",\"relativePath\":\"/01.前端/03. 工作技巧/02.issue.html\",\"frontmatter\":{\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"permalink\":\"/basic/issue\",\"tags\":[\"基础\",\"工作\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"capture\":\"获取一个月有多少天\\n今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据\\n`new Date(year, month, date, hrs, min, sec)` ， `new Date` 可以接受这些参数创建一个时间对象\\n其中当我们把 `date` 设置为 `0` 的时候，可以直接通过 `getDate()` 获取到最后一天的日期然后得到我们要的最后一天\\n```js\\nnew Date(2019, 12, 0).getDate(); // 31\\nnew Date(2018, 2, 0).getDate(); // 28\\n// 根据这个我们可以得到一个方法\\nfunc\"},{\"url\":\"/basic/getport.html\",\"relativePath\":\"/01.前端/03. 工作技巧/getport.html\",\"frontmatter\":{\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"permalink\":\"/basic/getport\",\"tags\":[\"webpack\",\"node\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"capture\":\"一个问题\\n前段时间，公司项目改版登录，所有管理后台、大屏可视化或者说电脑 web 端的登录做成了一个模块统一授权登录，登录的域名是配置出来的，等他们联调完之后，我发现我本地项目跑起来后登录不了啦，找相关开发人员了解情况后才知道后端限制了 `localhost` 的访问(就离谱)\\n他们推荐前端开发人员本地安装 nginx，配置本机 hosts，用 nginx 做跳转，后端可访问域名白名单中添加有我们 hosts 中配置的域名\\n我是习惯了项目跑完后点击项目启动完成后的提示信息跳转页面进行开发(主要我不想本地配 nginx)，继续与他们交谈我了解到后端允许 127.0.0.1 进行接口访问，只需要在\"},{\"url\":\"/basic/mapbox.html\",\"relativePath\":\"/01.前端/03. 工作技巧/mapbox.html\",\"frontmatter\":{\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"permalink\":\"/basic/mapbox\",\"tags\":[\"可视化\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"capture\":\"底图渲染\\n- 初次渲染地图很简单，按照官网的配置\\n- 我们需要一个地图渲染容器，需要用到 mapbox-gl 库，有时候你可能需要准备一个开发者 token，那我们开始吧\\n- 首先我们实例化一个 Map 类，在 mapbox-gl 里面有个 Map 类，该类接受一个 options 配置对象作为初始化地图的条件\\n```js\\nimport mapboxgl from 'mapbox-gl';\\nconst options = {\\n  container: '底图容器',\\n  style: '您的底图json',\\n  // 经度越大越靠左，纬度越大越靠下\\n  center: [108.5, 38],\"},{\"url\":\"/basic/tree.html\",\"relativePath\":\"/01.前端/03. 工作技巧/tree.html\",\"frontmatter\":{\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"permalink\":\"/basic/tree\",\"tags\":[\"工作\",\"算法\"],\"categories\":[\"算法\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"capture\":\"前言\\n在工作中我们经常见到用树的场景，比如说写前端页面时，每个页面就有对应的 DOM 树、CSSOM 树、渲染树等，或者开发过程中的写的级联选择器、菜单树、权限树、人员树等\\n面试的时候会被问到算法相关的知识，而刷树相关的题，是特别培养算法思维的，回溯、动规、分治算法其实都是树的问题\\n本文将汇总一些工作中常用的一些树的操作以及面试可能会问到二叉树相关的问题\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/tree.svg\\\"/&gt;\\n&lt;/p&gt;\\n 树（工作）\\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个\"},{\"url\":\"/basic/vite-plugin-unique-page-chunks.html\",\"relativePath\":\"/01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.html\",\"frontmatter\":{\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"permalink\":\"/basic/vite-plugin-unique-page-chunks\",\"tags\":[\"插件\",\"Vite\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"capture\":\"问题背景\\n在某项目初上线优化代码的时候，打包后看到了类似的结果\\n```txt\\ndist/assets/index-CMe6Kk4E.js       0.63 kB │ gzip:   0.38 kB\\ndist/assets/index-DbyJIfZt.js     104.19 kB │ gzip:  40.96 kB\\ndist/assets/index-BN6vN86v.js     874.79 kB │ gzip: 282.58 kB\\ndist/assets/index-zD3tofSk.js   1,128.82 kB │ gzip: 375.52 kB\\n```\\n这些文件的名称几乎\"},{\"url\":\"/FE/ast.html\",\"relativePath\":\"/01.前端/04. 浏览器/AST.html\",\"frontmatter\":{\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/FE/ast\",\"tags\":[\"ast\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"capture\":\"&lt;!--  背景 --\\n 什么是 AST\\n抽象语法树（`Abstract Syntax Tree`）简称 `AST`，是源代码的抽象语法结构的树状表现形式。`webpack`、`eslint` 等很多工具库的核心都是通过抽象语法书这个概念来实现对代码的检查、分析等操作。今天我为大家分享一下 JavaScript 这类解释型语言的抽象语法树的概念\\n我们常用的浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作。所以将 js 转化为抽象语法树更利于程序的分析。\\n&lt;!-- ast --&gt;\\n&lt;p align=\\\"left\\\" class=\\\"p-images\\\"&g\"},{\"url\":\"/FE/cache.html\",\"relativePath\":\"/01.前端/04. 浏览器/cache.html\",\"frontmatter\":{\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"permalink\":\"/FE/cache\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"capture\":\"缓存会根据进来的请求保存输出内容的副本；当下一个请求来临的时候，如果是相同的 `URL`，缓存会根据缓存机制决定是直接使用副本响应请求还是向源服务器再次发送请求。比较常见的。\\n比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 `URL` 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。至于浏览器和网站服务器是如何标识网站页面是否更新的机制，将在后面介绍。\\n缓存可以减少网络带宽的消耗、减低服务器的压力、减少网络延迟，加快页面打开速度\\n这里主要记录浏览器缓存。\\n Memory Cache\\n`memory\"},{\"url\":\"/FE/jwt.html\",\"relativePath\":\"/01.前端/04. 浏览器/jwt.html\",\"frontmatter\":{\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"permalink\":\"/FE/jwt\",\"tags\":[\"http\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"capture\":\"还有几分钟就要跨年了，2019 即将结束，跨年夜独自一人闲来无趣，整理一下 `cookie、token` 和 `jwt` 的，记得在学校的时候我就很奇怪 `cookie` 是什么，当时老师只对我们说他就是用来存储数据的，只能存储 `4kb`，超过 `4kb` 之后就会开始删除之前的 `cookie` 值，不同浏览器删除的行为是不一样的。然后就没了。直到后来参加工作了，刚入公司没多久一次接触到了 `cookie` 让我一脸懵逼（当时带我的大佬有事回家了），项目出了 bug 因为 `cookie` 传递的不对，后台解析不了，然后我折腾了一晚上（回想当初小白的时候是真的有趣）。\\n今天来记录下工作这么\"},{\"url\":\"/FE/website-render.html\",\"relativePath\":\"/01.前端/04. 浏览器/website-render.html\",\"frontmatter\":{\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"permalink\":\"/FE/website-render\",\"tags\":[\"基础\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"capture\":\"简单流程\\n\\n URL\\n- URL（_Uniform Resource Locator_），统一资源定位符，用于定位互联网上资源，俗称网址\\n- 一个基本的URL由以下几部分组成\\n  1. 协议部分（_protocol_）：常见的协议有 _http、https、ftp、file_，其中最常见的类型是 _http_，而 _https_ 则是进行加密的网络传输\\n  2. 域名部分（_domain_）：该 URL 的域名部分为 _www.aspxfans.com_。一个 URL 中，也可以使用 IP 地址作为域名使用，_www_ 也是 _http_ 的默认主机（_host_）\\n  3. 端口部分（_po\"},{\"url\":\"/service/linux.html\",\"relativePath\":\"/02.服务端/01.linux.html\",\"frontmatter\":{\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"permalink\":\"/service/linux\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"capture\":\"这篇文章涵盖了Linux系统中常见目录、文件管理、搜索、压缩解压等内容。我对其进行了语言优化和排版调整，以提高可读性和流畅性。\\n 常见目录\\n在 `Linux` 中一切皆文件\\n| 目录      | 作用                                                                                 |\\n| --------- | ------------------------------------------------------------------------------------ |\\n| /         | 根\"},{\"url\":\"/service/mysql.html\",\"relativePath\":\"/02.服务端/02.mysql.html\",\"frontmatter\":{\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"permalink\":\"/service/mysql\",\"tags\":[\"MySQL\"],\"categories\":[\"MySQL\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"capture\":\"数据库操作\\n\\n 基本操作\\n```sql\\n  -- 创建数据库\\n  CREATE database_name;\\n  -- 查看数据库信息\\n  SHOW CREATE DATABASE database_name;\\n  -- 设置为 utf-8 格式的\\n  SET names utf8;\\n  -- 查看数据库\\n  SHOW DATABASES;\\n  -- 使用数据库，use 数据库名\\n  USE database_name;\\n  -- 创建表\\n  CREATE TABLE table_name (\\n    id    int(10),\\n    name  varchar(20),\\n    age \"},{\"url\":\"/service/proxy.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx-requisite.html\",\"frontmatter\":{\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"permalink\":\"/service/proxy\",\"tags\":[\"其他\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"capture\":\"反向代理与负载均衡\\n\\n&gt;\\n&gt; - 解决跨域\\n&gt; - 请求过滤\\n&gt; - 配置 gzip\\n&gt; - 负载均衡\\n&gt; - 静态资源服务器\\n 代理\\n&gt; &emsp;`代理` 是在服务器和客户端之间架设的一层服务器，代理将接受客户端的请求将它转发给服务器，然后将服务端的响应转发给客户端。不管正向代理还是反向代理，都是实现此功能。&lt;br/&gt; &gt; &emsp;说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。&lt;br/&gt; &gt; &emsp;举个例子：比如说生活中的专卖\"},{\"url\":\"/service/nginx.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx.html\",\"frontmatter\":{\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"permalink\":\"/service/nginx\",\"tags\":[\"Nginx\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"capture\":\"安装\\n- 安装就暂时略过了，记录一下配置\\n 常用命令\\n- 做了软链接或者配置了 nginx 的环境变量可以用以下语法，没有话就需要指定到 nginx 所在的目录\\n- nginx -s stop 停止 nginx\\n- nginx -s quit 退出 nginx\\n- nginx -s reload 重新加载配置（修改配置文件后）\\n- nginx -s reopen 重启 nginx\\n- nginx -v 查看版本\\n- nginx -t 查看配置文件目录，检测配置文件是否有语法错误，然后退出\\n nginx.conf 配置文件\\nNginx 配置文件主要分成四部分：main（全局设置）、server（\"},{\"url\":\"/service/http.html\",\"relativePath\":\"/02.服务端/http-undone.html\",\"frontmatter\":{\"title\":\"HTTP 笔记\",\"name\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"permalink\":\"/service/http\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"capture\":\"头部\\n 通用头\\n| 首部字段名        | 说明                       |\\n| ----------------- | -------------------------- |\\n| Cache-Control     | 控制缓存行为               |\\n| Connection        | 链接的管理                 |\\n| Date              | 报文日期                   |\\n| Pragma            | 报文指令                   |\\n| Trailer   \"},{\"url\":\"/service/https.html\",\"relativePath\":\"/02.服务端/https-undone.html\",\"frontmatter\":{\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"permalink\":\"/service/https\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"capture\":\"https\\n参照老左笔记进行实践\\n 准备东西\\n首先准备一台空的服务器\\n 安装的东西\\n- 安装 git、nginx\\n```sh\\nyum install git\\nyum install nginx\\n```\\n 快速获取 Let's Encrypt 免费 SSL 证书\\n执行以下脚本，域名换成自己的域名，邮箱换成自己的邮箱，然后一路同意\\n注意：执行脚本的时候一定要停掉 nginx，否则会出错\\n```sh\\ngit clone https://github.com/letsencrypt/letsencrypt\\ncd letsencrypt\\n./letsencrypt-auto certonly --sta\"},{\"url\":\"/service/crypto.html\",\"relativePath\":\"/02.服务端/node/crypto.html\",\"frontmatter\":{\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"permalink\":\"/service/crypto\",\"tags\":[\"其他\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"capture\":\"crypto\\ncrypto 是 node 中实现加密解密的模块，使用 OpenSSL 类库作为内部实现加密解密的手段\\n 散列(哈希)算法\\n散列算法也叫哈希算法，用来把任意长度的输入换成固定长度的输出，常见的有 md5、sha1、sha256 等\\n散列算法好很多中，在 node 中可以使用 `crypto.getHashes()` 获取到 node 所支持的所有 hash 类型\\n 特点\\n- 相同的输入会产生相同的输出\\n- 不同的输出会产生不同的输出\\n- 任意的输入长度输出长度都是相同的\\n- 不能从输出推算输出的值（不能反解）\\n 用途\\n- 用来校验要下载的文件是否被改的\\n- 用来对数据库中保存的密\"},{\"url\":\"/service/fs.html\",\"relativePath\":\"/02.服务端/node/fs.html\",\"frontmatter\":{\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/fs\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"文件操作\\n 读取文件\\n- fs 模块所有的都有同步和异步语法，异步语法直接写 api，同步写法就是 api 后紧跟 sync(同步)\\n- fs.readFile() 就是异步写法，那么同步写法就是 fs.readFilSync()\\n- 异步写法的返回值在回调函数中，同步写发直接就有返回值，这基本上也是 fs 所有模块的写法\\n```js\\nconst fs = require('fs');\\nconst path = require('path');\\nconst resolve = dir =&gt; path.join(__dirname, '..', dir);\\n// 异步写法\\nfs.readF\"},{\"url\":\"/service/process.html\",\"relativePath\":\"/02.服务端/node/process-undone.html\",\"frontmatter\":{\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/process\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"进程对象属性\\n| 属性       | 说明                                         |\\n|----------|--------------------------------------------|\\n| execPath | 可执行文件的绝对路径，如 `/usr/local/bin/node`         |\\n| version  | 版本号                                        |\\n| versions | 依赖库的版本号                                    |\\n| p\"},{\"url\":\"/service/redis.html\",\"relativePath\":\"/02.服务端/redis.html\",\"frontmatter\":{\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"permalink\":\"/service/redis\",\"tags\":[\"其他\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"capture\":\"安装\\n- 官网有 Linux 的详细教程，安装省略，记录一下基本配置以及基础用法\\n 简介\\n\\n- Redis 是 `ket-value` 数据库。效率快，但功能单一；\\n- 常用做集中式会话管理（部署了负载均衡的服务之后，可用作 redis 来存储 _session_，可保证 _session_ 不用换一个服务请求一次）\\n- 用作缓存服务器（Redis 读取特别快：SET 操作每秒钟 110000 次，GET 操作每秒钟 81000 次。）\\n 基本命令\\n```sh\\n   启动redis，window启动方式\\n  redis-server redis.window.conf\\n   Linux启动\\n \"},{\"url\":\"/service/conf.html\",\"relativePath\":\"/02.服务端/service-conf.html\",\"frontmatter\":{\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"permalink\":\"/service/conf\",\"tags\":[\"Linux\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"capture\":\"安装 nginx\\n&gt; 买了服务器，肯定先到控制台把服务器激活，然后重置登录密码，启动服务，然后怎么访问呢，那就先装个服务器呗，我选了 `nginx`，`nginx` 做内网转发还是挺不错的，现在也特别火，毕竟是轻量级的服务器。`nginx` 有什么好处我就不多说了，可以看看这篇文章讲解的很不错了\\n 安装前检查\\n- 安装 `nginx` 有两种方法，一种是源码包安装一种是 `yum` 安装，`yum` 安装可能不是最新版本的，这里我们选择了`源码包`安装\\n- 首先由于 `nginx` 的一些模块依赖一些 `lib` 库，所以在安装 `nginx` 之前，必须先安装这些 `lib` 库，这些\"},{\"url\":\"/service/vmware.html\",\"relativePath\":\"/02.服务端/vmware-undone.html\",\"frontmatter\":{\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"permalink\":\"/service/vmware\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"],\"private\":true,\"privateRealm\":\"common\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"capture\":\"&lt;!-- 虽然都 0202 年了，现在都不流行装系统了，但是作为一个开发，经常与电脑打交道还是需要会装系统的。曾几何时，我们用 xp 系统的时候安装 --\\n 系统启动\\n计算机通电后，第一件事情就是读取输入 ROM 芯片的开机程序，这个程序叫做基本输入输出系统 `BIOS`（Basic Input/Output System）\\n`BIOS` 程序首先检查计算机硬件是否满足运行的基本条件，这个叫做硬件自检（Power-On Self-Test）\\n如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止，如果没有问题，屏幕会显示出 CPU、内存、硬盘等信息\\n硬件自检完成后，BIOS 会把控制权交给\"},{\"url\":\"/git/git-1.html\",\"relativePath\":\"/03.工具/Git 相关/git-1.html\",\"frontmatter\":{\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"permalink\":\"/git/git-1\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"capture\":\"前言\\nGit 是目前广泛使用的分布式版本控制系统，在日常开发中经常会用到。\\n这篇文章记录了一些 Git 的基础知识和常用操作，希望能对大家有所帮助\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-1.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n Git 简介\\nGit 是一个 分布式版本控制系统，最初由 Linux 之父 Linus Torvalds 编写。它可以帮助我们跟踪代码的修改历史、多人协作开发，并在出问题时迅速回滚。\\n&gt; ✅ Git vs SVN：Git 是分布式的，每个开发者都有完整历史记录；\"},{\"url\":\"/git/git-2.html\",\"relativePath\":\"/03.工具/Git 相关/git-2.html\",\"frontmatter\":{\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"permalink\":\"/git/git-2\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"capture\":\"前言\\n在第一篇中，我们掌握了 Git 的基础操作和核心概念。现在让我们继续深入，探索 Git 的高级特性和实战技巧。\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-2.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n 源的管理\\n```shell\\n 查看源仓库信息\\ngit remote -v\\n 修改源仓库信息\\ngit remote set-url &lt;origin_name&gt; &lt;url&gt;\\n 添加源仓库\\ngit remote add &lt;origin_name&gt; &lt;url&gt;\\n 删除源\"},{\"url\":\"/git/git-submodules.html\",\"relativePath\":\"/03.工具/Git 相关/git-submodules.html\",\"frontmatter\":{\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"permalink\":\"/git/git-submodules\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"capture\":\"项目背景\\n因公司项目要拆成多个模块，部分模块给分公司的小伙伴开发权限一起开发，所以最终决定使用 git 子模块来拆分项目，今天来复盘下项目拆分中爬过的一些坑。有兴趣的同学可以参考源码一起阅读，附源码。\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git-submodules.svg\\\"/&gt;\\n&lt;/p&gt;\\n 子模块\\n首先来科普一下 git 子模块\\n子模块允许你将一个 git 仓库作为另一个 git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。\\n官方中举了一个例子：某个工作中的项目需要包含并使用另一个\"},{\"url\":\"/tools/command.html\",\"relativePath\":\"/03.工具/Npm 相关/command.html\",\"frontmatter\":{\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"permalink\":\"/tools/command\",\"tags\":[\"cli\",\"基础\",\"node\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"capture\":\"命令行\\n不管在 windows 还是 Mac、Linux 系统都会有很多命令来提供一些便捷的操作，比如在 window 中 打开 cmd 输入 `start snippingtool` 就可以打开绘图工具，cmd 里面执行的其实就是一个以 .bat 执行脚本，你也可以直接新建一个文件，然后在文件内部写入 `start snippingtool`，然后保存为 .bat 结尾的文件即可直接双击执行这个文件。在 Mac 和 Linux 中可以直接写内容，不需要后缀名，以 .sh 结尾也可以，但是 Mac 和 Linux 默认新建的脚本是没有执行权限的，需要 执行 `chmod +x 文件名` 给文件\"},{\"url\":\"/tools/npm-cli.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-cli.html\",\"frontmatter\":{\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"permalink\":\"/tools/npm-cli\",\"tags\":[\"cli\",\"node\",\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"capture\":\"思考\\n要开发一个脚手架需要捋清楚，脚手架是如何工作的？拿 `vue-cli` 来说，`vue-cli` 是将项目的模板放在 git 上面，执行 cli 命令的时候，再根据用户的交互选择不同的模板，然后经过模板引擎渲染出来生成项目。这样做将模板与脚手架分离，可以各自维护。\\n那我们先准备两套项目，一套作为自己的脚手架项目，一个作为模板\\n回想在使用 `vue-cli` 的时候，我们直接执行 `vue create projetcName` 然后进行一些交互便可以生成一个项目，生成的项目会拿到我们与用户交互的时候一些配置，会改变我们想要改变的一些文件。那我们就需要做完自己的脚手架后需要生成一个可以直接\"},{\"url\":\"/tools/npm-init.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-init.html\",\"frontmatter\":{\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"permalink\":\"/tools/npm-init\",\"tags\":[\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"capture\":\"npm init\\n初始化一个项目的时候，我们会在控制台输入 `npm init` 执行该命令后终端会依次询问 `name, version, description` 等字段，最后会为你生成一个 `package.json` 文件\\n如果想偷懒省去一路回车，可以在命令后面加 `--yes` 或者 `-y` 参数，这样会快速生成一个 `package.json` 文件\\n```sh\\n  npm init -y\\n```\\n这样生成出来的 `package.json` 是默认的配置，如果想要改变其默认配置怎么办？\\n 修改 npm 配置\\n初始化 `package.json` 时的字段默认值是可以自己配置的，\"},{\"url\":\"/tools/eslint.html\",\"relativePath\":\"/03.工具/Webpack 相关/lint.html\",\"frontmatter\":{\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/tools/eslint\",\"tags\":[\"eslint\",\"node\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"capture\":\"简介\\n本项目使用 express 脚手架初始化，并对其进行改造，从而实现一套完整的 eslint 工作流的 node 项目。本项目将全程使用 `pnpm` 作为包管理工具\\n本文将从以下几个方面过一遍 eslint 工作流\\n&lt;!--  --\\n&lt;p align=\\\"center\\\"&gt;\\n  &lt;img src=\\\"/imgs/eslint-process.svg\\\"/&gt;\\n&lt;/p&gt;\\n 初始化项目\\n```sh\\nnpx express-generator --view=pug express-template\\n```\\n也可以下全局下载 `express-generator`\"},{\"url\":\"/tools/vue.html\",\"relativePath\":\"/03.工具/Webpack 相关/vue.html\",\"frontmatter\":{\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"permalink\":\"/tools/vue\",\"tags\":[\"webpack\",\"vue\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"capture\":\"从 0 开始搭建 vue 项目\\n&lt;!-- 第一行的东西会被作为标题来展示 --\\n`webpack` 打包部署 js 项目从以下几个方面考虑：\\n- js 的处理：转换 ES6 代码，解决浏览器兼容问题\\n- css 的处理：编译 css，自动添加前缀，抽取 css 到独立文件\\n- html 的处理：复制并压缩 html 文件\\n- dist 的清理：打包前清理源目录文件\\n- assets 的处理：静态资源处理\\n- server 的启用：development 模式下启动服务器并实时刷新\\n 一、项目结构\\n我们按照 vue-cli 的目录结构来新建一些目录，然后 webpack 做相应的配置，打开\"},{\"url\":\"/tools/webpack-1.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-1.html\",\"frontmatter\":{\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"capture\":\"webpack 介绍\\nWebpack 可以直接执行 webpack 命令进行打包，也可以通过手动配置实现更复杂的打包需求。配置文件为 webpack.config.js，可以导出一个对象或函数，函数接受两个参数：env（环境对象）和 argv（描述传递给 webpack 选项的 map 对象）。\\n来看一下这两个参数：\\n```js\\n  // 在 webpack.config.js 中输入以下代码\\n  module.exports = function(env, argv) {\\n    console.log(env, argv)\\n  }\\n  // 在控制台执行\\n  webpack --env=c\"},{\"url\":\"/tools/webpack-2.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-2.html\",\"frontmatter\":{\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"tagsPage\":true,\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-2\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"capture\":\"安装\\n- 推荐本地安装，不推荐全局安装\\n- 安装本地 Webpack：npm i webpack webpack-cli -D\\n webpack 可以进行 0 配置\\n- 不需要配置任何东西，直接执行 webpack 就可以打包我们的代码\\n- 打包工具 -\\n- 打包（支持 js 模块化）\\n 手动配置 webpack\\n- 默认配置文件是 webpack.config.js\\n- 但是如果你不想使用这个文件也是可以的，可以使用 `--config webpack.other.js` 来让 webpack 使用其他的配置文件\\n 传参\\n- 如果需要在命令行后面传参，需要使用 `--`\\n```sh\\nnpm \"},{\"url\":\"/tools/webpack-3.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-3.html\",\"frontmatter\":{\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-3\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"capture\":\"介绍\\n接前两篇，这篇文章介绍一些使用 Webpack 的小技巧，以及在实际业务场景中如何自定义 Loader 和 Plugin。由于最近工作比较忙，这篇笔记写得断断续续，可能有些杂乱，后续会不断优化。\\n 小技巧：require.context\\n在开发项目时，如果需要引入很多文件，可以使用 require.context 函数创建一个文件引入的上下文。该函数接受三个参数：要搜索的目录、是否搜索子目录、匹配文件的正则表达式。\\n```js\\n// 语法如下\\nrequire.context(directory, (useSubdirectories = false), (regExp = /^\\\\.\\\\//\"},{\"url\":\"/scriptures/sutra.html\",\"relativePath\":\"/04.经典摘录/空性与妙用.html\",\"frontmatter\":{\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"permalink\":\"/scriptures/sutra\",\"tags\":[\"人生\"],\"categories\":[\"经典\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"capture\":\"金刚经的那句话\\n\\n&gt;\\n&gt; 虚妄不是说不存在，而是说太唯心。\\n---\\n&gt; 举个例子：  \\n&gt; 你面前有一个杯子——\\n&gt; - 你喝水，它就是 水杯；\\n&gt; - 你抽烟，它就是 烟灰缸；\\n&gt; - 你插花，它就是 花瓶；\\n&gt; - 你插笔，它就是 笔筒；\\n&gt; - 你愤怒时，它就是 一地的玻璃渣。\\n---\\n&gt; 杯子本身，其实它什么也不是，这叫 空性。\\n&gt;\\n&gt; 你用它来干什么，它就是什么，这叫 妙用。\\n&gt;\\n&gt; 你非要坚持，它一定就是杯子，这叫 住相。\\n&gt;\\n&gt; 为此，你不惜和别人争论抬杠，这叫 我执。\\n&gt;\\n&g\"},{\"url\":\"/archives.html\",\"relativePath\":\"/@pages/archivesPage.html\",\"frontmatter\":{\"title\":\"归档\",\"permalink\":\"/archives\",\"archivesPage\":true,\"layout\":\"page\",\"article\":false,\"sidebar\":false},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"归档\",\"date\":\"2025-10-20 01:48:42\",\"capture\":\"\"},{\"url\":\"/articleOverview.html\",\"relativePath\":\"/@pages/articleOverviewPage.html\",\"frontmatter\":{\"title\":\"文章清单\",\"permalink\":\"/articleOverview\",\"articleOverviewPage\":true,\"layout\":\"page\",\"article\":false,\"sidebar\":false},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"文章清单\",\"date\":\"2025-10-20 01:48:42\",\"capture\":\"\"},{\"url\":\"/categories.html\",\"relativePath\":\"/@pages/categoriesPage.html\",\"frontmatter\":{\"title\":\"分类\",\"categoriesPage\":true,\"permalink\":\"/categories\",\"article\":false,\"layout\":\"home\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"分类\",\"date\":\"2025-10-20 01:48:42\",\"capture\":\"\"},{\"url\":\"/login.html\",\"relativePath\":\"/@pages/loginPage.html\",\"frontmatter\":{\"permalink\":\"/login\",\"layout\":false,\"loginPage\":true,\"logo\":\"/logo.svg\",\"leftImg\":\"/login/bg-1.png\",\"article\":false},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"html\",\"date\":\"2025-10-20 01:48:42\",\"capture\":\"\"},{\"url\":\"/risk-link.html\",\"relativePath\":\"/@pages/riskLinkPage.html\",\"frontmatter\":{\"permalink\":\"/risk-link\",\"layout\":false,\"riskLinkPage\":true,\"logo\":\"/logo.svg\",\"article\":false},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"html\",\"date\":\"2025-10-20 01:48:42\",\"capture\":\"\"},{\"url\":\"/tags.html\",\"relativePath\":\"/@pages/tagsPage.html\",\"frontmatter\":{\"title\":\"标签\",\"permalink\":\"/tags\",\"tagsPage\":true,\"article\":false,\"layout\":\"home\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"标签\",\"date\":\"2025-10-20 01:48:42\",\"capture\":\"\"},{\"url\":\"/\",\"relativePath\":\"/\",\"frontmatter\":{\"layout\":\"home\",\"name\":\"风起代码间\",\"hero\":{\"name\":\"风起代码间\",\"text\":\"fecym 的博客\",\"tagline\":\"江湖有传言，任何可以使用 JavaScript 来编写的应用，最终会由 JavaScript 编写。\",\"actions\":[{\"theme\":\"brand\",\"text\":\"关于本站\",\"link\":\"/intro\"},{\"theme\":\"alt\",\"text\":\"所有文章\",\"link\":\"/@pages/articleOverviewPage\"},{\"theme\":\"alt\",\"text\":\"归档\",\"link\":\"/@pages/archivesPage\"}],\"image\":{\"src\":\"/logo.svg\",\"alt\":\"fecym blog\"}},\"features\":[{\"icon\":\"🧰\",\"title\":\"工程化与质量\",\"details\":\"Vite/Webpack 优化、ESLint 规范，提升可维护性与稳定性。\"},{\"icon\":\"🧩\",\"title\":\"Vue 生态与实践\",\"details\":\"组件设计、状态管理、性能优化与 ECharts 可视化落地。\"},{\"icon\":\"🚀\",\"title\":\"服务端与部署\",\"details\":\"Node.js、Nginx、MySQL、Linux、Docker 运维与上线流程经验。\"},{\"icon\":\"🤝\",\"title\":\"协作与效率\",\"details\":\"Git、npm、CI/CD、规范化工作流，提升协作与交付速度。\"}]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"\",\"date\":\"2025-10-20 01:48:42\",\"capture\":\"关于本站\\n这里是我的个人博客项目。我是前端开发工程师，长期专注 Vue 全家桶与前端工程化实践。博客主要记录我在编程、技术与工作中的思考与方法论，力求输出清晰、可复用的知识与经验。\\n目标是长期更新，持续积累与反思，并通过分类与标签构建结构化的知识图谱，提升检索与复盘效率。\\n 内容主题\\n- Vue 生态与工程化：Vue、组件设计、状态管理、性能优化、Vite、Webpack\\n- 前端基础：HTML、CSS、JavaScript（异步、模块化、编码规范、质量保障）\\n- 可视化实践：ECharts、图形渲染与地图\\n- 服务与部署：Node.js、Nginx、Docker、MySQL、（必要时 Red\"},{\"url\":\"/pages/87aa9d.html\",\"relativePath\":\"/intro.html\",\"frontmatter\":{\"date\":\"2024-08-03 07:59:26\",\"title\":\"关于博客\",\"sidebar\":false,\"article\":false,\"outline\":false,\"permalink\":\"/pages/87aa9d\",\"categories\":[null]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"关于博客\",\"date\":\"2024-08-03 07:59:26\",\"capture\":\"关于博客\\n- 本博客现已使用 VitePress 搭建，并基于 `vitepress-theme-teek` 主题扩展\\n- VitePress 是一个基于 Vite 的静态站点生成器，使用 Markdown 编写并享受更快的开发体验\\n- Teek 在默认主题基础上增强，提供文章概览、分类/标签、归档、永久链接、卡片布局等博客能力\\n- 每个页面预渲染静态 HTML，加载后作为 SPA 运行\\n- 参考：\\n  - VitePress 官方文档：https://vitepress.dev/\\n  - Teek 主题文档（配置参考）：https://vp.teek.top/\\n 快速上手\\n\\n 项目基本结构\\n\"},{\"url\":\"/pages/9492f1.html\",\"relativePath\":\"/views/plugins/chrome.html\",\"frontmatter\":{\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"tags\":[\"插件\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/9492f1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"\"},{\"url\":\"/pages/118849.html\",\"relativePath\":\"/views/plugins/vscode.html\",\"frontmatter\":{\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"插件\"],\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/118849\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"vscode 插件可以做什么\\nvscode 编辑器是可以高度自定义的，使用 vscode 插件几乎可以对 vscode 编辑器进行说有形式的自定义。\\nvscode 插件开发文档，中文文档\\nvscode 插件可以实现自定义指令、快捷键、自定义菜单项、自定义跳转、自动补全、悬浮提示、新增语言支持、语法检查、语法高亮、代码格式化等\\n 如何创建插件\\n我们使用官方来生成 vscode 插件模板项目\\n```sh\\n 安装 yo 和 generator-code\\nnpm install -g yo generator-code\\n 使用脚手架创建项目\\nyo code\\n```\\n yo 介绍\\nYeoman 是一个通\"}],\"originPosts\":[{\"url\":\"/basic/interview.html\",\"relativePath\":\"/01.前端/01. 基础/1. interview.html\",\"frontmatter\":{\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"permalink\":\"/basic/interview\",\"name\":\"面试题\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"capture\":\"1. 关于函数的 length 属性\\n360 面试过程遇到一个很有趣的问题，是关于函数的 length 属性的，题简写如下\\n```js\\n(() =\\n```\\n我所理解的拥有 `length` 的对象一般都是数组或者类数组对象，或者定义了 `length` 属性的对象，所以我回答说这个应该是 `false` 吧，后来面试告诉我函数是有 `length` 属性的，函数的 `length` 属性就是函数参数的个数，瞬间我恍然大悟，函数的参数就是 `arguments` ，而 `arguments` 也是一个类数组对象所以他是有 `length` 属性的\\n```js\\n// so\\n(() =&gt; 1)\"},{\"url\":\"/basic/css.html\",\"relativePath\":\"/01.前端/01. 基础/css.html\",\"frontmatter\":{\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"permalink\":\"/basic/css\",\"tags\":[\"css\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"capture\":\"css 加载会造成阻塞吗\\n\\n css 加载会造成 DOM 树的阻塞嘛？\\n- 首先，_css_ 加载会阻塞 _DOM_ 树渲染，但是 _css_ 并不会阻塞 _DOM_ 树的解析\\n- 也就是说，你可以在 _css_ 加载完之前可以在 _js_ 中获取到 _DOM_ 元素，但是 _DOM_ 却是没有渲染到页面上，需要等到 _css_ 加载完毕才渲染\\n- 为什么会这样？\\n  - 在你加载 _css_ 的时候，可能会修改 _DOM_ 节点的样式，如果 _css_ 加载不阻塞 _DOM_ 树渲染的话，那么当 _css_ 加载完之后， _DOM_ 树可有又得重绘或者回流了\\n  - 所以干脆先把 _DOM_\"},{\"url\":\"/basic/inherit.html\",\"relativePath\":\"/01.前端/01. 基础/inherit.html\",\"frontmatter\":{\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"permalink\":\"/basic/inherit\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"capture\":\"原型\\n 野史\\n&gt; 根据野史记载，Brendan Eich 用了一周的时间创造了今天的 JavaScript，当 Brendan Eich 在为 JavaScript 设计面向对象系统时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。而且 Brendan Eich 一开始就没有打算在 JavaScript 中加入类的概念，所以 JavaScript 是一门基于原型的语言。在原型编程的思想中，类并不是必须的，对象未必需要从类中创建而来，一个对象是通过另一个对象而得到的。\\n- 在曾探的《设计模式》中提到 JavaScript 中的原型继承会遵循以下这些原型编程的基本规则：\\n \"},{\"url\":\"/basic/js.html\",\"relativePath\":\"/01.前端/01. 基础/javascript.html\",\"frontmatter\":{\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"permalink\":\"/basic/js\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"capture\":\"类型转换\\n 一个有趣的问题\\n&lt;p align=\\\"center\\\" class=\\\"p-images\\\"\\n  &lt;img src=\\\"/imgs/basis-javascript-type-change.jpg\\\" height=\\\"260\\\" /&gt;\\n&lt;/p&gt;\\n&gt; 看到了这个我亲自尝试了下，结果发现自己对 js 基础越来越陌生了，现在好好复习下吧\\n```js\\n0 == '0'; // true\\n0 == []; // true\\n'0' == []; // false\\n```\\n 为什么？\\n&gt; 为什么 '0' == [] 是 false ？&lt;br&gt;\\n&gt; 为\"},{\"url\":\"/basic/api.html\",\"relativePath\":\"/01.前端/02. 代码实现/api.html\",\"frontmatter\":{\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"permalink\":\"/basic/api\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"capture\":\"实现一个 new 操作符\\n&gt; 函数执行前面加个 `new` 做了哪些事情，为啥就会构造一个对象出来\\n- 创建了一个新对象\\n- 链接到了原型\\n- 执行函数，绑定了 this 指向新创建的对象上\\n- 返回一个对象，如果函数中有`return`关键字，看 return 了什么出来，如果是一个对象，那么返回这个对象，如果不是则返回我们新建的这个对象\\n- 实现过程如下：\\n```js\\nfunction New() {\\n  // 创建了一个新对象\\n  const obj = {};\\n  // 取得构造函数\\n  const F = [].shift.call(arguments);\\n  // 链接到了原\"},{\"url\":\"/basic/array.html\",\"relativePath\":\"/01.前端/02. 代码实现/array.html\",\"frontmatter\":{\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"permalink\":\"/basic/array\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"capture\":\"在日常开发中，我们经常使用数组的 API。本文将详细介绍一些常用的数组操作方法，并提供其实现代码。\\n 任意位置插入单个成员\\n数组任意位置插入单个成员，这个 api 几乎可以作为数组插入的一个最基本的方法来处理，实现如下\\n按照数组 api 的规则，我们为数组增加了成员，那么要返回数组的长度\\n```js\\nfunction insert(arr, idx, item) {\\n  // 循环为什么要倒着写？看下面解释\\n  for (let i = arr.length - 1; i \\n    arr[i + 1] = arr[i];\\n  }\\n  arr[idx] = item;\\n  return arr\"},{\"url\":\"/basic/promise.html\",\"relativePath\":\"/01.前端/02. 代码实现/promise.html\",\"frontmatter\":{\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/promise\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"capture\":\"`promise` 的出现改变了以前 js 的回调风格。`promise` 核心是三种状态，`pending、resolve、reject`，状态一旦从 `pending` 变成其他状态则不可逆，其他用法细节将在实现 `promise` 的过程中一步步记录\\n 简单版 promise\\n- 首先我们实现函数异步函数执行的问题\\n```js\\n// 首先是三种状态\\nconst PENDING = 'pending';\\nconst RESOLVED = 'resolve';\\nconst REJECTED = 'reject';\\nfunction Promise(execute) {\\n  this.stat\"},{\"url\":\"/basic/vue.html\",\"relativePath\":\"/01.前端/02. 代码实现/vue-undone.html\",\"frontmatter\":{\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/vue\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"vue\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"capture\":\"数据劫持\\n 对象的劫持\\n2.x 版本的数据劫持是根据 Object.defineProperty 来实现的\\n```js\\nfunction observe(data) {\\n  // 不是对象直接返回\\n  if (!(typeof data === 'object' && data !== null)) return;\\n  return observer(data);\\n}\\nfunction observer(data) {\\n  if (Array.isArray(data)) {\\n    observeArray(data);\\n  } else {\\n    observeObject(data);\"},{\"url\":\"/basic/modulo.html\",\"relativePath\":\"/01.前端/03. 工作技巧/01.modulo.html\",\"frontmatter\":{\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"permalink\":\"/basic/modulo\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"capture\":\"&gt; 最近面试被问到一个倒计时相关问题，又一次用到了取余（Modulo）。说实话，刚入行那会儿，总觉得这玩意儿不就是小学数学里的`求余数`\\n&gt; 吗？除了面试题里用来判断奇偶数，平时好像也没啥大用。\\n&gt;\\n&gt; 但随着代码写得越来越多，逐渐发现 `%` 符号背后其实隐藏着一种处理数据的思维模型——它能把无限延伸的线性世界，折叠成有限可控的\\n周期世界。今天想和大家分享一下我对取余的重新思考，看看它是怎么帮我们优雅地解决那些头疼的边界问题。\\n 重新认识 `%`\\n取余的本质，是将任意数值强行`限定`在一个固定的循环范围内。无论数字跑多远，`% N` 都能让它回归到 `0` 至 `N-\"},{\"url\":\"/basic/issue.html\",\"relativePath\":\"/01.前端/03. 工作技巧/02.issue.html\",\"frontmatter\":{\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"permalink\":\"/basic/issue\",\"tags\":[\"基础\",\"工作\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"capture\":\"获取一个月有多少天\\n今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据\\n`new Date(year, month, date, hrs, min, sec)` ， `new Date` 可以接受这些参数创建一个时间对象\\n其中当我们把 `date` 设置为 `0` 的时候，可以直接通过 `getDate()` 获取到最后一天的日期然后得到我们要的最后一天\\n```js\\nnew Date(2019, 12, 0).getDate(); // 31\\nnew Date(2018, 2, 0).getDate(); // 28\\n// 根据这个我们可以得到一个方法\\nfunc\"},{\"url\":\"/basic/getport.html\",\"relativePath\":\"/01.前端/03. 工作技巧/getport.html\",\"frontmatter\":{\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"permalink\":\"/basic/getport\",\"tags\":[\"webpack\",\"node\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"capture\":\"一个问题\\n前段时间，公司项目改版登录，所有管理后台、大屏可视化或者说电脑 web 端的登录做成了一个模块统一授权登录，登录的域名是配置出来的，等他们联调完之后，我发现我本地项目跑起来后登录不了啦，找相关开发人员了解情况后才知道后端限制了 `localhost` 的访问(就离谱)\\n他们推荐前端开发人员本地安装 nginx，配置本机 hosts，用 nginx 做跳转，后端可访问域名白名单中添加有我们 hosts 中配置的域名\\n我是习惯了项目跑完后点击项目启动完成后的提示信息跳转页面进行开发(主要我不想本地配 nginx)，继续与他们交谈我了解到后端允许 127.0.0.1 进行接口访问，只需要在\"},{\"url\":\"/basic/mapbox.html\",\"relativePath\":\"/01.前端/03. 工作技巧/mapbox.html\",\"frontmatter\":{\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"permalink\":\"/basic/mapbox\",\"tags\":[\"可视化\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"capture\":\"底图渲染\\n- 初次渲染地图很简单，按照官网的配置\\n- 我们需要一个地图渲染容器，需要用到 mapbox-gl 库，有时候你可能需要准备一个开发者 token，那我们开始吧\\n- 首先我们实例化一个 Map 类，在 mapbox-gl 里面有个 Map 类，该类接受一个 options 配置对象作为初始化地图的条件\\n```js\\nimport mapboxgl from 'mapbox-gl';\\nconst options = {\\n  container: '底图容器',\\n  style: '您的底图json',\\n  // 经度越大越靠左，纬度越大越靠下\\n  center: [108.5, 38],\"},{\"url\":\"/basic/tree.html\",\"relativePath\":\"/01.前端/03. 工作技巧/tree.html\",\"frontmatter\":{\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"permalink\":\"/basic/tree\",\"tags\":[\"工作\",\"算法\"],\"categories\":[\"算法\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"capture\":\"前言\\n在工作中我们经常见到用树的场景，比如说写前端页面时，每个页面就有对应的 DOM 树、CSSOM 树、渲染树等，或者开发过程中的写的级联选择器、菜单树、权限树、人员树等\\n面试的时候会被问到算法相关的知识，而刷树相关的题，是特别培养算法思维的，回溯、动规、分治算法其实都是树的问题\\n本文将汇总一些工作中常用的一些树的操作以及面试可能会问到二叉树相关的问题\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/tree.svg\\\"/&gt;\\n&lt;/p&gt;\\n 树（工作）\\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个\"},{\"url\":\"/basic/vite-plugin-unique-page-chunks.html\",\"relativePath\":\"/01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.html\",\"frontmatter\":{\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"permalink\":\"/basic/vite-plugin-unique-page-chunks\",\"tags\":[\"插件\",\"Vite\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"capture\":\"问题背景\\n在某项目初上线优化代码的时候，打包后看到了类似的结果\\n```txt\\ndist/assets/index-CMe6Kk4E.js       0.63 kB │ gzip:   0.38 kB\\ndist/assets/index-DbyJIfZt.js     104.19 kB │ gzip:  40.96 kB\\ndist/assets/index-BN6vN86v.js     874.79 kB │ gzip: 282.58 kB\\ndist/assets/index-zD3tofSk.js   1,128.82 kB │ gzip: 375.52 kB\\n```\\n这些文件的名称几乎\"},{\"url\":\"/FE/ast.html\",\"relativePath\":\"/01.前端/04. 浏览器/AST.html\",\"frontmatter\":{\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/FE/ast\",\"tags\":[\"ast\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"capture\":\"&lt;!--  背景 --\\n 什么是 AST\\n抽象语法树（`Abstract Syntax Tree`）简称 `AST`，是源代码的抽象语法结构的树状表现形式。`webpack`、`eslint` 等很多工具库的核心都是通过抽象语法书这个概念来实现对代码的检查、分析等操作。今天我为大家分享一下 JavaScript 这类解释型语言的抽象语法树的概念\\n我们常用的浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作。所以将 js 转化为抽象语法树更利于程序的分析。\\n&lt;!-- ast --&gt;\\n&lt;p align=\\\"left\\\" class=\\\"p-images\\\"&g\"},{\"url\":\"/FE/cache.html\",\"relativePath\":\"/01.前端/04. 浏览器/cache.html\",\"frontmatter\":{\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"permalink\":\"/FE/cache\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"capture\":\"缓存会根据进来的请求保存输出内容的副本；当下一个请求来临的时候，如果是相同的 `URL`，缓存会根据缓存机制决定是直接使用副本响应请求还是向源服务器再次发送请求。比较常见的。\\n比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 `URL` 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。至于浏览器和网站服务器是如何标识网站页面是否更新的机制，将在后面介绍。\\n缓存可以减少网络带宽的消耗、减低服务器的压力、减少网络延迟，加快页面打开速度\\n这里主要记录浏览器缓存。\\n Memory Cache\\n`memory\"},{\"url\":\"/FE/jwt.html\",\"relativePath\":\"/01.前端/04. 浏览器/jwt.html\",\"frontmatter\":{\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"permalink\":\"/FE/jwt\",\"tags\":[\"http\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"capture\":\"还有几分钟就要跨年了，2019 即将结束，跨年夜独自一人闲来无趣，整理一下 `cookie、token` 和 `jwt` 的，记得在学校的时候我就很奇怪 `cookie` 是什么，当时老师只对我们说他就是用来存储数据的，只能存储 `4kb`，超过 `4kb` 之后就会开始删除之前的 `cookie` 值，不同浏览器删除的行为是不一样的。然后就没了。直到后来参加工作了，刚入公司没多久一次接触到了 `cookie` 让我一脸懵逼（当时带我的大佬有事回家了），项目出了 bug 因为 `cookie` 传递的不对，后台解析不了，然后我折腾了一晚上（回想当初小白的时候是真的有趣）。\\n今天来记录下工作这么\"},{\"url\":\"/FE/website-render.html\",\"relativePath\":\"/01.前端/04. 浏览器/website-render.html\",\"frontmatter\":{\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"permalink\":\"/FE/website-render\",\"tags\":[\"基础\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"capture\":\"简单流程\\n\\n URL\\n- URL（_Uniform Resource Locator_），统一资源定位符，用于定位互联网上资源，俗称网址\\n- 一个基本的URL由以下几部分组成\\n  1. 协议部分（_protocol_）：常见的协议有 _http、https、ftp、file_，其中最常见的类型是 _http_，而 _https_ 则是进行加密的网络传输\\n  2. 域名部分（_domain_）：该 URL 的域名部分为 _www.aspxfans.com_。一个 URL 中，也可以使用 IP 地址作为域名使用，_www_ 也是 _http_ 的默认主机（_host_）\\n  3. 端口部分（_po\"},{\"url\":\"/service/linux.html\",\"relativePath\":\"/02.服务端/01.linux.html\",\"frontmatter\":{\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"permalink\":\"/service/linux\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"capture\":\"这篇文章涵盖了Linux系统中常见目录、文件管理、搜索、压缩解压等内容。我对其进行了语言优化和排版调整，以提高可读性和流畅性。\\n 常见目录\\n在 `Linux` 中一切皆文件\\n| 目录      | 作用                                                                                 |\\n| --------- | ------------------------------------------------------------------------------------ |\\n| /         | 根\"},{\"url\":\"/service/mysql.html\",\"relativePath\":\"/02.服务端/02.mysql.html\",\"frontmatter\":{\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"permalink\":\"/service/mysql\",\"tags\":[\"MySQL\"],\"categories\":[\"MySQL\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"capture\":\"数据库操作\\n\\n 基本操作\\n```sql\\n  -- 创建数据库\\n  CREATE database_name;\\n  -- 查看数据库信息\\n  SHOW CREATE DATABASE database_name;\\n  -- 设置为 utf-8 格式的\\n  SET names utf8;\\n  -- 查看数据库\\n  SHOW DATABASES;\\n  -- 使用数据库，use 数据库名\\n  USE database_name;\\n  -- 创建表\\n  CREATE TABLE table_name (\\n    id    int(10),\\n    name  varchar(20),\\n    age \"},{\"url\":\"/service/proxy.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx-requisite.html\",\"frontmatter\":{\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"permalink\":\"/service/proxy\",\"tags\":[\"其他\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"capture\":\"反向代理与负载均衡\\n\\n&gt;\\n&gt; - 解决跨域\\n&gt; - 请求过滤\\n&gt; - 配置 gzip\\n&gt; - 负载均衡\\n&gt; - 静态资源服务器\\n 代理\\n&gt; &emsp;`代理` 是在服务器和客户端之间架设的一层服务器，代理将接受客户端的请求将它转发给服务器，然后将服务端的响应转发给客户端。不管正向代理还是反向代理，都是实现此功能。&lt;br/&gt; &gt; &emsp;说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。&lt;br/&gt; &gt; &emsp;举个例子：比如说生活中的专卖\"},{\"url\":\"/service/nginx.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx.html\",\"frontmatter\":{\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"permalink\":\"/service/nginx\",\"tags\":[\"Nginx\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"capture\":\"安装\\n- 安装就暂时略过了，记录一下配置\\n 常用命令\\n- 做了软链接或者配置了 nginx 的环境变量可以用以下语法，没有话就需要指定到 nginx 所在的目录\\n- nginx -s stop 停止 nginx\\n- nginx -s quit 退出 nginx\\n- nginx -s reload 重新加载配置（修改配置文件后）\\n- nginx -s reopen 重启 nginx\\n- nginx -v 查看版本\\n- nginx -t 查看配置文件目录，检测配置文件是否有语法错误，然后退出\\n nginx.conf 配置文件\\nNginx 配置文件主要分成四部分：main（全局设置）、server（\"},{\"url\":\"/service/http.html\",\"relativePath\":\"/02.服务端/http-undone.html\",\"frontmatter\":{\"title\":\"HTTP 笔记\",\"name\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"permalink\":\"/service/http\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"capture\":\"头部\\n 通用头\\n| 首部字段名        | 说明                       |\\n| ----------------- | -------------------------- |\\n| Cache-Control     | 控制缓存行为               |\\n| Connection        | 链接的管理                 |\\n| Date              | 报文日期                   |\\n| Pragma            | 报文指令                   |\\n| Trailer   \"},{\"url\":\"/service/https.html\",\"relativePath\":\"/02.服务端/https-undone.html\",\"frontmatter\":{\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"permalink\":\"/service/https\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"capture\":\"https\\n参照老左笔记进行实践\\n 准备东西\\n首先准备一台空的服务器\\n 安装的东西\\n- 安装 git、nginx\\n```sh\\nyum install git\\nyum install nginx\\n```\\n 快速获取 Let's Encrypt 免费 SSL 证书\\n执行以下脚本，域名换成自己的域名，邮箱换成自己的邮箱，然后一路同意\\n注意：执行脚本的时候一定要停掉 nginx，否则会出错\\n```sh\\ngit clone https://github.com/letsencrypt/letsencrypt\\ncd letsencrypt\\n./letsencrypt-auto certonly --sta\"},{\"url\":\"/service/crypto.html\",\"relativePath\":\"/02.服务端/node/crypto.html\",\"frontmatter\":{\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"permalink\":\"/service/crypto\",\"tags\":[\"其他\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"capture\":\"crypto\\ncrypto 是 node 中实现加密解密的模块，使用 OpenSSL 类库作为内部实现加密解密的手段\\n 散列(哈希)算法\\n散列算法也叫哈希算法，用来把任意长度的输入换成固定长度的输出，常见的有 md5、sha1、sha256 等\\n散列算法好很多中，在 node 中可以使用 `crypto.getHashes()` 获取到 node 所支持的所有 hash 类型\\n 特点\\n- 相同的输入会产生相同的输出\\n- 不同的输出会产生不同的输出\\n- 任意的输入长度输出长度都是相同的\\n- 不能从输出推算输出的值（不能反解）\\n 用途\\n- 用来校验要下载的文件是否被改的\\n- 用来对数据库中保存的密\"},{\"url\":\"/service/fs.html\",\"relativePath\":\"/02.服务端/node/fs.html\",\"frontmatter\":{\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/fs\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"文件操作\\n 读取文件\\n- fs 模块所有的都有同步和异步语法，异步语法直接写 api，同步写法就是 api 后紧跟 sync(同步)\\n- fs.readFile() 就是异步写法，那么同步写法就是 fs.readFilSync()\\n- 异步写法的返回值在回调函数中，同步写发直接就有返回值，这基本上也是 fs 所有模块的写法\\n```js\\nconst fs = require('fs');\\nconst path = require('path');\\nconst resolve = dir =&gt; path.join(__dirname, '..', dir);\\n// 异步写法\\nfs.readF\"},{\"url\":\"/service/process.html\",\"relativePath\":\"/02.服务端/node/process-undone.html\",\"frontmatter\":{\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/process\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"进程对象属性\\n| 属性       | 说明                                         |\\n|----------|--------------------------------------------|\\n| execPath | 可执行文件的绝对路径，如 `/usr/local/bin/node`         |\\n| version  | 版本号                                        |\\n| versions | 依赖库的版本号                                    |\\n| p\"},{\"url\":\"/service/redis.html\",\"relativePath\":\"/02.服务端/redis.html\",\"frontmatter\":{\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"permalink\":\"/service/redis\",\"tags\":[\"其他\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"capture\":\"安装\\n- 官网有 Linux 的详细教程，安装省略，记录一下基本配置以及基础用法\\n 简介\\n\\n- Redis 是 `ket-value` 数据库。效率快，但功能单一；\\n- 常用做集中式会话管理（部署了负载均衡的服务之后，可用作 redis 来存储 _session_，可保证 _session_ 不用换一个服务请求一次）\\n- 用作缓存服务器（Redis 读取特别快：SET 操作每秒钟 110000 次，GET 操作每秒钟 81000 次。）\\n 基本命令\\n```sh\\n   启动redis，window启动方式\\n  redis-server redis.window.conf\\n   Linux启动\\n \"},{\"url\":\"/service/conf.html\",\"relativePath\":\"/02.服务端/service-conf.html\",\"frontmatter\":{\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"permalink\":\"/service/conf\",\"tags\":[\"Linux\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"capture\":\"安装 nginx\\n&gt; 买了服务器，肯定先到控制台把服务器激活，然后重置登录密码，启动服务，然后怎么访问呢，那就先装个服务器呗，我选了 `nginx`，`nginx` 做内网转发还是挺不错的，现在也特别火，毕竟是轻量级的服务器。`nginx` 有什么好处我就不多说了，可以看看这篇文章讲解的很不错了\\n 安装前检查\\n- 安装 `nginx` 有两种方法，一种是源码包安装一种是 `yum` 安装，`yum` 安装可能不是最新版本的，这里我们选择了`源码包`安装\\n- 首先由于 `nginx` 的一些模块依赖一些 `lib` 库，所以在安装 `nginx` 之前，必须先安装这些 `lib` 库，这些\"},{\"url\":\"/service/vmware.html\",\"relativePath\":\"/02.服务端/vmware-undone.html\",\"frontmatter\":{\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"permalink\":\"/service/vmware\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"],\"private\":true,\"privateRealm\":\"common\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"capture\":\"&lt;!-- 虽然都 0202 年了，现在都不流行装系统了，但是作为一个开发，经常与电脑打交道还是需要会装系统的。曾几何时，我们用 xp 系统的时候安装 --\\n 系统启动\\n计算机通电后，第一件事情就是读取输入 ROM 芯片的开机程序，这个程序叫做基本输入输出系统 `BIOS`（Basic Input/Output System）\\n`BIOS` 程序首先检查计算机硬件是否满足运行的基本条件，这个叫做硬件自检（Power-On Self-Test）\\n如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止，如果没有问题，屏幕会显示出 CPU、内存、硬盘等信息\\n硬件自检完成后，BIOS 会把控制权交给\"},{\"url\":\"/git/git-1.html\",\"relativePath\":\"/03.工具/Git 相关/git-1.html\",\"frontmatter\":{\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"permalink\":\"/git/git-1\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"capture\":\"前言\\nGit 是目前广泛使用的分布式版本控制系统，在日常开发中经常会用到。\\n这篇文章记录了一些 Git 的基础知识和常用操作，希望能对大家有所帮助\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-1.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n Git 简介\\nGit 是一个 分布式版本控制系统，最初由 Linux 之父 Linus Torvalds 编写。它可以帮助我们跟踪代码的修改历史、多人协作开发，并在出问题时迅速回滚。\\n&gt; ✅ Git vs SVN：Git 是分布式的，每个开发者都有完整历史记录；\"},{\"url\":\"/git/git-2.html\",\"relativePath\":\"/03.工具/Git 相关/git-2.html\",\"frontmatter\":{\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"permalink\":\"/git/git-2\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"capture\":\"前言\\n在第一篇中，我们掌握了 Git 的基础操作和核心概念。现在让我们继续深入，探索 Git 的高级特性和实战技巧。\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-2.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n 源的管理\\n```shell\\n 查看源仓库信息\\ngit remote -v\\n 修改源仓库信息\\ngit remote set-url &lt;origin_name&gt; &lt;url&gt;\\n 添加源仓库\\ngit remote add &lt;origin_name&gt; &lt;url&gt;\\n 删除源\"},{\"url\":\"/git/git-submodules.html\",\"relativePath\":\"/03.工具/Git 相关/git-submodules.html\",\"frontmatter\":{\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"permalink\":\"/git/git-submodules\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"capture\":\"项目背景\\n因公司项目要拆成多个模块，部分模块给分公司的小伙伴开发权限一起开发，所以最终决定使用 git 子模块来拆分项目，今天来复盘下项目拆分中爬过的一些坑。有兴趣的同学可以参考源码一起阅读，附源码。\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git-submodules.svg\\\"/&gt;\\n&lt;/p&gt;\\n 子模块\\n首先来科普一下 git 子模块\\n子模块允许你将一个 git 仓库作为另一个 git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。\\n官方中举了一个例子：某个工作中的项目需要包含并使用另一个\"},{\"url\":\"/tools/command.html\",\"relativePath\":\"/03.工具/Npm 相关/command.html\",\"frontmatter\":{\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"permalink\":\"/tools/command\",\"tags\":[\"cli\",\"基础\",\"node\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"capture\":\"命令行\\n不管在 windows 还是 Mac、Linux 系统都会有很多命令来提供一些便捷的操作，比如在 window 中 打开 cmd 输入 `start snippingtool` 就可以打开绘图工具，cmd 里面执行的其实就是一个以 .bat 执行脚本，你也可以直接新建一个文件，然后在文件内部写入 `start snippingtool`，然后保存为 .bat 结尾的文件即可直接双击执行这个文件。在 Mac 和 Linux 中可以直接写内容，不需要后缀名，以 .sh 结尾也可以，但是 Mac 和 Linux 默认新建的脚本是没有执行权限的，需要 执行 `chmod +x 文件名` 给文件\"},{\"url\":\"/tools/npm-cli.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-cli.html\",\"frontmatter\":{\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"permalink\":\"/tools/npm-cli\",\"tags\":[\"cli\",\"node\",\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"capture\":\"思考\\n要开发一个脚手架需要捋清楚，脚手架是如何工作的？拿 `vue-cli` 来说，`vue-cli` 是将项目的模板放在 git 上面，执行 cli 命令的时候，再根据用户的交互选择不同的模板，然后经过模板引擎渲染出来生成项目。这样做将模板与脚手架分离，可以各自维护。\\n那我们先准备两套项目，一套作为自己的脚手架项目，一个作为模板\\n回想在使用 `vue-cli` 的时候，我们直接执行 `vue create projetcName` 然后进行一些交互便可以生成一个项目，生成的项目会拿到我们与用户交互的时候一些配置，会改变我们想要改变的一些文件。那我们就需要做完自己的脚手架后需要生成一个可以直接\"},{\"url\":\"/tools/npm-init.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-init.html\",\"frontmatter\":{\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"permalink\":\"/tools/npm-init\",\"tags\":[\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"capture\":\"npm init\\n初始化一个项目的时候，我们会在控制台输入 `npm init` 执行该命令后终端会依次询问 `name, version, description` 等字段，最后会为你生成一个 `package.json` 文件\\n如果想偷懒省去一路回车，可以在命令后面加 `--yes` 或者 `-y` 参数，这样会快速生成一个 `package.json` 文件\\n```sh\\n  npm init -y\\n```\\n这样生成出来的 `package.json` 是默认的配置，如果想要改变其默认配置怎么办？\\n 修改 npm 配置\\n初始化 `package.json` 时的字段默认值是可以自己配置的，\"},{\"url\":\"/tools/eslint.html\",\"relativePath\":\"/03.工具/Webpack 相关/lint.html\",\"frontmatter\":{\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/tools/eslint\",\"tags\":[\"eslint\",\"node\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"capture\":\"简介\\n本项目使用 express 脚手架初始化，并对其进行改造，从而实现一套完整的 eslint 工作流的 node 项目。本项目将全程使用 `pnpm` 作为包管理工具\\n本文将从以下几个方面过一遍 eslint 工作流\\n&lt;!--  --\\n&lt;p align=\\\"center\\\"&gt;\\n  &lt;img src=\\\"/imgs/eslint-process.svg\\\"/&gt;\\n&lt;/p&gt;\\n 初始化项目\\n```sh\\nnpx express-generator --view=pug express-template\\n```\\n也可以下全局下载 `express-generator`\"},{\"url\":\"/tools/vue.html\",\"relativePath\":\"/03.工具/Webpack 相关/vue.html\",\"frontmatter\":{\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"permalink\":\"/tools/vue\",\"tags\":[\"webpack\",\"vue\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"capture\":\"从 0 开始搭建 vue 项目\\n&lt;!-- 第一行的东西会被作为标题来展示 --\\n`webpack` 打包部署 js 项目从以下几个方面考虑：\\n- js 的处理：转换 ES6 代码，解决浏览器兼容问题\\n- css 的处理：编译 css，自动添加前缀，抽取 css 到独立文件\\n- html 的处理：复制并压缩 html 文件\\n- dist 的清理：打包前清理源目录文件\\n- assets 的处理：静态资源处理\\n- server 的启用：development 模式下启动服务器并实时刷新\\n 一、项目结构\\n我们按照 vue-cli 的目录结构来新建一些目录，然后 webpack 做相应的配置，打开\"},{\"url\":\"/tools/webpack-1.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-1.html\",\"frontmatter\":{\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"capture\":\"webpack 介绍\\nWebpack 可以直接执行 webpack 命令进行打包，也可以通过手动配置实现更复杂的打包需求。配置文件为 webpack.config.js，可以导出一个对象或函数，函数接受两个参数：env（环境对象）和 argv（描述传递给 webpack 选项的 map 对象）。\\n来看一下这两个参数：\\n```js\\n  // 在 webpack.config.js 中输入以下代码\\n  module.exports = function(env, argv) {\\n    console.log(env, argv)\\n  }\\n  // 在控制台执行\\n  webpack --env=c\"},{\"url\":\"/tools/webpack-2.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-2.html\",\"frontmatter\":{\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"tagsPage\":true,\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-2\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"capture\":\"安装\\n- 推荐本地安装，不推荐全局安装\\n- 安装本地 Webpack：npm i webpack webpack-cli -D\\n webpack 可以进行 0 配置\\n- 不需要配置任何东西，直接执行 webpack 就可以打包我们的代码\\n- 打包工具 -\\n- 打包（支持 js 模块化）\\n 手动配置 webpack\\n- 默认配置文件是 webpack.config.js\\n- 但是如果你不想使用这个文件也是可以的，可以使用 `--config webpack.other.js` 来让 webpack 使用其他的配置文件\\n 传参\\n- 如果需要在命令行后面传参，需要使用 `--`\\n```sh\\nnpm \"},{\"url\":\"/tools/webpack-3.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-3.html\",\"frontmatter\":{\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-3\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"capture\":\"介绍\\n接前两篇，这篇文章介绍一些使用 Webpack 的小技巧，以及在实际业务场景中如何自定义 Loader 和 Plugin。由于最近工作比较忙，这篇笔记写得断断续续，可能有些杂乱，后续会不断优化。\\n 小技巧：require.context\\n在开发项目时，如果需要引入很多文件，可以使用 require.context 函数创建一个文件引入的上下文。该函数接受三个参数：要搜索的目录、是否搜索子目录、匹配文件的正则表达式。\\n```js\\n// 语法如下\\nrequire.context(directory, (useSubdirectories = false), (regExp = /^\\\\.\\\\//\"},{\"url\":\"/scriptures/sutra.html\",\"relativePath\":\"/04.经典摘录/空性与妙用.html\",\"frontmatter\":{\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"permalink\":\"/scriptures/sutra\",\"tags\":[\"人生\"],\"categories\":[\"经典\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"capture\":\"金刚经的那句话\\n\\n&gt;\\n&gt; 虚妄不是说不存在，而是说太唯心。\\n---\\n&gt; 举个例子：  \\n&gt; 你面前有一个杯子——\\n&gt; - 你喝水，它就是 水杯；\\n&gt; - 你抽烟，它就是 烟灰缸；\\n&gt; - 你插花，它就是 花瓶；\\n&gt; - 你插笔，它就是 笔筒；\\n&gt; - 你愤怒时，它就是 一地的玻璃渣。\\n---\\n&gt; 杯子本身，其实它什么也不是，这叫 空性。\\n&gt;\\n&gt; 你用它来干什么，它就是什么，这叫 妙用。\\n&gt;\\n&gt; 你非要坚持，它一定就是杯子，这叫 住相。\\n&gt;\\n&gt; 为此，你不惜和别人争论抬杠，这叫 我执。\\n&gt;\\n&g\"},{\"url\":\"/pages/9492f1.html\",\"relativePath\":\"/views/plugins/chrome.html\",\"frontmatter\":{\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"tags\":[\"插件\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/9492f1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"\"},{\"url\":\"/pages/118849.html\",\"relativePath\":\"/views/plugins/vscode.html\",\"frontmatter\":{\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"插件\"],\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/118849\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"vscode 插件可以做什么\\nvscode 编辑器是可以高度自定义的，使用 vscode 插件几乎可以对 vscode 编辑器进行说有形式的自定义。\\nvscode 插件开发文档，中文文档\\nvscode 插件可以实现自定义指令、快捷键、自定义菜单项、自定义跳转、自动补全、悬浮提示、新增语言支持、语法检查、语法高亮、代码格式化等\\n 如何创建插件\\n我们使用官方来生成 vscode 插件模板项目\\n```sh\\n 安装 yo 和 generator-code\\nnpm install -g yo generator-code\\n 使用脚手架创建项目\\nyo code\\n```\\n yo 介绍\\nYeoman 是一个通\"}],\"sortPostsByDateAndSticky\":[{\"url\":\"/basic/modulo.html\",\"relativePath\":\"/01.前端/03. 工作技巧/01.modulo.html\",\"frontmatter\":{\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"permalink\":\"/basic/modulo\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"capture\":\"&gt; 最近面试被问到一个倒计时相关问题，又一次用到了取余（Modulo）。说实话，刚入行那会儿，总觉得这玩意儿不就是小学数学里的`求余数`\\n&gt; 吗？除了面试题里用来判断奇偶数，平时好像也没啥大用。\\n&gt;\\n&gt; 但随着代码写得越来越多，逐渐发现 `%` 符号背后其实隐藏着一种处理数据的思维模型——它能把无限延伸的线性世界，折叠成有限可控的\\n周期世界。今天想和大家分享一下我对取余的重新思考，看看它是怎么帮我们优雅地解决那些头疼的边界问题。\\n 重新认识 `%`\\n取余的本质，是将任意数值强行`限定`在一个固定的循环范围内。无论数字跑多远，`% N` 都能让它回归到 `0` 至 `N-\"},{\"url\":\"/scriptures/sutra.html\",\"relativePath\":\"/04.经典摘录/空性与妙用.html\",\"frontmatter\":{\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"permalink\":\"/scriptures/sutra\",\"tags\":[\"人生\"],\"categories\":[\"经典\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"capture\":\"金刚经的那句话\\n\\n&gt;\\n&gt; 虚妄不是说不存在，而是说太唯心。\\n---\\n&gt; 举个例子：  \\n&gt; 你面前有一个杯子——\\n&gt; - 你喝水，它就是 水杯；\\n&gt; - 你抽烟，它就是 烟灰缸；\\n&gt; - 你插花，它就是 花瓶；\\n&gt; - 你插笔，它就是 笔筒；\\n&gt; - 你愤怒时，它就是 一地的玻璃渣。\\n---\\n&gt; 杯子本身，其实它什么也不是，这叫 空性。\\n&gt;\\n&gt; 你用它来干什么，它就是什么，这叫 妙用。\\n&gt;\\n&gt; 你非要坚持，它一定就是杯子，这叫 住相。\\n&gt;\\n&gt; 为此，你不惜和别人争论抬杠，这叫 我执。\\n&gt;\\n&g\"},{\"url\":\"/basic/vite-plugin-unique-page-chunks.html\",\"relativePath\":\"/01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.html\",\"frontmatter\":{\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"permalink\":\"/basic/vite-plugin-unique-page-chunks\",\"tags\":[\"插件\",\"Vite\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"capture\":\"问题背景\\n在某项目初上线优化代码的时候，打包后看到了类似的结果\\n```txt\\ndist/assets/index-CMe6Kk4E.js       0.63 kB │ gzip:   0.38 kB\\ndist/assets/index-DbyJIfZt.js     104.19 kB │ gzip:  40.96 kB\\ndist/assets/index-BN6vN86v.js     874.79 kB │ gzip: 282.58 kB\\ndist/assets/index-zD3tofSk.js   1,128.82 kB │ gzip: 375.52 kB\\n```\\n这些文件的名称几乎\"},{\"url\":\"/git/git-2.html\",\"relativePath\":\"/03.工具/Git 相关/git-2.html\",\"frontmatter\":{\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"permalink\":\"/git/git-2\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"capture\":\"前言\\n在第一篇中，我们掌握了 Git 的基础操作和核心概念。现在让我们继续深入，探索 Git 的高级特性和实战技巧。\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-2.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n 源的管理\\n```shell\\n 查看源仓库信息\\ngit remote -v\\n 修改源仓库信息\\ngit remote set-url &lt;origin_name&gt; &lt;url&gt;\\n 添加源仓库\\ngit remote add &lt;origin_name&gt; &lt;url&gt;\\n 删除源\"},{\"url\":\"/git/git-1.html\",\"relativePath\":\"/03.工具/Git 相关/git-1.html\",\"frontmatter\":{\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"permalink\":\"/git/git-1\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"capture\":\"前言\\nGit 是目前广泛使用的分布式版本控制系统，在日常开发中经常会用到。\\n这篇文章记录了一些 Git 的基础知识和常用操作，希望能对大家有所帮助\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-1.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n Git 简介\\nGit 是一个 分布式版本控制系统，最初由 Linux 之父 Linus Torvalds 编写。它可以帮助我们跟踪代码的修改历史、多人协作开发，并在出问题时迅速回滚。\\n&gt; ✅ Git vs SVN：Git 是分布式的，每个开发者都有完整历史记录；\"},{\"url\":\"/tools/eslint.html\",\"relativePath\":\"/03.工具/Webpack 相关/lint.html\",\"frontmatter\":{\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/tools/eslint\",\"tags\":[\"eslint\",\"node\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"capture\":\"简介\\n本项目使用 express 脚手架初始化，并对其进行改造，从而实现一套完整的 eslint 工作流的 node 项目。本项目将全程使用 `pnpm` 作为包管理工具\\n本文将从以下几个方面过一遍 eslint 工作流\\n&lt;!--  --\\n&lt;p align=\\\"center\\\"&gt;\\n  &lt;img src=\\\"/imgs/eslint-process.svg\\\"/&gt;\\n&lt;/p&gt;\\n 初始化项目\\n```sh\\nnpx express-generator --view=pug express-template\\n```\\n也可以下全局下载 `express-generator`\"},{\"url\":\"/git/git-submodules.html\",\"relativePath\":\"/03.工具/Git 相关/git-submodules.html\",\"frontmatter\":{\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"permalink\":\"/git/git-submodules\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"capture\":\"项目背景\\n因公司项目要拆成多个模块，部分模块给分公司的小伙伴开发权限一起开发，所以最终决定使用 git 子模块来拆分项目，今天来复盘下项目拆分中爬过的一些坑。有兴趣的同学可以参考源码一起阅读，附源码。\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git-submodules.svg\\\"/&gt;\\n&lt;/p&gt;\\n 子模块\\n首先来科普一下 git 子模块\\n子模块允许你将一个 git 仓库作为另一个 git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。\\n官方中举了一个例子：某个工作中的项目需要包含并使用另一个\"},{\"url\":\"/basic/getport.html\",\"relativePath\":\"/01.前端/03. 工作技巧/getport.html\",\"frontmatter\":{\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"permalink\":\"/basic/getport\",\"tags\":[\"webpack\",\"node\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"capture\":\"一个问题\\n前段时间，公司项目改版登录，所有管理后台、大屏可视化或者说电脑 web 端的登录做成了一个模块统一授权登录，登录的域名是配置出来的，等他们联调完之后，我发现我本地项目跑起来后登录不了啦，找相关开发人员了解情况后才知道后端限制了 `localhost` 的访问(就离谱)\\n他们推荐前端开发人员本地安装 nginx，配置本机 hosts，用 nginx 做跳转，后端可访问域名白名单中添加有我们 hosts 中配置的域名\\n我是习惯了项目跑完后点击项目启动完成后的提示信息跳转页面进行开发(主要我不想本地配 nginx)，继续与他们交谈我了解到后端允许 127.0.0.1 进行接口访问，只需要在\"},{\"url\":\"/basic/tree.html\",\"relativePath\":\"/01.前端/03. 工作技巧/tree.html\",\"frontmatter\":{\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"permalink\":\"/basic/tree\",\"tags\":[\"工作\",\"算法\"],\"categories\":[\"算法\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"capture\":\"前言\\n在工作中我们经常见到用树的场景，比如说写前端页面时，每个页面就有对应的 DOM 树、CSSOM 树、渲染树等，或者开发过程中的写的级联选择器、菜单树、权限树、人员树等\\n面试的时候会被问到算法相关的知识，而刷树相关的题，是特别培养算法思维的，回溯、动规、分治算法其实都是树的问题\\n本文将汇总一些工作中常用的一些树的操作以及面试可能会问到二叉树相关的问题\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/tree.svg\\\"/&gt;\\n&lt;/p&gt;\\n 树（工作）\\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个\"},{\"url\":\"/basic/interview.html\",\"relativePath\":\"/01.前端/01. 基础/1. interview.html\",\"frontmatter\":{\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"permalink\":\"/basic/interview\",\"name\":\"面试题\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"capture\":\"1. 关于函数的 length 属性\\n360 面试过程遇到一个很有趣的问题，是关于函数的 length 属性的，题简写如下\\n```js\\n(() =\\n```\\n我所理解的拥有 `length` 的对象一般都是数组或者类数组对象，或者定义了 `length` 属性的对象，所以我回答说这个应该是 `false` 吧，后来面试告诉我函数是有 `length` 属性的，函数的 `length` 属性就是函数参数的个数，瞬间我恍然大悟，函数的参数就是 `arguments` ，而 `arguments` 也是一个类数组对象所以他是有 `length` 属性的\\n```js\\n// so\\n(() =&gt; 1)\"},{\"url\":\"/basic/array.html\",\"relativePath\":\"/01.前端/02. 代码实现/array.html\",\"frontmatter\":{\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"permalink\":\"/basic/array\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"capture\":\"在日常开发中，我们经常使用数组的 API。本文将详细介绍一些常用的数组操作方法，并提供其实现代码。\\n 任意位置插入单个成员\\n数组任意位置插入单个成员，这个 api 几乎可以作为数组插入的一个最基本的方法来处理，实现如下\\n按照数组 api 的规则，我们为数组增加了成员，那么要返回数组的长度\\n```js\\nfunction insert(arr, idx, item) {\\n  // 循环为什么要倒着写？看下面解释\\n  for (let i = arr.length - 1; i \\n    arr[i + 1] = arr[i];\\n  }\\n  arr[idx] = item;\\n  return arr\"},{\"url\":\"/pages/9492f1.html\",\"relativePath\":\"/views/plugins/chrome.html\",\"frontmatter\":{\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"tags\":[\"插件\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/9492f1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"\"},{\"url\":\"/pages/118849.html\",\"relativePath\":\"/views/plugins/vscode.html\",\"frontmatter\":{\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"插件\"],\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/118849\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"vscode 插件可以做什么\\nvscode 编辑器是可以高度自定义的，使用 vscode 插件几乎可以对 vscode 编辑器进行说有形式的自定义。\\nvscode 插件开发文档，中文文档\\nvscode 插件可以实现自定义指令、快捷键、自定义菜单项、自定义跳转、自动补全、悬浮提示、新增语言支持、语法检查、语法高亮、代码格式化等\\n 如何创建插件\\n我们使用官方来生成 vscode 插件模板项目\\n```sh\\n 安装 yo 和 generator-code\\nnpm install -g yo generator-code\\n 使用脚手架创建项目\\nyo code\\n```\\n yo 介绍\\nYeoman 是一个通\"},{\"url\":\"/tools/webpack-3.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-3.html\",\"frontmatter\":{\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-3\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"capture\":\"介绍\\n接前两篇，这篇文章介绍一些使用 Webpack 的小技巧，以及在实际业务场景中如何自定义 Loader 和 Plugin。由于最近工作比较忙，这篇笔记写得断断续续，可能有些杂乱，后续会不断优化。\\n 小技巧：require.context\\n在开发项目时，如果需要引入很多文件，可以使用 require.context 函数创建一个文件引入的上下文。该函数接受三个参数：要搜索的目录、是否搜索子目录、匹配文件的正则表达式。\\n```js\\n// 语法如下\\nrequire.context(directory, (useSubdirectories = false), (regExp = /^\\\\.\\\\//\"},{\"url\":\"/basic/vue.html\",\"relativePath\":\"/01.前端/02. 代码实现/vue-undone.html\",\"frontmatter\":{\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/vue\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"vue\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"capture\":\"数据劫持\\n 对象的劫持\\n2.x 版本的数据劫持是根据 Object.defineProperty 来实现的\\n```js\\nfunction observe(data) {\\n  // 不是对象直接返回\\n  if (!(typeof data === 'object' && data !== null)) return;\\n  return observer(data);\\n}\\nfunction observer(data) {\\n  if (Array.isArray(data)) {\\n    observeArray(data);\\n  } else {\\n    observeObject(data);\"},{\"url\":\"/FE/ast.html\",\"relativePath\":\"/01.前端/04. 浏览器/AST.html\",\"frontmatter\":{\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/FE/ast\",\"tags\":[\"ast\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"capture\":\"&lt;!--  背景 --\\n 什么是 AST\\n抽象语法树（`Abstract Syntax Tree`）简称 `AST`，是源代码的抽象语法结构的树状表现形式。`webpack`、`eslint` 等很多工具库的核心都是通过抽象语法书这个概念来实现对代码的检查、分析等操作。今天我为大家分享一下 JavaScript 这类解释型语言的抽象语法树的概念\\n我们常用的浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作。所以将 js 转化为抽象语法树更利于程序的分析。\\n&lt;!-- ast --&gt;\\n&lt;p align=\\\"left\\\" class=\\\"p-images\\\"&g\"},{\"url\":\"/basic/promise.html\",\"relativePath\":\"/01.前端/02. 代码实现/promise.html\",\"frontmatter\":{\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/promise\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"capture\":\"`promise` 的出现改变了以前 js 的回调风格。`promise` 核心是三种状态，`pending、resolve、reject`，状态一旦从 `pending` 变成其他状态则不可逆，其他用法细节将在实现 `promise` 的过程中一步步记录\\n 简单版 promise\\n- 首先我们实现函数异步函数执行的问题\\n```js\\n// 首先是三种状态\\nconst PENDING = 'pending';\\nconst RESOLVED = 'resolve';\\nconst REJECTED = 'reject';\\nfunction Promise(execute) {\\n  this.stat\"},{\"url\":\"/tools/webpack-2.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-2.html\",\"frontmatter\":{\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"tagsPage\":true,\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-2\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"capture\":\"安装\\n- 推荐本地安装，不推荐全局安装\\n- 安装本地 Webpack：npm i webpack webpack-cli -D\\n webpack 可以进行 0 配置\\n- 不需要配置任何东西，直接执行 webpack 就可以打包我们的代码\\n- 打包工具 -\\n- 打包（支持 js 模块化）\\n 手动配置 webpack\\n- 默认配置文件是 webpack.config.js\\n- 但是如果你不想使用这个文件也是可以的，可以使用 `--config webpack.other.js` 来让 webpack 使用其他的配置文件\\n 传参\\n- 如果需要在命令行后面传参，需要使用 `--`\\n```sh\\nnpm \"},{\"url\":\"/tools/command.html\",\"relativePath\":\"/03.工具/Npm 相关/command.html\",\"frontmatter\":{\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"permalink\":\"/tools/command\",\"tags\":[\"cli\",\"基础\",\"node\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"capture\":\"命令行\\n不管在 windows 还是 Mac、Linux 系统都会有很多命令来提供一些便捷的操作，比如在 window 中 打开 cmd 输入 `start snippingtool` 就可以打开绘图工具，cmd 里面执行的其实就是一个以 .bat 执行脚本，你也可以直接新建一个文件，然后在文件内部写入 `start snippingtool`，然后保存为 .bat 结尾的文件即可直接双击执行这个文件。在 Mac 和 Linux 中可以直接写内容，不需要后缀名，以 .sh 结尾也可以，但是 Mac 和 Linux 默认新建的脚本是没有执行权限的，需要 执行 `chmod +x 文件名` 给文件\"},{\"url\":\"/service/https.html\",\"relativePath\":\"/02.服务端/https-undone.html\",\"frontmatter\":{\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"permalink\":\"/service/https\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"capture\":\"https\\n参照老左笔记进行实践\\n 准备东西\\n首先准备一台空的服务器\\n 安装的东西\\n- 安装 git、nginx\\n```sh\\nyum install git\\nyum install nginx\\n```\\n 快速获取 Let's Encrypt 免费 SSL 证书\\n执行以下脚本，域名换成自己的域名，邮箱换成自己的邮箱，然后一路同意\\n注意：执行脚本的时候一定要停掉 nginx，否则会出错\\n```sh\\ngit clone https://github.com/letsencrypt/letsencrypt\\ncd letsencrypt\\n./letsencrypt-auto certonly --sta\"},{\"url\":\"/service/crypto.html\",\"relativePath\":\"/02.服务端/node/crypto.html\",\"frontmatter\":{\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"permalink\":\"/service/crypto\",\"tags\":[\"其他\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"capture\":\"crypto\\ncrypto 是 node 中实现加密解密的模块，使用 OpenSSL 类库作为内部实现加密解密的手段\\n 散列(哈希)算法\\n散列算法也叫哈希算法，用来把任意长度的输入换成固定长度的输出，常见的有 md5、sha1、sha256 等\\n散列算法好很多中，在 node 中可以使用 `crypto.getHashes()` 获取到 node 所支持的所有 hash 类型\\n 特点\\n- 相同的输入会产生相同的输出\\n- 不同的输出会产生不同的输出\\n- 任意的输入长度输出长度都是相同的\\n- 不能从输出推算输出的值（不能反解）\\n 用途\\n- 用来校验要下载的文件是否被改的\\n- 用来对数据库中保存的密\"},{\"url\":\"/service/http.html\",\"relativePath\":\"/02.服务端/http-undone.html\",\"frontmatter\":{\"title\":\"HTTP 笔记\",\"name\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"permalink\":\"/service/http\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"capture\":\"头部\\n 通用头\\n| 首部字段名        | 说明                       |\\n| ----------------- | -------------------------- |\\n| Cache-Control     | 控制缓存行为               |\\n| Connection        | 链接的管理                 |\\n| Date              | 报文日期                   |\\n| Pragma            | 报文指令                   |\\n| Trailer   \"},{\"url\":\"/service/linux.html\",\"relativePath\":\"/02.服务端/01.linux.html\",\"frontmatter\":{\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"permalink\":\"/service/linux\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"capture\":\"这篇文章涵盖了Linux系统中常见目录、文件管理、搜索、压缩解压等内容。我对其进行了语言优化和排版调整，以提高可读性和流畅性。\\n 常见目录\\n在 `Linux` 中一切皆文件\\n| 目录      | 作用                                                                                 |\\n| --------- | ------------------------------------------------------------------------------------ |\\n| /         | 根\"},{\"url\":\"/service/vmware.html\",\"relativePath\":\"/02.服务端/vmware-undone.html\",\"frontmatter\":{\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"permalink\":\"/service/vmware\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"],\"private\":true,\"privateRealm\":\"common\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"capture\":\"&lt;!-- 虽然都 0202 年了，现在都不流行装系统了，但是作为一个开发，经常与电脑打交道还是需要会装系统的。曾几何时，我们用 xp 系统的时候安装 --\\n 系统启动\\n计算机通电后，第一件事情就是读取输入 ROM 芯片的开机程序，这个程序叫做基本输入输出系统 `BIOS`（Basic Input/Output System）\\n`BIOS` 程序首先检查计算机硬件是否满足运行的基本条件，这个叫做硬件自检（Power-On Self-Test）\\n如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止，如果没有问题，屏幕会显示出 CPU、内存、硬盘等信息\\n硬件自检完成后，BIOS 会把控制权交给\"},{\"url\":\"/FE/jwt.html\",\"relativePath\":\"/01.前端/04. 浏览器/jwt.html\",\"frontmatter\":{\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"permalink\":\"/FE/jwt\",\"tags\":[\"http\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"capture\":\"还有几分钟就要跨年了，2019 即将结束，跨年夜独自一人闲来无趣，整理一下 `cookie、token` 和 `jwt` 的，记得在学校的时候我就很奇怪 `cookie` 是什么，当时老师只对我们说他就是用来存储数据的，只能存储 `4kb`，超过 `4kb` 之后就会开始删除之前的 `cookie` 值，不同浏览器删除的行为是不一样的。然后就没了。直到后来参加工作了，刚入公司没多久一次接触到了 `cookie` 让我一脸懵逼（当时带我的大佬有事回家了），项目出了 bug 因为 `cookie` 传递的不对，后台解析不了，然后我折腾了一晚上（回想当初小白的时候是真的有趣）。\\n今天来记录下工作这么\"},{\"url\":\"/FE/cache.html\",\"relativePath\":\"/01.前端/04. 浏览器/cache.html\",\"frontmatter\":{\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"permalink\":\"/FE/cache\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"capture\":\"缓存会根据进来的请求保存输出内容的副本；当下一个请求来临的时候，如果是相同的 `URL`，缓存会根据缓存机制决定是直接使用副本响应请求还是向源服务器再次发送请求。比较常见的。\\n比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 `URL` 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。至于浏览器和网站服务器是如何标识网站页面是否更新的机制，将在后面介绍。\\n缓存可以减少网络带宽的消耗、减低服务器的压力、减少网络延迟，加快页面打开速度\\n这里主要记录浏览器缓存。\\n Memory Cache\\n`memory\"},{\"url\":\"/basic/issue.html\",\"relativePath\":\"/01.前端/03. 工作技巧/02.issue.html\",\"frontmatter\":{\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"permalink\":\"/basic/issue\",\"tags\":[\"基础\",\"工作\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"capture\":\"获取一个月有多少天\\n今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据\\n`new Date(year, month, date, hrs, min, sec)` ， `new Date` 可以接受这些参数创建一个时间对象\\n其中当我们把 `date` 设置为 `0` 的时候，可以直接通过 `getDate()` 获取到最后一天的日期然后得到我们要的最后一天\\n```js\\nnew Date(2019, 12, 0).getDate(); // 31\\nnew Date(2018, 2, 0).getDate(); // 28\\n// 根据这个我们可以得到一个方法\\nfunc\"},{\"url\":\"/tools/npm-cli.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-cli.html\",\"frontmatter\":{\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"permalink\":\"/tools/npm-cli\",\"tags\":[\"cli\",\"node\",\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"capture\":\"思考\\n要开发一个脚手架需要捋清楚，脚手架是如何工作的？拿 `vue-cli` 来说，`vue-cli` 是将项目的模板放在 git 上面，执行 cli 命令的时候，再根据用户的交互选择不同的模板，然后经过模板引擎渲染出来生成项目。这样做将模板与脚手架分离，可以各自维护。\\n那我们先准备两套项目，一套作为自己的脚手架项目，一个作为模板\\n回想在使用 `vue-cli` 的时候，我们直接执行 `vue create projetcName` 然后进行一些交互便可以生成一个项目，生成的项目会拿到我们与用户交互的时候一些配置，会改变我们想要改变的一些文件。那我们就需要做完自己的脚手架后需要生成一个可以直接\"},{\"url\":\"/tools/npm-init.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-init.html\",\"frontmatter\":{\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"permalink\":\"/tools/npm-init\",\"tags\":[\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"capture\":\"npm init\\n初始化一个项目的时候，我们会在控制台输入 `npm init` 执行该命令后终端会依次询问 `name, version, description` 等字段，最后会为你生成一个 `package.json` 文件\\n如果想偷懒省去一路回车，可以在命令后面加 `--yes` 或者 `-y` 参数，这样会快速生成一个 `package.json` 文件\\n```sh\\n  npm init -y\\n```\\n这样生成出来的 `package.json` 是默认的配置，如果想要改变其默认配置怎么办？\\n 修改 npm 配置\\n初始化 `package.json` 时的字段默认值是可以自己配置的，\"},{\"url\":\"/service/conf.html\",\"relativePath\":\"/02.服务端/service-conf.html\",\"frontmatter\":{\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"permalink\":\"/service/conf\",\"tags\":[\"Linux\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"capture\":\"安装 nginx\\n&gt; 买了服务器，肯定先到控制台把服务器激活，然后重置登录密码，启动服务，然后怎么访问呢，那就先装个服务器呗，我选了 `nginx`，`nginx` 做内网转发还是挺不错的，现在也特别火，毕竟是轻量级的服务器。`nginx` 有什么好处我就不多说了，可以看看这篇文章讲解的很不错了\\n 安装前检查\\n- 安装 `nginx` 有两种方法，一种是源码包安装一种是 `yum` 安装，`yum` 安装可能不是最新版本的，这里我们选择了`源码包`安装\\n- 首先由于 `nginx` 的一些模块依赖一些 `lib` 库，所以在安装 `nginx` 之前，必须先安装这些 `lib` 库，这些\"},{\"url\":\"/basic/api.html\",\"relativePath\":\"/01.前端/02. 代码实现/api.html\",\"frontmatter\":{\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"permalink\":\"/basic/api\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"capture\":\"实现一个 new 操作符\\n&gt; 函数执行前面加个 `new` 做了哪些事情，为啥就会构造一个对象出来\\n- 创建了一个新对象\\n- 链接到了原型\\n- 执行函数，绑定了 this 指向新创建的对象上\\n- 返回一个对象，如果函数中有`return`关键字，看 return 了什么出来，如果是一个对象，那么返回这个对象，如果不是则返回我们新建的这个对象\\n- 实现过程如下：\\n```js\\nfunction New() {\\n  // 创建了一个新对象\\n  const obj = {};\\n  // 取得构造函数\\n  const F = [].shift.call(arguments);\\n  // 链接到了原\"},{\"url\":\"/basic/inherit.html\",\"relativePath\":\"/01.前端/01. 基础/inherit.html\",\"frontmatter\":{\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"permalink\":\"/basic/inherit\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"capture\":\"原型\\n 野史\\n&gt; 根据野史记载，Brendan Eich 用了一周的时间创造了今天的 JavaScript，当 Brendan Eich 在为 JavaScript 设计面向对象系统时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。而且 Brendan Eich 一开始就没有打算在 JavaScript 中加入类的概念，所以 JavaScript 是一门基于原型的语言。在原型编程的思想中，类并不是必须的，对象未必需要从类中创建而来，一个对象是通过另一个对象而得到的。\\n- 在曾探的《设计模式》中提到 JavaScript 中的原型继承会遵循以下这些原型编程的基本规则：\\n \"},{\"url\":\"/service/redis.html\",\"relativePath\":\"/02.服务端/redis.html\",\"frontmatter\":{\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"permalink\":\"/service/redis\",\"tags\":[\"其他\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"capture\":\"安装\\n- 官网有 Linux 的详细教程，安装省略，记录一下基本配置以及基础用法\\n 简介\\n\\n- Redis 是 `ket-value` 数据库。效率快，但功能单一；\\n- 常用做集中式会话管理（部署了负载均衡的服务之后，可用作 redis 来存储 _session_，可保证 _session_ 不用换一个服务请求一次）\\n- 用作缓存服务器（Redis 读取特别快：SET 操作每秒钟 110000 次，GET 操作每秒钟 81000 次。）\\n 基本命令\\n```sh\\n   启动redis，window启动方式\\n  redis-server redis.window.conf\\n   Linux启动\\n \"},{\"url\":\"/basic/mapbox.html\",\"relativePath\":\"/01.前端/03. 工作技巧/mapbox.html\",\"frontmatter\":{\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"permalink\":\"/basic/mapbox\",\"tags\":[\"可视化\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"capture\":\"底图渲染\\n- 初次渲染地图很简单，按照官网的配置\\n- 我们需要一个地图渲染容器，需要用到 mapbox-gl 库，有时候你可能需要准备一个开发者 token，那我们开始吧\\n- 首先我们实例化一个 Map 类，在 mapbox-gl 里面有个 Map 类，该类接受一个 options 配置对象作为初始化地图的条件\\n```js\\nimport mapboxgl from 'mapbox-gl';\\nconst options = {\\n  container: '底图容器',\\n  style: '您的底图json',\\n  // 经度越大越靠左，纬度越大越靠下\\n  center: [108.5, 38],\"},{\"url\":\"/service/proxy.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx-requisite.html\",\"frontmatter\":{\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"permalink\":\"/service/proxy\",\"tags\":[\"其他\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"capture\":\"反向代理与负载均衡\\n\\n&gt;\\n&gt; - 解决跨域\\n&gt; - 请求过滤\\n&gt; - 配置 gzip\\n&gt; - 负载均衡\\n&gt; - 静态资源服务器\\n 代理\\n&gt; &emsp;`代理` 是在服务器和客户端之间架设的一层服务器，代理将接受客户端的请求将它转发给服务器，然后将服务端的响应转发给客户端。不管正向代理还是反向代理，都是实现此功能。&lt;br/&gt; &gt; &emsp;说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。&lt;br/&gt; &gt; &emsp;举个例子：比如说生活中的专卖\"},{\"url\":\"/FE/website-render.html\",\"relativePath\":\"/01.前端/04. 浏览器/website-render.html\",\"frontmatter\":{\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"permalink\":\"/FE/website-render\",\"tags\":[\"基础\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"capture\":\"简单流程\\n\\n URL\\n- URL（_Uniform Resource Locator_），统一资源定位符，用于定位互联网上资源，俗称网址\\n- 一个基本的URL由以下几部分组成\\n  1. 协议部分（_protocol_）：常见的协议有 _http、https、ftp、file_，其中最常见的类型是 _http_，而 _https_ 则是进行加密的网络传输\\n  2. 域名部分（_domain_）：该 URL 的域名部分为 _www.aspxfans.com_。一个 URL 中，也可以使用 IP 地址作为域名使用，_www_ 也是 _http_ 的默认主机（_host_）\\n  3. 端口部分（_po\"},{\"url\":\"/service/mysql.html\",\"relativePath\":\"/02.服务端/02.mysql.html\",\"frontmatter\":{\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"permalink\":\"/service/mysql\",\"tags\":[\"MySQL\"],\"categories\":[\"MySQL\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"capture\":\"数据库操作\\n\\n 基本操作\\n```sql\\n  -- 创建数据库\\n  CREATE database_name;\\n  -- 查看数据库信息\\n  SHOW CREATE DATABASE database_name;\\n  -- 设置为 utf-8 格式的\\n  SET names utf8;\\n  -- 查看数据库\\n  SHOW DATABASES;\\n  -- 使用数据库，use 数据库名\\n  USE database_name;\\n  -- 创建表\\n  CREATE TABLE table_name (\\n    id    int(10),\\n    name  varchar(20),\\n    age \"},{\"url\":\"/service/nginx.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx.html\",\"frontmatter\":{\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"permalink\":\"/service/nginx\",\"tags\":[\"Nginx\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"capture\":\"安装\\n- 安装就暂时略过了，记录一下配置\\n 常用命令\\n- 做了软链接或者配置了 nginx 的环境变量可以用以下语法，没有话就需要指定到 nginx 所在的目录\\n- nginx -s stop 停止 nginx\\n- nginx -s quit 退出 nginx\\n- nginx -s reload 重新加载配置（修改配置文件后）\\n- nginx -s reopen 重启 nginx\\n- nginx -v 查看版本\\n- nginx -t 查看配置文件目录，检测配置文件是否有语法错误，然后退出\\n nginx.conf 配置文件\\nNginx 配置文件主要分成四部分：main（全局设置）、server（\"},{\"url\":\"/service/fs.html\",\"relativePath\":\"/02.服务端/node/fs.html\",\"frontmatter\":{\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/fs\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"文件操作\\n 读取文件\\n- fs 模块所有的都有同步和异步语法，异步语法直接写 api，同步写法就是 api 后紧跟 sync(同步)\\n- fs.readFile() 就是异步写法，那么同步写法就是 fs.readFilSync()\\n- 异步写法的返回值在回调函数中，同步写发直接就有返回值，这基本上也是 fs 所有模块的写法\\n```js\\nconst fs = require('fs');\\nconst path = require('path');\\nconst resolve = dir =&gt; path.join(__dirname, '..', dir);\\n// 异步写法\\nfs.readF\"},{\"url\":\"/service/process.html\",\"relativePath\":\"/02.服务端/node/process-undone.html\",\"frontmatter\":{\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/process\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"进程对象属性\\n| 属性       | 说明                                         |\\n|----------|--------------------------------------------|\\n| execPath | 可执行文件的绝对路径，如 `/usr/local/bin/node`         |\\n| version  | 版本号                                        |\\n| versions | 依赖库的版本号                                    |\\n| p\"},{\"url\":\"/tools/vue.html\",\"relativePath\":\"/03.工具/Webpack 相关/vue.html\",\"frontmatter\":{\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"permalink\":\"/tools/vue\",\"tags\":[\"webpack\",\"vue\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"capture\":\"从 0 开始搭建 vue 项目\\n&lt;!-- 第一行的东西会被作为标题来展示 --\\n`webpack` 打包部署 js 项目从以下几个方面考虑：\\n- js 的处理：转换 ES6 代码，解决浏览器兼容问题\\n- css 的处理：编译 css，自动添加前缀，抽取 css 到独立文件\\n- html 的处理：复制并压缩 html 文件\\n- dist 的清理：打包前清理源目录文件\\n- assets 的处理：静态资源处理\\n- server 的启用：development 模式下启动服务器并实时刷新\\n 一、项目结构\\n我们按照 vue-cli 的目录结构来新建一些目录，然后 webpack 做相应的配置，打开\"},{\"url\":\"/tools/webpack-1.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-1.html\",\"frontmatter\":{\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"capture\":\"webpack 介绍\\nWebpack 可以直接执行 webpack 命令进行打包，也可以通过手动配置实现更复杂的打包需求。配置文件为 webpack.config.js，可以导出一个对象或函数，函数接受两个参数：env（环境对象）和 argv（描述传递给 webpack 选项的 map 对象）。\\n来看一下这两个参数：\\n```js\\n  // 在 webpack.config.js 中输入以下代码\\n  module.exports = function(env, argv) {\\n    console.log(env, argv)\\n  }\\n  // 在控制台执行\\n  webpack --env=c\"},{\"url\":\"/basic/js.html\",\"relativePath\":\"/01.前端/01. 基础/javascript.html\",\"frontmatter\":{\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"permalink\":\"/basic/js\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"capture\":\"类型转换\\n 一个有趣的问题\\n&lt;p align=\\\"center\\\" class=\\\"p-images\\\"\\n  &lt;img src=\\\"/imgs/basis-javascript-type-change.jpg\\\" height=\\\"260\\\" /&gt;\\n&lt;/p&gt;\\n&gt; 看到了这个我亲自尝试了下，结果发现自己对 js 基础越来越陌生了，现在好好复习下吧\\n```js\\n0 == '0'; // true\\n0 == []; // true\\n'0' == []; // false\\n```\\n 为什么？\\n&gt; 为什么 '0' == [] 是 false ？&lt;br&gt;\\n&gt; 为\"},{\"url\":\"/basic/css.html\",\"relativePath\":\"/01.前端/01. 基础/css.html\",\"frontmatter\":{\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"permalink\":\"/basic/css\",\"tags\":[\"css\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"capture\":\"css 加载会造成阻塞吗\\n\\n css 加载会造成 DOM 树的阻塞嘛？\\n- 首先，_css_ 加载会阻塞 _DOM_ 树渲染，但是 _css_ 并不会阻塞 _DOM_ 树的解析\\n- 也就是说，你可以在 _css_ 加载完之前可以在 _js_ 中获取到 _DOM_ 元素，但是 _DOM_ 却是没有渲染到页面上，需要等到 _css_ 加载完毕才渲染\\n- 为什么会这样？\\n  - 在你加载 _css_ 的时候，可能会修改 _DOM_ 节点的样式，如果 _css_ 加载不阻塞 _DOM_ 树渲染的话，那么当 _css_ 加载完之后， _DOM_ 树可有又得重绘或者回流了\\n  - 所以干脆先把 _DOM_\"}],\"sortPostsByDate\":[{\"url\":\"/basic/modulo.html\",\"relativePath\":\"/01.前端/03. 工作技巧/01.modulo.html\",\"frontmatter\":{\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"permalink\":\"/basic/modulo\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"capture\":\"&gt; 最近面试被问到一个倒计时相关问题，又一次用到了取余（Modulo）。说实话，刚入行那会儿，总觉得这玩意儿不就是小学数学里的`求余数`\\n&gt; 吗？除了面试题里用来判断奇偶数，平时好像也没啥大用。\\n&gt;\\n&gt; 但随着代码写得越来越多，逐渐发现 `%` 符号背后其实隐藏着一种处理数据的思维模型——它能把无限延伸的线性世界，折叠成有限可控的\\n周期世界。今天想和大家分享一下我对取余的重新思考，看看它是怎么帮我们优雅地解决那些头疼的边界问题。\\n 重新认识 `%`\\n取余的本质，是将任意数值强行`限定`在一个固定的循环范围内。无论数字跑多远，`% N` 都能让它回归到 `0` 至 `N-\"},{\"url\":\"/scriptures/sutra.html\",\"relativePath\":\"/04.经典摘录/空性与妙用.html\",\"frontmatter\":{\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"permalink\":\"/scriptures/sutra\",\"tags\":[\"人生\"],\"categories\":[\"经典\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"capture\":\"金刚经的那句话\\n\\n&gt;\\n&gt; 虚妄不是说不存在，而是说太唯心。\\n---\\n&gt; 举个例子：  \\n&gt; 你面前有一个杯子——\\n&gt; - 你喝水，它就是 水杯；\\n&gt; - 你抽烟，它就是 烟灰缸；\\n&gt; - 你插花，它就是 花瓶；\\n&gt; - 你插笔，它就是 笔筒；\\n&gt; - 你愤怒时，它就是 一地的玻璃渣。\\n---\\n&gt; 杯子本身，其实它什么也不是，这叫 空性。\\n&gt;\\n&gt; 你用它来干什么，它就是什么，这叫 妙用。\\n&gt;\\n&gt; 你非要坚持，它一定就是杯子，这叫 住相。\\n&gt;\\n&gt; 为此，你不惜和别人争论抬杠，这叫 我执。\\n&gt;\\n&g\"},{\"url\":\"/basic/vite-plugin-unique-page-chunks.html\",\"relativePath\":\"/01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.html\",\"frontmatter\":{\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"permalink\":\"/basic/vite-plugin-unique-page-chunks\",\"tags\":[\"插件\",\"Vite\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"capture\":\"问题背景\\n在某项目初上线优化代码的时候，打包后看到了类似的结果\\n```txt\\ndist/assets/index-CMe6Kk4E.js       0.63 kB │ gzip:   0.38 kB\\ndist/assets/index-DbyJIfZt.js     104.19 kB │ gzip:  40.96 kB\\ndist/assets/index-BN6vN86v.js     874.79 kB │ gzip: 282.58 kB\\ndist/assets/index-zD3tofSk.js   1,128.82 kB │ gzip: 375.52 kB\\n```\\n这些文件的名称几乎\"},{\"url\":\"/git/git-2.html\",\"relativePath\":\"/03.工具/Git 相关/git-2.html\",\"frontmatter\":{\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"permalink\":\"/git/git-2\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"capture\":\"前言\\n在第一篇中，我们掌握了 Git 的基础操作和核心概念。现在让我们继续深入，探索 Git 的高级特性和实战技巧。\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-2.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n 源的管理\\n```shell\\n 查看源仓库信息\\ngit remote -v\\n 修改源仓库信息\\ngit remote set-url &lt;origin_name&gt; &lt;url&gt;\\n 添加源仓库\\ngit remote add &lt;origin_name&gt; &lt;url&gt;\\n 删除源\"},{\"url\":\"/git/git-1.html\",\"relativePath\":\"/03.工具/Git 相关/git-1.html\",\"frontmatter\":{\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"permalink\":\"/git/git-1\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"capture\":\"前言\\nGit 是目前广泛使用的分布式版本控制系统，在日常开发中经常会用到。\\n这篇文章记录了一些 Git 的基础知识和常用操作，希望能对大家有所帮助\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-1.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n Git 简介\\nGit 是一个 分布式版本控制系统，最初由 Linux 之父 Linus Torvalds 编写。它可以帮助我们跟踪代码的修改历史、多人协作开发，并在出问题时迅速回滚。\\n&gt; ✅ Git vs SVN：Git 是分布式的，每个开发者都有完整历史记录；\"},{\"url\":\"/tools/eslint.html\",\"relativePath\":\"/03.工具/Webpack 相关/lint.html\",\"frontmatter\":{\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/tools/eslint\",\"tags\":[\"eslint\",\"node\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"capture\":\"简介\\n本项目使用 express 脚手架初始化，并对其进行改造，从而实现一套完整的 eslint 工作流的 node 项目。本项目将全程使用 `pnpm` 作为包管理工具\\n本文将从以下几个方面过一遍 eslint 工作流\\n&lt;!--  --\\n&lt;p align=\\\"center\\\"&gt;\\n  &lt;img src=\\\"/imgs/eslint-process.svg\\\"/&gt;\\n&lt;/p&gt;\\n 初始化项目\\n```sh\\nnpx express-generator --view=pug express-template\\n```\\n也可以下全局下载 `express-generator`\"},{\"url\":\"/git/git-submodules.html\",\"relativePath\":\"/03.工具/Git 相关/git-submodules.html\",\"frontmatter\":{\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"permalink\":\"/git/git-submodules\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"capture\":\"项目背景\\n因公司项目要拆成多个模块，部分模块给分公司的小伙伴开发权限一起开发，所以最终决定使用 git 子模块来拆分项目，今天来复盘下项目拆分中爬过的一些坑。有兴趣的同学可以参考源码一起阅读，附源码。\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git-submodules.svg\\\"/&gt;\\n&lt;/p&gt;\\n 子模块\\n首先来科普一下 git 子模块\\n子模块允许你将一个 git 仓库作为另一个 git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。\\n官方中举了一个例子：某个工作中的项目需要包含并使用另一个\"},{\"url\":\"/basic/getport.html\",\"relativePath\":\"/01.前端/03. 工作技巧/getport.html\",\"frontmatter\":{\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"permalink\":\"/basic/getport\",\"tags\":[\"webpack\",\"node\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"capture\":\"一个问题\\n前段时间，公司项目改版登录，所有管理后台、大屏可视化或者说电脑 web 端的登录做成了一个模块统一授权登录，登录的域名是配置出来的，等他们联调完之后，我发现我本地项目跑起来后登录不了啦，找相关开发人员了解情况后才知道后端限制了 `localhost` 的访问(就离谱)\\n他们推荐前端开发人员本地安装 nginx，配置本机 hosts，用 nginx 做跳转，后端可访问域名白名单中添加有我们 hosts 中配置的域名\\n我是习惯了项目跑完后点击项目启动完成后的提示信息跳转页面进行开发(主要我不想本地配 nginx)，继续与他们交谈我了解到后端允许 127.0.0.1 进行接口访问，只需要在\"},{\"url\":\"/basic/tree.html\",\"relativePath\":\"/01.前端/03. 工作技巧/tree.html\",\"frontmatter\":{\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"permalink\":\"/basic/tree\",\"tags\":[\"工作\",\"算法\"],\"categories\":[\"算法\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"capture\":\"前言\\n在工作中我们经常见到用树的场景，比如说写前端页面时，每个页面就有对应的 DOM 树、CSSOM 树、渲染树等，或者开发过程中的写的级联选择器、菜单树、权限树、人员树等\\n面试的时候会被问到算法相关的知识，而刷树相关的题，是特别培养算法思维的，回溯、动规、分治算法其实都是树的问题\\n本文将汇总一些工作中常用的一些树的操作以及面试可能会问到二叉树相关的问题\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/tree.svg\\\"/&gt;\\n&lt;/p&gt;\\n 树（工作）\\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个\"},{\"url\":\"/basic/interview.html\",\"relativePath\":\"/01.前端/01. 基础/1. interview.html\",\"frontmatter\":{\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"permalink\":\"/basic/interview\",\"name\":\"面试题\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"capture\":\"1. 关于函数的 length 属性\\n360 面试过程遇到一个很有趣的问题，是关于函数的 length 属性的，题简写如下\\n```js\\n(() =\\n```\\n我所理解的拥有 `length` 的对象一般都是数组或者类数组对象，或者定义了 `length` 属性的对象，所以我回答说这个应该是 `false` 吧，后来面试告诉我函数是有 `length` 属性的，函数的 `length` 属性就是函数参数的个数，瞬间我恍然大悟，函数的参数就是 `arguments` ，而 `arguments` 也是一个类数组对象所以他是有 `length` 属性的\\n```js\\n// so\\n(() =&gt; 1)\"},{\"url\":\"/basic/array.html\",\"relativePath\":\"/01.前端/02. 代码实现/array.html\",\"frontmatter\":{\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"permalink\":\"/basic/array\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"capture\":\"在日常开发中，我们经常使用数组的 API。本文将详细介绍一些常用的数组操作方法，并提供其实现代码。\\n 任意位置插入单个成员\\n数组任意位置插入单个成员，这个 api 几乎可以作为数组插入的一个最基本的方法来处理，实现如下\\n按照数组 api 的规则，我们为数组增加了成员，那么要返回数组的长度\\n```js\\nfunction insert(arr, idx, item) {\\n  // 循环为什么要倒着写？看下面解释\\n  for (let i = arr.length - 1; i \\n    arr[i + 1] = arr[i];\\n  }\\n  arr[idx] = item;\\n  return arr\"},{\"url\":\"/pages/9492f1.html\",\"relativePath\":\"/views/plugins/chrome.html\",\"frontmatter\":{\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"tags\":[\"插件\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/9492f1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"\"},{\"url\":\"/pages/118849.html\",\"relativePath\":\"/views/plugins/vscode.html\",\"frontmatter\":{\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"插件\"],\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/118849\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"vscode 插件可以做什么\\nvscode 编辑器是可以高度自定义的，使用 vscode 插件几乎可以对 vscode 编辑器进行说有形式的自定义。\\nvscode 插件开发文档，中文文档\\nvscode 插件可以实现自定义指令、快捷键、自定义菜单项、自定义跳转、自动补全、悬浮提示、新增语言支持、语法检查、语法高亮、代码格式化等\\n 如何创建插件\\n我们使用官方来生成 vscode 插件模板项目\\n```sh\\n 安装 yo 和 generator-code\\nnpm install -g yo generator-code\\n 使用脚手架创建项目\\nyo code\\n```\\n yo 介绍\\nYeoman 是一个通\"},{\"url\":\"/tools/webpack-3.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-3.html\",\"frontmatter\":{\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-3\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"capture\":\"介绍\\n接前两篇，这篇文章介绍一些使用 Webpack 的小技巧，以及在实际业务场景中如何自定义 Loader 和 Plugin。由于最近工作比较忙，这篇笔记写得断断续续，可能有些杂乱，后续会不断优化。\\n 小技巧：require.context\\n在开发项目时，如果需要引入很多文件，可以使用 require.context 函数创建一个文件引入的上下文。该函数接受三个参数：要搜索的目录、是否搜索子目录、匹配文件的正则表达式。\\n```js\\n// 语法如下\\nrequire.context(directory, (useSubdirectories = false), (regExp = /^\\\\.\\\\//\"},{\"url\":\"/basic/vue.html\",\"relativePath\":\"/01.前端/02. 代码实现/vue-undone.html\",\"frontmatter\":{\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/vue\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"vue\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"capture\":\"数据劫持\\n 对象的劫持\\n2.x 版本的数据劫持是根据 Object.defineProperty 来实现的\\n```js\\nfunction observe(data) {\\n  // 不是对象直接返回\\n  if (!(typeof data === 'object' && data !== null)) return;\\n  return observer(data);\\n}\\nfunction observer(data) {\\n  if (Array.isArray(data)) {\\n    observeArray(data);\\n  } else {\\n    observeObject(data);\"},{\"url\":\"/FE/ast.html\",\"relativePath\":\"/01.前端/04. 浏览器/AST.html\",\"frontmatter\":{\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/FE/ast\",\"tags\":[\"ast\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"capture\":\"&lt;!--  背景 --\\n 什么是 AST\\n抽象语法树（`Abstract Syntax Tree`）简称 `AST`，是源代码的抽象语法结构的树状表现形式。`webpack`、`eslint` 等很多工具库的核心都是通过抽象语法书这个概念来实现对代码的检查、分析等操作。今天我为大家分享一下 JavaScript 这类解释型语言的抽象语法树的概念\\n我们常用的浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作。所以将 js 转化为抽象语法树更利于程序的分析。\\n&lt;!-- ast --&gt;\\n&lt;p align=\\\"left\\\" class=\\\"p-images\\\"&g\"},{\"url\":\"/basic/promise.html\",\"relativePath\":\"/01.前端/02. 代码实现/promise.html\",\"frontmatter\":{\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/promise\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"capture\":\"`promise` 的出现改变了以前 js 的回调风格。`promise` 核心是三种状态，`pending、resolve、reject`，状态一旦从 `pending` 变成其他状态则不可逆，其他用法细节将在实现 `promise` 的过程中一步步记录\\n 简单版 promise\\n- 首先我们实现函数异步函数执行的问题\\n```js\\n// 首先是三种状态\\nconst PENDING = 'pending';\\nconst RESOLVED = 'resolve';\\nconst REJECTED = 'reject';\\nfunction Promise(execute) {\\n  this.stat\"},{\"url\":\"/tools/webpack-2.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-2.html\",\"frontmatter\":{\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"tagsPage\":true,\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-2\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"capture\":\"安装\\n- 推荐本地安装，不推荐全局安装\\n- 安装本地 Webpack：npm i webpack webpack-cli -D\\n webpack 可以进行 0 配置\\n- 不需要配置任何东西，直接执行 webpack 就可以打包我们的代码\\n- 打包工具 -\\n- 打包（支持 js 模块化）\\n 手动配置 webpack\\n- 默认配置文件是 webpack.config.js\\n- 但是如果你不想使用这个文件也是可以的，可以使用 `--config webpack.other.js` 来让 webpack 使用其他的配置文件\\n 传参\\n- 如果需要在命令行后面传参，需要使用 `--`\\n```sh\\nnpm \"},{\"url\":\"/tools/command.html\",\"relativePath\":\"/03.工具/Npm 相关/command.html\",\"frontmatter\":{\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"permalink\":\"/tools/command\",\"tags\":[\"cli\",\"基础\",\"node\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"capture\":\"命令行\\n不管在 windows 还是 Mac、Linux 系统都会有很多命令来提供一些便捷的操作，比如在 window 中 打开 cmd 输入 `start snippingtool` 就可以打开绘图工具，cmd 里面执行的其实就是一个以 .bat 执行脚本，你也可以直接新建一个文件，然后在文件内部写入 `start snippingtool`，然后保存为 .bat 结尾的文件即可直接双击执行这个文件。在 Mac 和 Linux 中可以直接写内容，不需要后缀名，以 .sh 结尾也可以，但是 Mac 和 Linux 默认新建的脚本是没有执行权限的，需要 执行 `chmod +x 文件名` 给文件\"},{\"url\":\"/service/https.html\",\"relativePath\":\"/02.服务端/https-undone.html\",\"frontmatter\":{\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"permalink\":\"/service/https\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"capture\":\"https\\n参照老左笔记进行实践\\n 准备东西\\n首先准备一台空的服务器\\n 安装的东西\\n- 安装 git、nginx\\n```sh\\nyum install git\\nyum install nginx\\n```\\n 快速获取 Let's Encrypt 免费 SSL 证书\\n执行以下脚本，域名换成自己的域名，邮箱换成自己的邮箱，然后一路同意\\n注意：执行脚本的时候一定要停掉 nginx，否则会出错\\n```sh\\ngit clone https://github.com/letsencrypt/letsencrypt\\ncd letsencrypt\\n./letsencrypt-auto certonly --sta\"},{\"url\":\"/service/crypto.html\",\"relativePath\":\"/02.服务端/node/crypto.html\",\"frontmatter\":{\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"permalink\":\"/service/crypto\",\"tags\":[\"其他\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"capture\":\"crypto\\ncrypto 是 node 中实现加密解密的模块，使用 OpenSSL 类库作为内部实现加密解密的手段\\n 散列(哈希)算法\\n散列算法也叫哈希算法，用来把任意长度的输入换成固定长度的输出，常见的有 md5、sha1、sha256 等\\n散列算法好很多中，在 node 中可以使用 `crypto.getHashes()` 获取到 node 所支持的所有 hash 类型\\n 特点\\n- 相同的输入会产生相同的输出\\n- 不同的输出会产生不同的输出\\n- 任意的输入长度输出长度都是相同的\\n- 不能从输出推算输出的值（不能反解）\\n 用途\\n- 用来校验要下载的文件是否被改的\\n- 用来对数据库中保存的密\"},{\"url\":\"/service/http.html\",\"relativePath\":\"/02.服务端/http-undone.html\",\"frontmatter\":{\"title\":\"HTTP 笔记\",\"name\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"permalink\":\"/service/http\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"capture\":\"头部\\n 通用头\\n| 首部字段名        | 说明                       |\\n| ----------------- | -------------------------- |\\n| Cache-Control     | 控制缓存行为               |\\n| Connection        | 链接的管理                 |\\n| Date              | 报文日期                   |\\n| Pragma            | 报文指令                   |\\n| Trailer   \"},{\"url\":\"/service/linux.html\",\"relativePath\":\"/02.服务端/01.linux.html\",\"frontmatter\":{\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"permalink\":\"/service/linux\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"capture\":\"这篇文章涵盖了Linux系统中常见目录、文件管理、搜索、压缩解压等内容。我对其进行了语言优化和排版调整，以提高可读性和流畅性。\\n 常见目录\\n在 `Linux` 中一切皆文件\\n| 目录      | 作用                                                                                 |\\n| --------- | ------------------------------------------------------------------------------------ |\\n| /         | 根\"},{\"url\":\"/service/vmware.html\",\"relativePath\":\"/02.服务端/vmware-undone.html\",\"frontmatter\":{\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"permalink\":\"/service/vmware\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"],\"private\":true,\"privateRealm\":\"common\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"capture\":\"&lt;!-- 虽然都 0202 年了，现在都不流行装系统了，但是作为一个开发，经常与电脑打交道还是需要会装系统的。曾几何时，我们用 xp 系统的时候安装 --\\n 系统启动\\n计算机通电后，第一件事情就是读取输入 ROM 芯片的开机程序，这个程序叫做基本输入输出系统 `BIOS`（Basic Input/Output System）\\n`BIOS` 程序首先检查计算机硬件是否满足运行的基本条件，这个叫做硬件自检（Power-On Self-Test）\\n如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止，如果没有问题，屏幕会显示出 CPU、内存、硬盘等信息\\n硬件自检完成后，BIOS 会把控制权交给\"},{\"url\":\"/FE/jwt.html\",\"relativePath\":\"/01.前端/04. 浏览器/jwt.html\",\"frontmatter\":{\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"permalink\":\"/FE/jwt\",\"tags\":[\"http\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"capture\":\"还有几分钟就要跨年了，2019 即将结束，跨年夜独自一人闲来无趣，整理一下 `cookie、token` 和 `jwt` 的，记得在学校的时候我就很奇怪 `cookie` 是什么，当时老师只对我们说他就是用来存储数据的，只能存储 `4kb`，超过 `4kb` 之后就会开始删除之前的 `cookie` 值，不同浏览器删除的行为是不一样的。然后就没了。直到后来参加工作了，刚入公司没多久一次接触到了 `cookie` 让我一脸懵逼（当时带我的大佬有事回家了），项目出了 bug 因为 `cookie` 传递的不对，后台解析不了，然后我折腾了一晚上（回想当初小白的时候是真的有趣）。\\n今天来记录下工作这么\"},{\"url\":\"/FE/cache.html\",\"relativePath\":\"/01.前端/04. 浏览器/cache.html\",\"frontmatter\":{\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"permalink\":\"/FE/cache\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"capture\":\"缓存会根据进来的请求保存输出内容的副本；当下一个请求来临的时候，如果是相同的 `URL`，缓存会根据缓存机制决定是直接使用副本响应请求还是向源服务器再次发送请求。比较常见的。\\n比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 `URL` 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。至于浏览器和网站服务器是如何标识网站页面是否更新的机制，将在后面介绍。\\n缓存可以减少网络带宽的消耗、减低服务器的压力、减少网络延迟，加快页面打开速度\\n这里主要记录浏览器缓存。\\n Memory Cache\\n`memory\"},{\"url\":\"/basic/issue.html\",\"relativePath\":\"/01.前端/03. 工作技巧/02.issue.html\",\"frontmatter\":{\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"permalink\":\"/basic/issue\",\"tags\":[\"基础\",\"工作\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"capture\":\"获取一个月有多少天\\n今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据\\n`new Date(year, month, date, hrs, min, sec)` ， `new Date` 可以接受这些参数创建一个时间对象\\n其中当我们把 `date` 设置为 `0` 的时候，可以直接通过 `getDate()` 获取到最后一天的日期然后得到我们要的最后一天\\n```js\\nnew Date(2019, 12, 0).getDate(); // 31\\nnew Date(2018, 2, 0).getDate(); // 28\\n// 根据这个我们可以得到一个方法\\nfunc\"},{\"url\":\"/tools/npm-cli.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-cli.html\",\"frontmatter\":{\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"permalink\":\"/tools/npm-cli\",\"tags\":[\"cli\",\"node\",\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"capture\":\"思考\\n要开发一个脚手架需要捋清楚，脚手架是如何工作的？拿 `vue-cli` 来说，`vue-cli` 是将项目的模板放在 git 上面，执行 cli 命令的时候，再根据用户的交互选择不同的模板，然后经过模板引擎渲染出来生成项目。这样做将模板与脚手架分离，可以各自维护。\\n那我们先准备两套项目，一套作为自己的脚手架项目，一个作为模板\\n回想在使用 `vue-cli` 的时候，我们直接执行 `vue create projetcName` 然后进行一些交互便可以生成一个项目，生成的项目会拿到我们与用户交互的时候一些配置，会改变我们想要改变的一些文件。那我们就需要做完自己的脚手架后需要生成一个可以直接\"},{\"url\":\"/tools/npm-init.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-init.html\",\"frontmatter\":{\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"permalink\":\"/tools/npm-init\",\"tags\":[\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"capture\":\"npm init\\n初始化一个项目的时候，我们会在控制台输入 `npm init` 执行该命令后终端会依次询问 `name, version, description` 等字段，最后会为你生成一个 `package.json` 文件\\n如果想偷懒省去一路回车，可以在命令后面加 `--yes` 或者 `-y` 参数，这样会快速生成一个 `package.json` 文件\\n```sh\\n  npm init -y\\n```\\n这样生成出来的 `package.json` 是默认的配置，如果想要改变其默认配置怎么办？\\n 修改 npm 配置\\n初始化 `package.json` 时的字段默认值是可以自己配置的，\"},{\"url\":\"/service/conf.html\",\"relativePath\":\"/02.服务端/service-conf.html\",\"frontmatter\":{\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"permalink\":\"/service/conf\",\"tags\":[\"Linux\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"capture\":\"安装 nginx\\n&gt; 买了服务器，肯定先到控制台把服务器激活，然后重置登录密码，启动服务，然后怎么访问呢，那就先装个服务器呗，我选了 `nginx`，`nginx` 做内网转发还是挺不错的，现在也特别火，毕竟是轻量级的服务器。`nginx` 有什么好处我就不多说了，可以看看这篇文章讲解的很不错了\\n 安装前检查\\n- 安装 `nginx` 有两种方法，一种是源码包安装一种是 `yum` 安装，`yum` 安装可能不是最新版本的，这里我们选择了`源码包`安装\\n- 首先由于 `nginx` 的一些模块依赖一些 `lib` 库，所以在安装 `nginx` 之前，必须先安装这些 `lib` 库，这些\"},{\"url\":\"/basic/api.html\",\"relativePath\":\"/01.前端/02. 代码实现/api.html\",\"frontmatter\":{\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"permalink\":\"/basic/api\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"capture\":\"实现一个 new 操作符\\n&gt; 函数执行前面加个 `new` 做了哪些事情，为啥就会构造一个对象出来\\n- 创建了一个新对象\\n- 链接到了原型\\n- 执行函数，绑定了 this 指向新创建的对象上\\n- 返回一个对象，如果函数中有`return`关键字，看 return 了什么出来，如果是一个对象，那么返回这个对象，如果不是则返回我们新建的这个对象\\n- 实现过程如下：\\n```js\\nfunction New() {\\n  // 创建了一个新对象\\n  const obj = {};\\n  // 取得构造函数\\n  const F = [].shift.call(arguments);\\n  // 链接到了原\"},{\"url\":\"/basic/inherit.html\",\"relativePath\":\"/01.前端/01. 基础/inherit.html\",\"frontmatter\":{\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"permalink\":\"/basic/inherit\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"capture\":\"原型\\n 野史\\n&gt; 根据野史记载，Brendan Eich 用了一周的时间创造了今天的 JavaScript，当 Brendan Eich 在为 JavaScript 设计面向对象系统时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。而且 Brendan Eich 一开始就没有打算在 JavaScript 中加入类的概念，所以 JavaScript 是一门基于原型的语言。在原型编程的思想中，类并不是必须的，对象未必需要从类中创建而来，一个对象是通过另一个对象而得到的。\\n- 在曾探的《设计模式》中提到 JavaScript 中的原型继承会遵循以下这些原型编程的基本规则：\\n \"},{\"url\":\"/service/redis.html\",\"relativePath\":\"/02.服务端/redis.html\",\"frontmatter\":{\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"permalink\":\"/service/redis\",\"tags\":[\"其他\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"capture\":\"安装\\n- 官网有 Linux 的详细教程，安装省略，记录一下基本配置以及基础用法\\n 简介\\n\\n- Redis 是 `ket-value` 数据库。效率快，但功能单一；\\n- 常用做集中式会话管理（部署了负载均衡的服务之后，可用作 redis 来存储 _session_，可保证 _session_ 不用换一个服务请求一次）\\n- 用作缓存服务器（Redis 读取特别快：SET 操作每秒钟 110000 次，GET 操作每秒钟 81000 次。）\\n 基本命令\\n```sh\\n   启动redis，window启动方式\\n  redis-server redis.window.conf\\n   Linux启动\\n \"},{\"url\":\"/basic/mapbox.html\",\"relativePath\":\"/01.前端/03. 工作技巧/mapbox.html\",\"frontmatter\":{\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"permalink\":\"/basic/mapbox\",\"tags\":[\"可视化\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"capture\":\"底图渲染\\n- 初次渲染地图很简单，按照官网的配置\\n- 我们需要一个地图渲染容器，需要用到 mapbox-gl 库，有时候你可能需要准备一个开发者 token，那我们开始吧\\n- 首先我们实例化一个 Map 类，在 mapbox-gl 里面有个 Map 类，该类接受一个 options 配置对象作为初始化地图的条件\\n```js\\nimport mapboxgl from 'mapbox-gl';\\nconst options = {\\n  container: '底图容器',\\n  style: '您的底图json',\\n  // 经度越大越靠左，纬度越大越靠下\\n  center: [108.5, 38],\"},{\"url\":\"/service/proxy.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx-requisite.html\",\"frontmatter\":{\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"permalink\":\"/service/proxy\",\"tags\":[\"其他\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"capture\":\"反向代理与负载均衡\\n\\n&gt;\\n&gt; - 解决跨域\\n&gt; - 请求过滤\\n&gt; - 配置 gzip\\n&gt; - 负载均衡\\n&gt; - 静态资源服务器\\n 代理\\n&gt; &emsp;`代理` 是在服务器和客户端之间架设的一层服务器，代理将接受客户端的请求将它转发给服务器，然后将服务端的响应转发给客户端。不管正向代理还是反向代理，都是实现此功能。&lt;br/&gt; &gt; &emsp;说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。&lt;br/&gt; &gt; &emsp;举个例子：比如说生活中的专卖\"},{\"url\":\"/FE/website-render.html\",\"relativePath\":\"/01.前端/04. 浏览器/website-render.html\",\"frontmatter\":{\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"permalink\":\"/FE/website-render\",\"tags\":[\"基础\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"capture\":\"简单流程\\n\\n URL\\n- URL（_Uniform Resource Locator_），统一资源定位符，用于定位互联网上资源，俗称网址\\n- 一个基本的URL由以下几部分组成\\n  1. 协议部分（_protocol_）：常见的协议有 _http、https、ftp、file_，其中最常见的类型是 _http_，而 _https_ 则是进行加密的网络传输\\n  2. 域名部分（_domain_）：该 URL 的域名部分为 _www.aspxfans.com_。一个 URL 中，也可以使用 IP 地址作为域名使用，_www_ 也是 _http_ 的默认主机（_host_）\\n  3. 端口部分（_po\"},{\"url\":\"/service/mysql.html\",\"relativePath\":\"/02.服务端/02.mysql.html\",\"frontmatter\":{\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"permalink\":\"/service/mysql\",\"tags\":[\"MySQL\"],\"categories\":[\"MySQL\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"capture\":\"数据库操作\\n\\n 基本操作\\n```sql\\n  -- 创建数据库\\n  CREATE database_name;\\n  -- 查看数据库信息\\n  SHOW CREATE DATABASE database_name;\\n  -- 设置为 utf-8 格式的\\n  SET names utf8;\\n  -- 查看数据库\\n  SHOW DATABASES;\\n  -- 使用数据库，use 数据库名\\n  USE database_name;\\n  -- 创建表\\n  CREATE TABLE table_name (\\n    id    int(10),\\n    name  varchar(20),\\n    age \"},{\"url\":\"/service/nginx.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx.html\",\"frontmatter\":{\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"permalink\":\"/service/nginx\",\"tags\":[\"Nginx\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"capture\":\"安装\\n- 安装就暂时略过了，记录一下配置\\n 常用命令\\n- 做了软链接或者配置了 nginx 的环境变量可以用以下语法，没有话就需要指定到 nginx 所在的目录\\n- nginx -s stop 停止 nginx\\n- nginx -s quit 退出 nginx\\n- nginx -s reload 重新加载配置（修改配置文件后）\\n- nginx -s reopen 重启 nginx\\n- nginx -v 查看版本\\n- nginx -t 查看配置文件目录，检测配置文件是否有语法错误，然后退出\\n nginx.conf 配置文件\\nNginx 配置文件主要分成四部分：main（全局设置）、server（\"},{\"url\":\"/service/fs.html\",\"relativePath\":\"/02.服务端/node/fs.html\",\"frontmatter\":{\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/fs\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"文件操作\\n 读取文件\\n- fs 模块所有的都有同步和异步语法，异步语法直接写 api，同步写法就是 api 后紧跟 sync(同步)\\n- fs.readFile() 就是异步写法，那么同步写法就是 fs.readFilSync()\\n- 异步写法的返回值在回调函数中，同步写发直接就有返回值，这基本上也是 fs 所有模块的写法\\n```js\\nconst fs = require('fs');\\nconst path = require('path');\\nconst resolve = dir =&gt; path.join(__dirname, '..', dir);\\n// 异步写法\\nfs.readF\"},{\"url\":\"/service/process.html\",\"relativePath\":\"/02.服务端/node/process-undone.html\",\"frontmatter\":{\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/process\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"进程对象属性\\n| 属性       | 说明                                         |\\n|----------|--------------------------------------------|\\n| execPath | 可执行文件的绝对路径，如 `/usr/local/bin/node`         |\\n| version  | 版本号                                        |\\n| versions | 依赖库的版本号                                    |\\n| p\"},{\"url\":\"/tools/vue.html\",\"relativePath\":\"/03.工具/Webpack 相关/vue.html\",\"frontmatter\":{\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"permalink\":\"/tools/vue\",\"tags\":[\"webpack\",\"vue\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"capture\":\"从 0 开始搭建 vue 项目\\n&lt;!-- 第一行的东西会被作为标题来展示 --\\n`webpack` 打包部署 js 项目从以下几个方面考虑：\\n- js 的处理：转换 ES6 代码，解决浏览器兼容问题\\n- css 的处理：编译 css，自动添加前缀，抽取 css 到独立文件\\n- html 的处理：复制并压缩 html 文件\\n- dist 的清理：打包前清理源目录文件\\n- assets 的处理：静态资源处理\\n- server 的启用：development 模式下启动服务器并实时刷新\\n 一、项目结构\\n我们按照 vue-cli 的目录结构来新建一些目录，然后 webpack 做相应的配置，打开\"},{\"url\":\"/tools/webpack-1.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-1.html\",\"frontmatter\":{\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"capture\":\"webpack 介绍\\nWebpack 可以直接执行 webpack 命令进行打包，也可以通过手动配置实现更复杂的打包需求。配置文件为 webpack.config.js，可以导出一个对象或函数，函数接受两个参数：env（环境对象）和 argv（描述传递给 webpack 选项的 map 对象）。\\n来看一下这两个参数：\\n```js\\n  // 在 webpack.config.js 中输入以下代码\\n  module.exports = function(env, argv) {\\n    console.log(env, argv)\\n  }\\n  // 在控制台执行\\n  webpack --env=c\"},{\"url\":\"/basic/js.html\",\"relativePath\":\"/01.前端/01. 基础/javascript.html\",\"frontmatter\":{\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"permalink\":\"/basic/js\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"capture\":\"类型转换\\n 一个有趣的问题\\n&lt;p align=\\\"center\\\" class=\\\"p-images\\\"\\n  &lt;img src=\\\"/imgs/basis-javascript-type-change.jpg\\\" height=\\\"260\\\" /&gt;\\n&lt;/p&gt;\\n&gt; 看到了这个我亲自尝试了下，结果发现自己对 js 基础越来越陌生了，现在好好复习下吧\\n```js\\n0 == '0'; // true\\n0 == []; // true\\n'0' == []; // false\\n```\\n 为什么？\\n&gt; 为什么 '0' == [] 是 false ？&lt;br&gt;\\n&gt; 为\"},{\"url\":\"/basic/css.html\",\"relativePath\":\"/01.前端/01. 基础/css.html\",\"frontmatter\":{\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"permalink\":\"/basic/css\",\"tags\":[\"css\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"capture\":\"css 加载会造成阻塞吗\\n\\n css 加载会造成 DOM 树的阻塞嘛？\\n- 首先，_css_ 加载会阻塞 _DOM_ 树渲染，但是 _css_ 并不会阻塞 _DOM_ 树的解析\\n- 也就是说，你可以在 _css_ 加载完之前可以在 _js_ 中获取到 _DOM_ 元素，但是 _DOM_ 却是没有渲染到页面上，需要等到 _css_ 加载完毕才渲染\\n- 为什么会这样？\\n  - 在你加载 _css_ 的时候，可能会修改 _DOM_ 节点的样式，如果 _css_ 加载不阻塞 _DOM_ 树渲染的话，那么当 _css_ 加载完之后， _DOM_ 树可有又得重绘或者回流了\\n  - 所以干脆先把 _DOM_\"}],\"groupPostsByYear\":{\"2026 \":[{\"url\":\"/basic/modulo.html\",\"relativePath\":\"/01.前端/03. 工作技巧/01.modulo.html\",\"frontmatter\":{\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"permalink\":\"/basic/modulo\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"capture\":\"&gt; 最近面试被问到一个倒计时相关问题，又一次用到了取余（Modulo）。说实话，刚入行那会儿，总觉得这玩意儿不就是小学数学里的`求余数`\\n&gt; 吗？除了面试题里用来判断奇偶数，平时好像也没啥大用。\\n&gt;\\n&gt; 但随着代码写得越来越多，逐渐发现 `%` 符号背后其实隐藏着一种处理数据的思维模型——它能把无限延伸的线性世界，折叠成有限可控的\\n周期世界。今天想和大家分享一下我对取余的重新思考，看看它是怎么帮我们优雅地解决那些头疼的边界问题。\\n 重新认识 `%`\\n取余的本质，是将任意数值强行`限定`在一个固定的循环范围内。无论数字跑多远，`% N` 都能让它回归到 `0` 至 `N-\"}],\"2025 \":[{\"url\":\"/scriptures/sutra.html\",\"relativePath\":\"/04.经典摘录/空性与妙用.html\",\"frontmatter\":{\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"permalink\":\"/scriptures/sutra\",\"tags\":[\"人生\"],\"categories\":[\"经典\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"capture\":\"金刚经的那句话\\n\\n&gt;\\n&gt; 虚妄不是说不存在，而是说太唯心。\\n---\\n&gt; 举个例子：  \\n&gt; 你面前有一个杯子——\\n&gt; - 你喝水，它就是 水杯；\\n&gt; - 你抽烟，它就是 烟灰缸；\\n&gt; - 你插花，它就是 花瓶；\\n&gt; - 你插笔，它就是 笔筒；\\n&gt; - 你愤怒时，它就是 一地的玻璃渣。\\n---\\n&gt; 杯子本身，其实它什么也不是，这叫 空性。\\n&gt;\\n&gt; 你用它来干什么，它就是什么，这叫 妙用。\\n&gt;\\n&gt; 你非要坚持，它一定就是杯子，这叫 住相。\\n&gt;\\n&gt; 为此，你不惜和别人争论抬杠，这叫 我执。\\n&gt;\\n&g\"},{\"url\":\"/basic/vite-plugin-unique-page-chunks.html\",\"relativePath\":\"/01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.html\",\"frontmatter\":{\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"permalink\":\"/basic/vite-plugin-unique-page-chunks\",\"tags\":[\"插件\",\"Vite\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"capture\":\"问题背景\\n在某项目初上线优化代码的时候，打包后看到了类似的结果\\n```txt\\ndist/assets/index-CMe6Kk4E.js       0.63 kB │ gzip:   0.38 kB\\ndist/assets/index-DbyJIfZt.js     104.19 kB │ gzip:  40.96 kB\\ndist/assets/index-BN6vN86v.js     874.79 kB │ gzip: 282.58 kB\\ndist/assets/index-zD3tofSk.js   1,128.82 kB │ gzip: 375.52 kB\\n```\\n这些文件的名称几乎\"},{\"url\":\"/git/git-2.html\",\"relativePath\":\"/03.工具/Git 相关/git-2.html\",\"frontmatter\":{\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"permalink\":\"/git/git-2\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"capture\":\"前言\\n在第一篇中，我们掌握了 Git 的基础操作和核心概念。现在让我们继续深入，探索 Git 的高级特性和实战技巧。\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-2.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n 源的管理\\n```shell\\n 查看源仓库信息\\ngit remote -v\\n 修改源仓库信息\\ngit remote set-url &lt;origin_name&gt; &lt;url&gt;\\n 添加源仓库\\ngit remote add &lt;origin_name&gt; &lt;url&gt;\\n 删除源\"},{\"url\":\"/git/git-1.html\",\"relativePath\":\"/03.工具/Git 相关/git-1.html\",\"frontmatter\":{\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"permalink\":\"/git/git-1\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"capture\":\"前言\\nGit 是目前广泛使用的分布式版本控制系统，在日常开发中经常会用到。\\n这篇文章记录了一些 Git 的基础知识和常用操作，希望能对大家有所帮助\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-1.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n Git 简介\\nGit 是一个 分布式版本控制系统，最初由 Linux 之父 Linus Torvalds 编写。它可以帮助我们跟踪代码的修改历史、多人协作开发，并在出问题时迅速回滚。\\n&gt; ✅ Git vs SVN：Git 是分布式的，每个开发者都有完整历史记录；\"}],\"2022 \":[{\"url\":\"/tools/eslint.html\",\"relativePath\":\"/03.工具/Webpack 相关/lint.html\",\"frontmatter\":{\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/tools/eslint\",\"tags\":[\"eslint\",\"node\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"capture\":\"简介\\n本项目使用 express 脚手架初始化，并对其进行改造，从而实现一套完整的 eslint 工作流的 node 项目。本项目将全程使用 `pnpm` 作为包管理工具\\n本文将从以下几个方面过一遍 eslint 工作流\\n&lt;!--  --\\n&lt;p align=\\\"center\\\"&gt;\\n  &lt;img src=\\\"/imgs/eslint-process.svg\\\"/&gt;\\n&lt;/p&gt;\\n 初始化项目\\n```sh\\nnpx express-generator --view=pug express-template\\n```\\n也可以下全局下载 `express-generator`\"},{\"url\":\"/git/git-submodules.html\",\"relativePath\":\"/03.工具/Git 相关/git-submodules.html\",\"frontmatter\":{\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"permalink\":\"/git/git-submodules\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"capture\":\"项目背景\\n因公司项目要拆成多个模块，部分模块给分公司的小伙伴开发权限一起开发，所以最终决定使用 git 子模块来拆分项目，今天来复盘下项目拆分中爬过的一些坑。有兴趣的同学可以参考源码一起阅读，附源码。\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git-submodules.svg\\\"/&gt;\\n&lt;/p&gt;\\n 子模块\\n首先来科普一下 git 子模块\\n子模块允许你将一个 git 仓库作为另一个 git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。\\n官方中举了一个例子：某个工作中的项目需要包含并使用另一个\"},{\"url\":\"/basic/getport.html\",\"relativePath\":\"/01.前端/03. 工作技巧/getport.html\",\"frontmatter\":{\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"permalink\":\"/basic/getport\",\"tags\":[\"webpack\",\"node\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"capture\":\"一个问题\\n前段时间，公司项目改版登录，所有管理后台、大屏可视化或者说电脑 web 端的登录做成了一个模块统一授权登录，登录的域名是配置出来的，等他们联调完之后，我发现我本地项目跑起来后登录不了啦，找相关开发人员了解情况后才知道后端限制了 `localhost` 的访问(就离谱)\\n他们推荐前端开发人员本地安装 nginx，配置本机 hosts，用 nginx 做跳转，后端可访问域名白名单中添加有我们 hosts 中配置的域名\\n我是习惯了项目跑完后点击项目启动完成后的提示信息跳转页面进行开发(主要我不想本地配 nginx)，继续与他们交谈我了解到后端允许 127.0.0.1 进行接口访问，只需要在\"},{\"url\":\"/basic/tree.html\",\"relativePath\":\"/01.前端/03. 工作技巧/tree.html\",\"frontmatter\":{\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"permalink\":\"/basic/tree\",\"tags\":[\"工作\",\"算法\"],\"categories\":[\"算法\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"capture\":\"前言\\n在工作中我们经常见到用树的场景，比如说写前端页面时，每个页面就有对应的 DOM 树、CSSOM 树、渲染树等，或者开发过程中的写的级联选择器、菜单树、权限树、人员树等\\n面试的时候会被问到算法相关的知识，而刷树相关的题，是特别培养算法思维的，回溯、动规、分治算法其实都是树的问题\\n本文将汇总一些工作中常用的一些树的操作以及面试可能会问到二叉树相关的问题\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/tree.svg\\\"/&gt;\\n&lt;/p&gt;\\n 树（工作）\\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个\"}],\"2021 \":[{\"url\":\"/basic/interview.html\",\"relativePath\":\"/01.前端/01. 基础/1. interview.html\",\"frontmatter\":{\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"permalink\":\"/basic/interview\",\"name\":\"面试题\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"capture\":\"1. 关于函数的 length 属性\\n360 面试过程遇到一个很有趣的问题，是关于函数的 length 属性的，题简写如下\\n```js\\n(() =\\n```\\n我所理解的拥有 `length` 的对象一般都是数组或者类数组对象，或者定义了 `length` 属性的对象，所以我回答说这个应该是 `false` 吧，后来面试告诉我函数是有 `length` 属性的，函数的 `length` 属性就是函数参数的个数，瞬间我恍然大悟，函数的参数就是 `arguments` ，而 `arguments` 也是一个类数组对象所以他是有 `length` 属性的\\n```js\\n// so\\n(() =&gt; 1)\"},{\"url\":\"/basic/array.html\",\"relativePath\":\"/01.前端/02. 代码实现/array.html\",\"frontmatter\":{\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"permalink\":\"/basic/array\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"capture\":\"在日常开发中，我们经常使用数组的 API。本文将详细介绍一些常用的数组操作方法，并提供其实现代码。\\n 任意位置插入单个成员\\n数组任意位置插入单个成员，这个 api 几乎可以作为数组插入的一个最基本的方法来处理，实现如下\\n按照数组 api 的规则，我们为数组增加了成员，那么要返回数组的长度\\n```js\\nfunction insert(arr, idx, item) {\\n  // 循环为什么要倒着写？看下面解释\\n  for (let i = arr.length - 1; i \\n    arr[i + 1] = arr[i];\\n  }\\n  arr[idx] = item;\\n  return arr\"},{\"url\":\"/pages/9492f1.html\",\"relativePath\":\"/views/plugins/chrome.html\",\"frontmatter\":{\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"tags\":[\"插件\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/9492f1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"\"},{\"url\":\"/pages/118849.html\",\"relativePath\":\"/views/plugins/vscode.html\",\"frontmatter\":{\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"插件\"],\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/118849\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"vscode 插件可以做什么\\nvscode 编辑器是可以高度自定义的，使用 vscode 插件几乎可以对 vscode 编辑器进行说有形式的自定义。\\nvscode 插件开发文档，中文文档\\nvscode 插件可以实现自定义指令、快捷键、自定义菜单项、自定义跳转、自动补全、悬浮提示、新增语言支持、语法检查、语法高亮、代码格式化等\\n 如何创建插件\\n我们使用官方来生成 vscode 插件模板项目\\n```sh\\n 安装 yo 和 generator-code\\nnpm install -g yo generator-code\\n 使用脚手架创建项目\\nyo code\\n```\\n yo 介绍\\nYeoman 是一个通\"}],\"2020 \":[{\"url\":\"/tools/webpack-3.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-3.html\",\"frontmatter\":{\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-3\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"capture\":\"介绍\\n接前两篇，这篇文章介绍一些使用 Webpack 的小技巧，以及在实际业务场景中如何自定义 Loader 和 Plugin。由于最近工作比较忙，这篇笔记写得断断续续，可能有些杂乱，后续会不断优化。\\n 小技巧：require.context\\n在开发项目时，如果需要引入很多文件，可以使用 require.context 函数创建一个文件引入的上下文。该函数接受三个参数：要搜索的目录、是否搜索子目录、匹配文件的正则表达式。\\n```js\\n// 语法如下\\nrequire.context(directory, (useSubdirectories = false), (regExp = /^\\\\.\\\\//\"},{\"url\":\"/basic/vue.html\",\"relativePath\":\"/01.前端/02. 代码实现/vue-undone.html\",\"frontmatter\":{\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/vue\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"vue\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"capture\":\"数据劫持\\n 对象的劫持\\n2.x 版本的数据劫持是根据 Object.defineProperty 来实现的\\n```js\\nfunction observe(data) {\\n  // 不是对象直接返回\\n  if (!(typeof data === 'object' && data !== null)) return;\\n  return observer(data);\\n}\\nfunction observer(data) {\\n  if (Array.isArray(data)) {\\n    observeArray(data);\\n  } else {\\n    observeObject(data);\"},{\"url\":\"/FE/ast.html\",\"relativePath\":\"/01.前端/04. 浏览器/AST.html\",\"frontmatter\":{\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/FE/ast\",\"tags\":[\"ast\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"capture\":\"&lt;!--  背景 --\\n 什么是 AST\\n抽象语法树（`Abstract Syntax Tree`）简称 `AST`，是源代码的抽象语法结构的树状表现形式。`webpack`、`eslint` 等很多工具库的核心都是通过抽象语法书这个概念来实现对代码的检查、分析等操作。今天我为大家分享一下 JavaScript 这类解释型语言的抽象语法树的概念\\n我们常用的浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作。所以将 js 转化为抽象语法树更利于程序的分析。\\n&lt;!-- ast --&gt;\\n&lt;p align=\\\"left\\\" class=\\\"p-images\\\"&g\"},{\"url\":\"/basic/promise.html\",\"relativePath\":\"/01.前端/02. 代码实现/promise.html\",\"frontmatter\":{\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/promise\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"capture\":\"`promise` 的出现改变了以前 js 的回调风格。`promise` 核心是三种状态，`pending、resolve、reject`，状态一旦从 `pending` 变成其他状态则不可逆，其他用法细节将在实现 `promise` 的过程中一步步记录\\n 简单版 promise\\n- 首先我们实现函数异步函数执行的问题\\n```js\\n// 首先是三种状态\\nconst PENDING = 'pending';\\nconst RESOLVED = 'resolve';\\nconst REJECTED = 'reject';\\nfunction Promise(execute) {\\n  this.stat\"},{\"url\":\"/tools/webpack-2.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-2.html\",\"frontmatter\":{\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"tagsPage\":true,\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-2\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"capture\":\"安装\\n- 推荐本地安装，不推荐全局安装\\n- 安装本地 Webpack：npm i webpack webpack-cli -D\\n webpack 可以进行 0 配置\\n- 不需要配置任何东西，直接执行 webpack 就可以打包我们的代码\\n- 打包工具 -\\n- 打包（支持 js 模块化）\\n 手动配置 webpack\\n- 默认配置文件是 webpack.config.js\\n- 但是如果你不想使用这个文件也是可以的，可以使用 `--config webpack.other.js` 来让 webpack 使用其他的配置文件\\n 传参\\n- 如果需要在命令行后面传参，需要使用 `--`\\n```sh\\nnpm \"},{\"url\":\"/tools/command.html\",\"relativePath\":\"/03.工具/Npm 相关/command.html\",\"frontmatter\":{\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"permalink\":\"/tools/command\",\"tags\":[\"cli\",\"基础\",\"node\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"capture\":\"命令行\\n不管在 windows 还是 Mac、Linux 系统都会有很多命令来提供一些便捷的操作，比如在 window 中 打开 cmd 输入 `start snippingtool` 就可以打开绘图工具，cmd 里面执行的其实就是一个以 .bat 执行脚本，你也可以直接新建一个文件，然后在文件内部写入 `start snippingtool`，然后保存为 .bat 结尾的文件即可直接双击执行这个文件。在 Mac 和 Linux 中可以直接写内容，不需要后缀名，以 .sh 结尾也可以，但是 Mac 和 Linux 默认新建的脚本是没有执行权限的，需要 执行 `chmod +x 文件名` 给文件\"},{\"url\":\"/service/https.html\",\"relativePath\":\"/02.服务端/https-undone.html\",\"frontmatter\":{\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"permalink\":\"/service/https\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"capture\":\"https\\n参照老左笔记进行实践\\n 准备东西\\n首先准备一台空的服务器\\n 安装的东西\\n- 安装 git、nginx\\n```sh\\nyum install git\\nyum install nginx\\n```\\n 快速获取 Let's Encrypt 免费 SSL 证书\\n执行以下脚本，域名换成自己的域名，邮箱换成自己的邮箱，然后一路同意\\n注意：执行脚本的时候一定要停掉 nginx，否则会出错\\n```sh\\ngit clone https://github.com/letsencrypt/letsencrypt\\ncd letsencrypt\\n./letsencrypt-auto certonly --sta\"},{\"url\":\"/service/crypto.html\",\"relativePath\":\"/02.服务端/node/crypto.html\",\"frontmatter\":{\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"permalink\":\"/service/crypto\",\"tags\":[\"其他\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"capture\":\"crypto\\ncrypto 是 node 中实现加密解密的模块，使用 OpenSSL 类库作为内部实现加密解密的手段\\n 散列(哈希)算法\\n散列算法也叫哈希算法，用来把任意长度的输入换成固定长度的输出，常见的有 md5、sha1、sha256 等\\n散列算法好很多中，在 node 中可以使用 `crypto.getHashes()` 获取到 node 所支持的所有 hash 类型\\n 特点\\n- 相同的输入会产生相同的输出\\n- 不同的输出会产生不同的输出\\n- 任意的输入长度输出长度都是相同的\\n- 不能从输出推算输出的值（不能反解）\\n 用途\\n- 用来校验要下载的文件是否被改的\\n- 用来对数据库中保存的密\"},{\"url\":\"/service/http.html\",\"relativePath\":\"/02.服务端/http-undone.html\",\"frontmatter\":{\"title\":\"HTTP 笔记\",\"name\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"permalink\":\"/service/http\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"capture\":\"头部\\n 通用头\\n| 首部字段名        | 说明                       |\\n| ----------------- | -------------------------- |\\n| Cache-Control     | 控制缓存行为               |\\n| Connection        | 链接的管理                 |\\n| Date              | 报文日期                   |\\n| Pragma            | 报文指令                   |\\n| Trailer   \"},{\"url\":\"/service/linux.html\",\"relativePath\":\"/02.服务端/01.linux.html\",\"frontmatter\":{\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"permalink\":\"/service/linux\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"capture\":\"这篇文章涵盖了Linux系统中常见目录、文件管理、搜索、压缩解压等内容。我对其进行了语言优化和排版调整，以提高可读性和流畅性。\\n 常见目录\\n在 `Linux` 中一切皆文件\\n| 目录      | 作用                                                                                 |\\n| --------- | ------------------------------------------------------------------------------------ |\\n| /         | 根\"},{\"url\":\"/service/vmware.html\",\"relativePath\":\"/02.服务端/vmware-undone.html\",\"frontmatter\":{\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"permalink\":\"/service/vmware\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"],\"private\":true,\"privateRealm\":\"common\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"capture\":\"&lt;!-- 虽然都 0202 年了，现在都不流行装系统了，但是作为一个开发，经常与电脑打交道还是需要会装系统的。曾几何时，我们用 xp 系统的时候安装 --\\n 系统启动\\n计算机通电后，第一件事情就是读取输入 ROM 芯片的开机程序，这个程序叫做基本输入输出系统 `BIOS`（Basic Input/Output System）\\n`BIOS` 程序首先检查计算机硬件是否满足运行的基本条件，这个叫做硬件自检（Power-On Self-Test）\\n如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止，如果没有问题，屏幕会显示出 CPU、内存、硬盘等信息\\n硬件自检完成后，BIOS 会把控制权交给\"}],\"2019 \":[{\"url\":\"/FE/jwt.html\",\"relativePath\":\"/01.前端/04. 浏览器/jwt.html\",\"frontmatter\":{\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"permalink\":\"/FE/jwt\",\"tags\":[\"http\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"capture\":\"还有几分钟就要跨年了，2019 即将结束，跨年夜独自一人闲来无趣，整理一下 `cookie、token` 和 `jwt` 的，记得在学校的时候我就很奇怪 `cookie` 是什么，当时老师只对我们说他就是用来存储数据的，只能存储 `4kb`，超过 `4kb` 之后就会开始删除之前的 `cookie` 值，不同浏览器删除的行为是不一样的。然后就没了。直到后来参加工作了，刚入公司没多久一次接触到了 `cookie` 让我一脸懵逼（当时带我的大佬有事回家了），项目出了 bug 因为 `cookie` 传递的不对，后台解析不了，然后我折腾了一晚上（回想当初小白的时候是真的有趣）。\\n今天来记录下工作这么\"},{\"url\":\"/FE/cache.html\",\"relativePath\":\"/01.前端/04. 浏览器/cache.html\",\"frontmatter\":{\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"permalink\":\"/FE/cache\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"capture\":\"缓存会根据进来的请求保存输出内容的副本；当下一个请求来临的时候，如果是相同的 `URL`，缓存会根据缓存机制决定是直接使用副本响应请求还是向源服务器再次发送请求。比较常见的。\\n比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 `URL` 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。至于浏览器和网站服务器是如何标识网站页面是否更新的机制，将在后面介绍。\\n缓存可以减少网络带宽的消耗、减低服务器的压力、减少网络延迟，加快页面打开速度\\n这里主要记录浏览器缓存。\\n Memory Cache\\n`memory\"},{\"url\":\"/basic/issue.html\",\"relativePath\":\"/01.前端/03. 工作技巧/02.issue.html\",\"frontmatter\":{\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"permalink\":\"/basic/issue\",\"tags\":[\"基础\",\"工作\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"capture\":\"获取一个月有多少天\\n今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据\\n`new Date(year, month, date, hrs, min, sec)` ， `new Date` 可以接受这些参数创建一个时间对象\\n其中当我们把 `date` 设置为 `0` 的时候，可以直接通过 `getDate()` 获取到最后一天的日期然后得到我们要的最后一天\\n```js\\nnew Date(2019, 12, 0).getDate(); // 31\\nnew Date(2018, 2, 0).getDate(); // 28\\n// 根据这个我们可以得到一个方法\\nfunc\"},{\"url\":\"/tools/npm-cli.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-cli.html\",\"frontmatter\":{\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"permalink\":\"/tools/npm-cli\",\"tags\":[\"cli\",\"node\",\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"capture\":\"思考\\n要开发一个脚手架需要捋清楚，脚手架是如何工作的？拿 `vue-cli` 来说，`vue-cli` 是将项目的模板放在 git 上面，执行 cli 命令的时候，再根据用户的交互选择不同的模板，然后经过模板引擎渲染出来生成项目。这样做将模板与脚手架分离，可以各自维护。\\n那我们先准备两套项目，一套作为自己的脚手架项目，一个作为模板\\n回想在使用 `vue-cli` 的时候，我们直接执行 `vue create projetcName` 然后进行一些交互便可以生成一个项目，生成的项目会拿到我们与用户交互的时候一些配置，会改变我们想要改变的一些文件。那我们就需要做完自己的脚手架后需要生成一个可以直接\"},{\"url\":\"/tools/npm-init.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-init.html\",\"frontmatter\":{\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"permalink\":\"/tools/npm-init\",\"tags\":[\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"capture\":\"npm init\\n初始化一个项目的时候，我们会在控制台输入 `npm init` 执行该命令后终端会依次询问 `name, version, description` 等字段，最后会为你生成一个 `package.json` 文件\\n如果想偷懒省去一路回车，可以在命令后面加 `--yes` 或者 `-y` 参数，这样会快速生成一个 `package.json` 文件\\n```sh\\n  npm init -y\\n```\\n这样生成出来的 `package.json` 是默认的配置，如果想要改变其默认配置怎么办？\\n 修改 npm 配置\\n初始化 `package.json` 时的字段默认值是可以自己配置的，\"},{\"url\":\"/service/conf.html\",\"relativePath\":\"/02.服务端/service-conf.html\",\"frontmatter\":{\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"permalink\":\"/service/conf\",\"tags\":[\"Linux\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"capture\":\"安装 nginx\\n&gt; 买了服务器，肯定先到控制台把服务器激活，然后重置登录密码，启动服务，然后怎么访问呢，那就先装个服务器呗，我选了 `nginx`，`nginx` 做内网转发还是挺不错的，现在也特别火，毕竟是轻量级的服务器。`nginx` 有什么好处我就不多说了，可以看看这篇文章讲解的很不错了\\n 安装前检查\\n- 安装 `nginx` 有两种方法，一种是源码包安装一种是 `yum` 安装，`yum` 安装可能不是最新版本的，这里我们选择了`源码包`安装\\n- 首先由于 `nginx` 的一些模块依赖一些 `lib` 库，所以在安装 `nginx` 之前，必须先安装这些 `lib` 库，这些\"},{\"url\":\"/basic/api.html\",\"relativePath\":\"/01.前端/02. 代码实现/api.html\",\"frontmatter\":{\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"permalink\":\"/basic/api\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"capture\":\"实现一个 new 操作符\\n&gt; 函数执行前面加个 `new` 做了哪些事情，为啥就会构造一个对象出来\\n- 创建了一个新对象\\n- 链接到了原型\\n- 执行函数，绑定了 this 指向新创建的对象上\\n- 返回一个对象，如果函数中有`return`关键字，看 return 了什么出来，如果是一个对象，那么返回这个对象，如果不是则返回我们新建的这个对象\\n- 实现过程如下：\\n```js\\nfunction New() {\\n  // 创建了一个新对象\\n  const obj = {};\\n  // 取得构造函数\\n  const F = [].shift.call(arguments);\\n  // 链接到了原\"},{\"url\":\"/basic/inherit.html\",\"relativePath\":\"/01.前端/01. 基础/inherit.html\",\"frontmatter\":{\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"permalink\":\"/basic/inherit\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"capture\":\"原型\\n 野史\\n&gt; 根据野史记载，Brendan Eich 用了一周的时间创造了今天的 JavaScript，当 Brendan Eich 在为 JavaScript 设计面向对象系统时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。而且 Brendan Eich 一开始就没有打算在 JavaScript 中加入类的概念，所以 JavaScript 是一门基于原型的语言。在原型编程的思想中，类并不是必须的，对象未必需要从类中创建而来，一个对象是通过另一个对象而得到的。\\n- 在曾探的《设计模式》中提到 JavaScript 中的原型继承会遵循以下这些原型编程的基本规则：\\n \"},{\"url\":\"/service/redis.html\",\"relativePath\":\"/02.服务端/redis.html\",\"frontmatter\":{\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"permalink\":\"/service/redis\",\"tags\":[\"其他\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"capture\":\"安装\\n- 官网有 Linux 的详细教程，安装省略，记录一下基本配置以及基础用法\\n 简介\\n\\n- Redis 是 `ket-value` 数据库。效率快，但功能单一；\\n- 常用做集中式会话管理（部署了负载均衡的服务之后，可用作 redis 来存储 _session_，可保证 _session_ 不用换一个服务请求一次）\\n- 用作缓存服务器（Redis 读取特别快：SET 操作每秒钟 110000 次，GET 操作每秒钟 81000 次。）\\n 基本命令\\n```sh\\n   启动redis，window启动方式\\n  redis-server redis.window.conf\\n   Linux启动\\n \"},{\"url\":\"/basic/mapbox.html\",\"relativePath\":\"/01.前端/03. 工作技巧/mapbox.html\",\"frontmatter\":{\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"permalink\":\"/basic/mapbox\",\"tags\":[\"可视化\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"capture\":\"底图渲染\\n- 初次渲染地图很简单，按照官网的配置\\n- 我们需要一个地图渲染容器，需要用到 mapbox-gl 库，有时候你可能需要准备一个开发者 token，那我们开始吧\\n- 首先我们实例化一个 Map 类，在 mapbox-gl 里面有个 Map 类，该类接受一个 options 配置对象作为初始化地图的条件\\n```js\\nimport mapboxgl from 'mapbox-gl';\\nconst options = {\\n  container: '底图容器',\\n  style: '您的底图json',\\n  // 经度越大越靠左，纬度越大越靠下\\n  center: [108.5, 38],\"},{\"url\":\"/service/proxy.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx-requisite.html\",\"frontmatter\":{\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"permalink\":\"/service/proxy\",\"tags\":[\"其他\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"capture\":\"反向代理与负载均衡\\n\\n&gt;\\n&gt; - 解决跨域\\n&gt; - 请求过滤\\n&gt; - 配置 gzip\\n&gt; - 负载均衡\\n&gt; - 静态资源服务器\\n 代理\\n&gt; &emsp;`代理` 是在服务器和客户端之间架设的一层服务器，代理将接受客户端的请求将它转发给服务器，然后将服务端的响应转发给客户端。不管正向代理还是反向代理，都是实现此功能。&lt;br/&gt; &gt; &emsp;说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。&lt;br/&gt; &gt; &emsp;举个例子：比如说生活中的专卖\"},{\"url\":\"/FE/website-render.html\",\"relativePath\":\"/01.前端/04. 浏览器/website-render.html\",\"frontmatter\":{\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"permalink\":\"/FE/website-render\",\"tags\":[\"基础\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"capture\":\"简单流程\\n\\n URL\\n- URL（_Uniform Resource Locator_），统一资源定位符，用于定位互联网上资源，俗称网址\\n- 一个基本的URL由以下几部分组成\\n  1. 协议部分（_protocol_）：常见的协议有 _http、https、ftp、file_，其中最常见的类型是 _http_，而 _https_ 则是进行加密的网络传输\\n  2. 域名部分（_domain_）：该 URL 的域名部分为 _www.aspxfans.com_。一个 URL 中，也可以使用 IP 地址作为域名使用，_www_ 也是 _http_ 的默认主机（_host_）\\n  3. 端口部分（_po\"},{\"url\":\"/service/mysql.html\",\"relativePath\":\"/02.服务端/02.mysql.html\",\"frontmatter\":{\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"permalink\":\"/service/mysql\",\"tags\":[\"MySQL\"],\"categories\":[\"MySQL\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"capture\":\"数据库操作\\n\\n 基本操作\\n```sql\\n  -- 创建数据库\\n  CREATE database_name;\\n  -- 查看数据库信息\\n  SHOW CREATE DATABASE database_name;\\n  -- 设置为 utf-8 格式的\\n  SET names utf8;\\n  -- 查看数据库\\n  SHOW DATABASES;\\n  -- 使用数据库，use 数据库名\\n  USE database_name;\\n  -- 创建表\\n  CREATE TABLE table_name (\\n    id    int(10),\\n    name  varchar(20),\\n    age \"},{\"url\":\"/service/nginx.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx.html\",\"frontmatter\":{\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"permalink\":\"/service/nginx\",\"tags\":[\"Nginx\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"capture\":\"安装\\n- 安装就暂时略过了，记录一下配置\\n 常用命令\\n- 做了软链接或者配置了 nginx 的环境变量可以用以下语法，没有话就需要指定到 nginx 所在的目录\\n- nginx -s stop 停止 nginx\\n- nginx -s quit 退出 nginx\\n- nginx -s reload 重新加载配置（修改配置文件后）\\n- nginx -s reopen 重启 nginx\\n- nginx -v 查看版本\\n- nginx -t 查看配置文件目录，检测配置文件是否有语法错误，然后退出\\n nginx.conf 配置文件\\nNginx 配置文件主要分成四部分：main（全局设置）、server（\"},{\"url\":\"/service/fs.html\",\"relativePath\":\"/02.服务端/node/fs.html\",\"frontmatter\":{\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/fs\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"文件操作\\n 读取文件\\n- fs 模块所有的都有同步和异步语法，异步语法直接写 api，同步写法就是 api 后紧跟 sync(同步)\\n- fs.readFile() 就是异步写法，那么同步写法就是 fs.readFilSync()\\n- 异步写法的返回值在回调函数中，同步写发直接就有返回值，这基本上也是 fs 所有模块的写法\\n```js\\nconst fs = require('fs');\\nconst path = require('path');\\nconst resolve = dir =&gt; path.join(__dirname, '..', dir);\\n// 异步写法\\nfs.readF\"},{\"url\":\"/service/process.html\",\"relativePath\":\"/02.服务端/node/process-undone.html\",\"frontmatter\":{\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/process\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"进程对象属性\\n| 属性       | 说明                                         |\\n|----------|--------------------------------------------|\\n| execPath | 可执行文件的绝对路径，如 `/usr/local/bin/node`         |\\n| version  | 版本号                                        |\\n| versions | 依赖库的版本号                                    |\\n| p\"},{\"url\":\"/tools/vue.html\",\"relativePath\":\"/03.工具/Webpack 相关/vue.html\",\"frontmatter\":{\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"permalink\":\"/tools/vue\",\"tags\":[\"webpack\",\"vue\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"capture\":\"从 0 开始搭建 vue 项目\\n&lt;!-- 第一行的东西会被作为标题来展示 --\\n`webpack` 打包部署 js 项目从以下几个方面考虑：\\n- js 的处理：转换 ES6 代码，解决浏览器兼容问题\\n- css 的处理：编译 css，自动添加前缀，抽取 css 到独立文件\\n- html 的处理：复制并压缩 html 文件\\n- dist 的清理：打包前清理源目录文件\\n- assets 的处理：静态资源处理\\n- server 的启用：development 模式下启动服务器并实时刷新\\n 一、项目结构\\n我们按照 vue-cli 的目录结构来新建一些目录，然后 webpack 做相应的配置，打开\"},{\"url\":\"/tools/webpack-1.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-1.html\",\"frontmatter\":{\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"capture\":\"webpack 介绍\\nWebpack 可以直接执行 webpack 命令进行打包，也可以通过手动配置实现更复杂的打包需求。配置文件为 webpack.config.js，可以导出一个对象或函数，函数接受两个参数：env（环境对象）和 argv（描述传递给 webpack 选项的 map 对象）。\\n来看一下这两个参数：\\n```js\\n  // 在 webpack.config.js 中输入以下代码\\n  module.exports = function(env, argv) {\\n    console.log(env, argv)\\n  }\\n  // 在控制台执行\\n  webpack --env=c\"},{\"url\":\"/basic/js.html\",\"relativePath\":\"/01.前端/01. 基础/javascript.html\",\"frontmatter\":{\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"permalink\":\"/basic/js\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"capture\":\"类型转换\\n 一个有趣的问题\\n&lt;p align=\\\"center\\\" class=\\\"p-images\\\"\\n  &lt;img src=\\\"/imgs/basis-javascript-type-change.jpg\\\" height=\\\"260\\\" /&gt;\\n&lt;/p&gt;\\n&gt; 看到了这个我亲自尝试了下，结果发现自己对 js 基础越来越陌生了，现在好好复习下吧\\n```js\\n0 == '0'; // true\\n0 == []; // true\\n'0' == []; // false\\n```\\n 为什么？\\n&gt; 为什么 '0' == [] 是 false ？&lt;br&gt;\\n&gt; 为\"},{\"url\":\"/basic/css.html\",\"relativePath\":\"/01.前端/01. 基础/css.html\",\"frontmatter\":{\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"permalink\":\"/basic/css\",\"tags\":[\"css\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"capture\":\"css 加载会造成阻塞吗\\n\\n css 加载会造成 DOM 树的阻塞嘛？\\n- 首先，_css_ 加载会阻塞 _DOM_ 树渲染，但是 _css_ 并不会阻塞 _DOM_ 树的解析\\n- 也就是说，你可以在 _css_ 加载完之前可以在 _js_ 中获取到 _DOM_ 元素，但是 _DOM_ 却是没有渲染到页面上，需要等到 _css_ 加载完毕才渲染\\n- 为什么会这样？\\n  - 在你加载 _css_ 的时候，可能会修改 _DOM_ 节点的样式，如果 _css_ 加载不阻塞 _DOM_ 树渲染的话，那么当 _css_ 加载完之后， _DOM_ 树可有又得重绘或者回流了\\n  - 所以干脆先把 _DOM_\"}]},\"groupPostsByYearMonth\":{\"2026 \":{\"02\":[{\"url\":\"/basic/modulo.html\",\"relativePath\":\"/01.前端/03. 工作技巧/01.modulo.html\",\"frontmatter\":{\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"permalink\":\"/basic/modulo\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"capture\":\"&gt; 最近面试被问到一个倒计时相关问题，又一次用到了取余（Modulo）。说实话，刚入行那会儿，总觉得这玩意儿不就是小学数学里的`求余数`\\n&gt; 吗？除了面试题里用来判断奇偶数，平时好像也没啥大用。\\n&gt;\\n&gt; 但随着代码写得越来越多，逐渐发现 `%` 符号背后其实隐藏着一种处理数据的思维模型——它能把无限延伸的线性世界，折叠成有限可控的\\n周期世界。今天想和大家分享一下我对取余的重新思考，看看它是怎么帮我们优雅地解决那些头疼的边界问题。\\n 重新认识 `%`\\n取余的本质，是将任意数值强行`限定`在一个固定的循环范围内。无论数字跑多远，`% N` 都能让它回归到 `0` 至 `N-\"}]},\"2025 \":{\"09\":[{\"url\":\"/scriptures/sutra.html\",\"relativePath\":\"/04.经典摘录/空性与妙用.html\",\"frontmatter\":{\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"permalink\":\"/scriptures/sutra\",\"tags\":[\"人生\"],\"categories\":[\"经典\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"capture\":\"金刚经的那句话\\n\\n&gt;\\n&gt; 虚妄不是说不存在，而是说太唯心。\\n---\\n&gt; 举个例子：  \\n&gt; 你面前有一个杯子——\\n&gt; - 你喝水，它就是 水杯；\\n&gt; - 你抽烟，它就是 烟灰缸；\\n&gt; - 你插花，它就是 花瓶；\\n&gt; - 你插笔，它就是 笔筒；\\n&gt; - 你愤怒时，它就是 一地的玻璃渣。\\n---\\n&gt; 杯子本身，其实它什么也不是，这叫 空性。\\n&gt;\\n&gt; 你用它来干什么，它就是什么，这叫 妙用。\\n&gt;\\n&gt; 你非要坚持，它一定就是杯子，这叫 住相。\\n&gt;\\n&gt; 为此，你不惜和别人争论抬杠，这叫 我执。\\n&gt;\\n&g\"},{\"url\":\"/basic/vite-plugin-unique-page-chunks.html\",\"relativePath\":\"/01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.html\",\"frontmatter\":{\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"permalink\":\"/basic/vite-plugin-unique-page-chunks\",\"tags\":[\"插件\",\"Vite\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"capture\":\"问题背景\\n在某项目初上线优化代码的时候，打包后看到了类似的结果\\n```txt\\ndist/assets/index-CMe6Kk4E.js       0.63 kB │ gzip:   0.38 kB\\ndist/assets/index-DbyJIfZt.js     104.19 kB │ gzip:  40.96 kB\\ndist/assets/index-BN6vN86v.js     874.79 kB │ gzip: 282.58 kB\\ndist/assets/index-zD3tofSk.js   1,128.82 kB │ gzip: 375.52 kB\\n```\\n这些文件的名称几乎\"}],\"07\":[{\"url\":\"/git/git-2.html\",\"relativePath\":\"/03.工具/Git 相关/git-2.html\",\"frontmatter\":{\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"permalink\":\"/git/git-2\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"capture\":\"前言\\n在第一篇中，我们掌握了 Git 的基础操作和核心概念。现在让我们继续深入，探索 Git 的高级特性和实战技巧。\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-2.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n 源的管理\\n```shell\\n 查看源仓库信息\\ngit remote -v\\n 修改源仓库信息\\ngit remote set-url &lt;origin_name&gt; &lt;url&gt;\\n 添加源仓库\\ngit remote add &lt;origin_name&gt; &lt;url&gt;\\n 删除源\"}],\"06\":[{\"url\":\"/git/git-1.html\",\"relativePath\":\"/03.工具/Git 相关/git-1.html\",\"frontmatter\":{\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"permalink\":\"/git/git-1\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"capture\":\"前言\\nGit 是目前广泛使用的分布式版本控制系统，在日常开发中经常会用到。\\n这篇文章记录了一些 Git 的基础知识和常用操作，希望能对大家有所帮助\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-1.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n Git 简介\\nGit 是一个 分布式版本控制系统，最初由 Linux 之父 Linus Torvalds 编写。它可以帮助我们跟踪代码的修改历史、多人协作开发，并在出问题时迅速回滚。\\n&gt; ✅ Git vs SVN：Git 是分布式的，每个开发者都有完整历史记录；\"}]},\"2022 \":{\"10\":[{\"url\":\"/tools/eslint.html\",\"relativePath\":\"/03.工具/Webpack 相关/lint.html\",\"frontmatter\":{\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/tools/eslint\",\"tags\":[\"eslint\",\"node\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"capture\":\"简介\\n本项目使用 express 脚手架初始化，并对其进行改造，从而实现一套完整的 eslint 工作流的 node 项目。本项目将全程使用 `pnpm` 作为包管理工具\\n本文将从以下几个方面过一遍 eslint 工作流\\n&lt;!--  --\\n&lt;p align=\\\"center\\\"&gt;\\n  &lt;img src=\\\"/imgs/eslint-process.svg\\\"/&gt;\\n&lt;/p&gt;\\n 初始化项目\\n```sh\\nnpx express-generator --view=pug express-template\\n```\\n也可以下全局下载 `express-generator`\"}],\"05\":[{\"url\":\"/git/git-submodules.html\",\"relativePath\":\"/03.工具/Git 相关/git-submodules.html\",\"frontmatter\":{\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"permalink\":\"/git/git-submodules\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"capture\":\"项目背景\\n因公司项目要拆成多个模块，部分模块给分公司的小伙伴开发权限一起开发，所以最终决定使用 git 子模块来拆分项目，今天来复盘下项目拆分中爬过的一些坑。有兴趣的同学可以参考源码一起阅读，附源码。\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git-submodules.svg\\\"/&gt;\\n&lt;/p&gt;\\n 子模块\\n首先来科普一下 git 子模块\\n子模块允许你将一个 git 仓库作为另一个 git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。\\n官方中举了一个例子：某个工作中的项目需要包含并使用另一个\"}],\"04\":[{\"url\":\"/basic/getport.html\",\"relativePath\":\"/01.前端/03. 工作技巧/getport.html\",\"frontmatter\":{\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"permalink\":\"/basic/getport\",\"tags\":[\"webpack\",\"node\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"capture\":\"一个问题\\n前段时间，公司项目改版登录，所有管理后台、大屏可视化或者说电脑 web 端的登录做成了一个模块统一授权登录，登录的域名是配置出来的，等他们联调完之后，我发现我本地项目跑起来后登录不了啦，找相关开发人员了解情况后才知道后端限制了 `localhost` 的访问(就离谱)\\n他们推荐前端开发人员本地安装 nginx，配置本机 hosts，用 nginx 做跳转，后端可访问域名白名单中添加有我们 hosts 中配置的域名\\n我是习惯了项目跑完后点击项目启动完成后的提示信息跳转页面进行开发(主要我不想本地配 nginx)，继续与他们交谈我了解到后端允许 127.0.0.1 进行接口访问，只需要在\"}],\"03\":[{\"url\":\"/basic/tree.html\",\"relativePath\":\"/01.前端/03. 工作技巧/tree.html\",\"frontmatter\":{\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"permalink\":\"/basic/tree\",\"tags\":[\"工作\",\"算法\"],\"categories\":[\"算法\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"capture\":\"前言\\n在工作中我们经常见到用树的场景，比如说写前端页面时，每个页面就有对应的 DOM 树、CSSOM 树、渲染树等，或者开发过程中的写的级联选择器、菜单树、权限树、人员树等\\n面试的时候会被问到算法相关的知识，而刷树相关的题，是特别培养算法思维的，回溯、动规、分治算法其实都是树的问题\\n本文将汇总一些工作中常用的一些树的操作以及面试可能会问到二叉树相关的问题\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/tree.svg\\\"/&gt;\\n&lt;/p&gt;\\n 树（工作）\\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个\"}]},\"2021 \":{\"08\":[{\"url\":\"/basic/interview.html\",\"relativePath\":\"/01.前端/01. 基础/1. interview.html\",\"frontmatter\":{\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"permalink\":\"/basic/interview\",\"name\":\"面试题\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"capture\":\"1. 关于函数的 length 属性\\n360 面试过程遇到一个很有趣的问题，是关于函数的 length 属性的，题简写如下\\n```js\\n(() =\\n```\\n我所理解的拥有 `length` 的对象一般都是数组或者类数组对象，或者定义了 `length` 属性的对象，所以我回答说这个应该是 `false` 吧，后来面试告诉我函数是有 `length` 属性的，函数的 `length` 属性就是函数参数的个数，瞬间我恍然大悟，函数的参数就是 `arguments` ，而 `arguments` 也是一个类数组对象所以他是有 `length` 属性的\\n```js\\n// so\\n(() =&gt; 1)\"}],\"05\":[{\"url\":\"/basic/array.html\",\"relativePath\":\"/01.前端/02. 代码实现/array.html\",\"frontmatter\":{\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"permalink\":\"/basic/array\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"capture\":\"在日常开发中，我们经常使用数组的 API。本文将详细介绍一些常用的数组操作方法，并提供其实现代码。\\n 任意位置插入单个成员\\n数组任意位置插入单个成员，这个 api 几乎可以作为数组插入的一个最基本的方法来处理，实现如下\\n按照数组 api 的规则，我们为数组增加了成员，那么要返回数组的长度\\n```js\\nfunction insert(arr, idx, item) {\\n  // 循环为什么要倒着写？看下面解释\\n  for (let i = arr.length - 1; i \\n    arr[i + 1] = arr[i];\\n  }\\n  arr[idx] = item;\\n  return arr\"}],\"03\":[{\"url\":\"/pages/9492f1.html\",\"relativePath\":\"/views/plugins/chrome.html\",\"frontmatter\":{\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"tags\":[\"插件\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/9492f1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"\"},{\"url\":\"/pages/118849.html\",\"relativePath\":\"/views/plugins/vscode.html\",\"frontmatter\":{\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"插件\"],\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/118849\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"vscode 插件可以做什么\\nvscode 编辑器是可以高度自定义的，使用 vscode 插件几乎可以对 vscode 编辑器进行说有形式的自定义。\\nvscode 插件开发文档，中文文档\\nvscode 插件可以实现自定义指令、快捷键、自定义菜单项、自定义跳转、自动补全、悬浮提示、新增语言支持、语法检查、语法高亮、代码格式化等\\n 如何创建插件\\n我们使用官方来生成 vscode 插件模板项目\\n```sh\\n 安装 yo 和 generator-code\\nnpm install -g yo generator-code\\n 使用脚手架创建项目\\nyo code\\n```\\n yo 介绍\\nYeoman 是一个通\"}]},\"2020 \":{\"09\":[{\"url\":\"/tools/webpack-3.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-3.html\",\"frontmatter\":{\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-3\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"capture\":\"介绍\\n接前两篇，这篇文章介绍一些使用 Webpack 的小技巧，以及在实际业务场景中如何自定义 Loader 和 Plugin。由于最近工作比较忙，这篇笔记写得断断续续，可能有些杂乱，后续会不断优化。\\n 小技巧：require.context\\n在开发项目时，如果需要引入很多文件，可以使用 require.context 函数创建一个文件引入的上下文。该函数接受三个参数：要搜索的目录、是否搜索子目录、匹配文件的正则表达式。\\n```js\\n// 语法如下\\nrequire.context(directory, (useSubdirectories = false), (regExp = /^\\\\.\\\\//\"}],\"06\":[{\"url\":\"/basic/vue.html\",\"relativePath\":\"/01.前端/02. 代码实现/vue-undone.html\",\"frontmatter\":{\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/vue\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"vue\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"capture\":\"数据劫持\\n 对象的劫持\\n2.x 版本的数据劫持是根据 Object.defineProperty 来实现的\\n```js\\nfunction observe(data) {\\n  // 不是对象直接返回\\n  if (!(typeof data === 'object' && data !== null)) return;\\n  return observer(data);\\n}\\nfunction observer(data) {\\n  if (Array.isArray(data)) {\\n    observeArray(data);\\n  } else {\\n    observeObject(data);\"},{\"url\":\"/FE/ast.html\",\"relativePath\":\"/01.前端/04. 浏览器/AST.html\",\"frontmatter\":{\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/FE/ast\",\"tags\":[\"ast\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"capture\":\"&lt;!--  背景 --\\n 什么是 AST\\n抽象语法树（`Abstract Syntax Tree`）简称 `AST`，是源代码的抽象语法结构的树状表现形式。`webpack`、`eslint` 等很多工具库的核心都是通过抽象语法书这个概念来实现对代码的检查、分析等操作。今天我为大家分享一下 JavaScript 这类解释型语言的抽象语法树的概念\\n我们常用的浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作。所以将 js 转化为抽象语法树更利于程序的分析。\\n&lt;!-- ast --&gt;\\n&lt;p align=\\\"left\\\" class=\\\"p-images\\\"&g\"}],\"03\":[{\"url\":\"/basic/promise.html\",\"relativePath\":\"/01.前端/02. 代码实现/promise.html\",\"frontmatter\":{\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/promise\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"capture\":\"`promise` 的出现改变了以前 js 的回调风格。`promise` 核心是三种状态，`pending、resolve、reject`，状态一旦从 `pending` 变成其他状态则不可逆，其他用法细节将在实现 `promise` 的过程中一步步记录\\n 简单版 promise\\n- 首先我们实现函数异步函数执行的问题\\n```js\\n// 首先是三种状态\\nconst PENDING = 'pending';\\nconst RESOLVED = 'resolve';\\nconst REJECTED = 'reject';\\nfunction Promise(execute) {\\n  this.stat\"},{\"url\":\"/tools/webpack-2.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-2.html\",\"frontmatter\":{\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"tagsPage\":true,\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-2\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"capture\":\"安装\\n- 推荐本地安装，不推荐全局安装\\n- 安装本地 Webpack：npm i webpack webpack-cli -D\\n webpack 可以进行 0 配置\\n- 不需要配置任何东西，直接执行 webpack 就可以打包我们的代码\\n- 打包工具 -\\n- 打包（支持 js 模块化）\\n 手动配置 webpack\\n- 默认配置文件是 webpack.config.js\\n- 但是如果你不想使用这个文件也是可以的，可以使用 `--config webpack.other.js` 来让 webpack 使用其他的配置文件\\n 传参\\n- 如果需要在命令行后面传参，需要使用 `--`\\n```sh\\nnpm \"},{\"url\":\"/tools/command.html\",\"relativePath\":\"/03.工具/Npm 相关/command.html\",\"frontmatter\":{\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"permalink\":\"/tools/command\",\"tags\":[\"cli\",\"基础\",\"node\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"capture\":\"命令行\\n不管在 windows 还是 Mac、Linux 系统都会有很多命令来提供一些便捷的操作，比如在 window 中 打开 cmd 输入 `start snippingtool` 就可以打开绘图工具，cmd 里面执行的其实就是一个以 .bat 执行脚本，你也可以直接新建一个文件，然后在文件内部写入 `start snippingtool`，然后保存为 .bat 结尾的文件即可直接双击执行这个文件。在 Mac 和 Linux 中可以直接写内容，不需要后缀名，以 .sh 结尾也可以，但是 Mac 和 Linux 默认新建的脚本是没有执行权限的，需要 执行 `chmod +x 文件名` 给文件\"}],\"02\":[{\"url\":\"/service/https.html\",\"relativePath\":\"/02.服务端/https-undone.html\",\"frontmatter\":{\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"permalink\":\"/service/https\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"capture\":\"https\\n参照老左笔记进行实践\\n 准备东西\\n首先准备一台空的服务器\\n 安装的东西\\n- 安装 git、nginx\\n```sh\\nyum install git\\nyum install nginx\\n```\\n 快速获取 Let's Encrypt 免费 SSL 证书\\n执行以下脚本，域名换成自己的域名，邮箱换成自己的邮箱，然后一路同意\\n注意：执行脚本的时候一定要停掉 nginx，否则会出错\\n```sh\\ngit clone https://github.com/letsencrypt/letsencrypt\\ncd letsencrypt\\n./letsencrypt-auto certonly --sta\"},{\"url\":\"/service/crypto.html\",\"relativePath\":\"/02.服务端/node/crypto.html\",\"frontmatter\":{\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"permalink\":\"/service/crypto\",\"tags\":[\"其他\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"capture\":\"crypto\\ncrypto 是 node 中实现加密解密的模块，使用 OpenSSL 类库作为内部实现加密解密的手段\\n 散列(哈希)算法\\n散列算法也叫哈希算法，用来把任意长度的输入换成固定长度的输出，常见的有 md5、sha1、sha256 等\\n散列算法好很多中，在 node 中可以使用 `crypto.getHashes()` 获取到 node 所支持的所有 hash 类型\\n 特点\\n- 相同的输入会产生相同的输出\\n- 不同的输出会产生不同的输出\\n- 任意的输入长度输出长度都是相同的\\n- 不能从输出推算输出的值（不能反解）\\n 用途\\n- 用来校验要下载的文件是否被改的\\n- 用来对数据库中保存的密\"},{\"url\":\"/service/http.html\",\"relativePath\":\"/02.服务端/http-undone.html\",\"frontmatter\":{\"title\":\"HTTP 笔记\",\"name\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"permalink\":\"/service/http\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"capture\":\"头部\\n 通用头\\n| 首部字段名        | 说明                       |\\n| ----------------- | -------------------------- |\\n| Cache-Control     | 控制缓存行为               |\\n| Connection        | 链接的管理                 |\\n| Date              | 报文日期                   |\\n| Pragma            | 报文指令                   |\\n| Trailer   \"}],\"01\":[{\"url\":\"/service/linux.html\",\"relativePath\":\"/02.服务端/01.linux.html\",\"frontmatter\":{\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"permalink\":\"/service/linux\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"capture\":\"这篇文章涵盖了Linux系统中常见目录、文件管理、搜索、压缩解压等内容。我对其进行了语言优化和排版调整，以提高可读性和流畅性。\\n 常见目录\\n在 `Linux` 中一切皆文件\\n| 目录      | 作用                                                                                 |\\n| --------- | ------------------------------------------------------------------------------------ |\\n| /         | 根\"},{\"url\":\"/service/vmware.html\",\"relativePath\":\"/02.服务端/vmware-undone.html\",\"frontmatter\":{\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"permalink\":\"/service/vmware\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"],\"private\":true,\"privateRealm\":\"common\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"capture\":\"&lt;!-- 虽然都 0202 年了，现在都不流行装系统了，但是作为一个开发，经常与电脑打交道还是需要会装系统的。曾几何时，我们用 xp 系统的时候安装 --\\n 系统启动\\n计算机通电后，第一件事情就是读取输入 ROM 芯片的开机程序，这个程序叫做基本输入输出系统 `BIOS`（Basic Input/Output System）\\n`BIOS` 程序首先检查计算机硬件是否满足运行的基本条件，这个叫做硬件自检（Power-On Self-Test）\\n如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止，如果没有问题，屏幕会显示出 CPU、内存、硬盘等信息\\n硬件自检完成后，BIOS 会把控制权交给\"}]},\"2019 \":{\"10\":[{\"url\":\"/basic/api.html\",\"relativePath\":\"/01.前端/02. 代码实现/api.html\",\"frontmatter\":{\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"permalink\":\"/basic/api\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"capture\":\"实现一个 new 操作符\\n&gt; 函数执行前面加个 `new` 做了哪些事情，为啥就会构造一个对象出来\\n- 创建了一个新对象\\n- 链接到了原型\\n- 执行函数，绑定了 this 指向新创建的对象上\\n- 返回一个对象，如果函数中有`return`关键字，看 return 了什么出来，如果是一个对象，那么返回这个对象，如果不是则返回我们新建的这个对象\\n- 实现过程如下：\\n```js\\nfunction New() {\\n  // 创建了一个新对象\\n  const obj = {};\\n  // 取得构造函数\\n  const F = [].shift.call(arguments);\\n  // 链接到了原\"},{\"url\":\"/basic/inherit.html\",\"relativePath\":\"/01.前端/01. 基础/inherit.html\",\"frontmatter\":{\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"permalink\":\"/basic/inherit\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"capture\":\"原型\\n 野史\\n&gt; 根据野史记载，Brendan Eich 用了一周的时间创造了今天的 JavaScript，当 Brendan Eich 在为 JavaScript 设计面向对象系统时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。而且 Brendan Eich 一开始就没有打算在 JavaScript 中加入类的概念，所以 JavaScript 是一门基于原型的语言。在原型编程的思想中，类并不是必须的，对象未必需要从类中创建而来，一个对象是通过另一个对象而得到的。\\n- 在曾探的《设计模式》中提到 JavaScript 中的原型继承会遵循以下这些原型编程的基本规则：\\n \"}],\"11\":[{\"url\":\"/service/conf.html\",\"relativePath\":\"/02.服务端/service-conf.html\",\"frontmatter\":{\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"permalink\":\"/service/conf\",\"tags\":[\"Linux\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"capture\":\"安装 nginx\\n&gt; 买了服务器，肯定先到控制台把服务器激活，然后重置登录密码，启动服务，然后怎么访问呢，那就先装个服务器呗，我选了 `nginx`，`nginx` 做内网转发还是挺不错的，现在也特别火，毕竟是轻量级的服务器。`nginx` 有什么好处我就不多说了，可以看看这篇文章讲解的很不错了\\n 安装前检查\\n- 安装 `nginx` 有两种方法，一种是源码包安装一种是 `yum` 安装，`yum` 安装可能不是最新版本的，这里我们选择了`源码包`安装\\n- 首先由于 `nginx` 的一些模块依赖一些 `lib` 库，所以在安装 `nginx` 之前，必须先安装这些 `lib` 库，这些\"}],\"12\":[{\"url\":\"/FE/jwt.html\",\"relativePath\":\"/01.前端/04. 浏览器/jwt.html\",\"frontmatter\":{\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"permalink\":\"/FE/jwt\",\"tags\":[\"http\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"capture\":\"还有几分钟就要跨年了，2019 即将结束，跨年夜独自一人闲来无趣，整理一下 `cookie、token` 和 `jwt` 的，记得在学校的时候我就很奇怪 `cookie` 是什么，当时老师只对我们说他就是用来存储数据的，只能存储 `4kb`，超过 `4kb` 之后就会开始删除之前的 `cookie` 值，不同浏览器删除的行为是不一样的。然后就没了。直到后来参加工作了，刚入公司没多久一次接触到了 `cookie` 让我一脸懵逼（当时带我的大佬有事回家了），项目出了 bug 因为 `cookie` 传递的不对，后台解析不了，然后我折腾了一晚上（回想当初小白的时候是真的有趣）。\\n今天来记录下工作这么\"},{\"url\":\"/FE/cache.html\",\"relativePath\":\"/01.前端/04. 浏览器/cache.html\",\"frontmatter\":{\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"permalink\":\"/FE/cache\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"capture\":\"缓存会根据进来的请求保存输出内容的副本；当下一个请求来临的时候，如果是相同的 `URL`，缓存会根据缓存机制决定是直接使用副本响应请求还是向源服务器再次发送请求。比较常见的。\\n比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 `URL` 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。至于浏览器和网站服务器是如何标识网站页面是否更新的机制，将在后面介绍。\\n缓存可以减少网络带宽的消耗、减低服务器的压力、减少网络延迟，加快页面打开速度\\n这里主要记录浏览器缓存。\\n Memory Cache\\n`memory\"},{\"url\":\"/basic/issue.html\",\"relativePath\":\"/01.前端/03. 工作技巧/02.issue.html\",\"frontmatter\":{\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"permalink\":\"/basic/issue\",\"tags\":[\"基础\",\"工作\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"capture\":\"获取一个月有多少天\\n今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据\\n`new Date(year, month, date, hrs, min, sec)` ， `new Date` 可以接受这些参数创建一个时间对象\\n其中当我们把 `date` 设置为 `0` 的时候，可以直接通过 `getDate()` 获取到最后一天的日期然后得到我们要的最后一天\\n```js\\nnew Date(2019, 12, 0).getDate(); // 31\\nnew Date(2018, 2, 0).getDate(); // 28\\n// 根据这个我们可以得到一个方法\\nfunc\"},{\"url\":\"/tools/npm-cli.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-cli.html\",\"frontmatter\":{\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"permalink\":\"/tools/npm-cli\",\"tags\":[\"cli\",\"node\",\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"capture\":\"思考\\n要开发一个脚手架需要捋清楚，脚手架是如何工作的？拿 `vue-cli` 来说，`vue-cli` 是将项目的模板放在 git 上面，执行 cli 命令的时候，再根据用户的交互选择不同的模板，然后经过模板引擎渲染出来生成项目。这样做将模板与脚手架分离，可以各自维护。\\n那我们先准备两套项目，一套作为自己的脚手架项目，一个作为模板\\n回想在使用 `vue-cli` 的时候，我们直接执行 `vue create projetcName` 然后进行一些交互便可以生成一个项目，生成的项目会拿到我们与用户交互的时候一些配置，会改变我们想要改变的一些文件。那我们就需要做完自己的脚手架后需要生成一个可以直接\"},{\"url\":\"/tools/npm-init.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-init.html\",\"frontmatter\":{\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"permalink\":\"/tools/npm-init\",\"tags\":[\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"capture\":\"npm init\\n初始化一个项目的时候，我们会在控制台输入 `npm init` 执行该命令后终端会依次询问 `name, version, description` 等字段，最后会为你生成一个 `package.json` 文件\\n如果想偷懒省去一路回车，可以在命令后面加 `--yes` 或者 `-y` 参数，这样会快速生成一个 `package.json` 文件\\n```sh\\n  npm init -y\\n```\\n这样生成出来的 `package.json` 是默认的配置，如果想要改变其默认配置怎么办？\\n 修改 npm 配置\\n初始化 `package.json` 时的字段默认值是可以自己配置的，\"}],\"09\":[{\"url\":\"/service/redis.html\",\"relativePath\":\"/02.服务端/redis.html\",\"frontmatter\":{\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"permalink\":\"/service/redis\",\"tags\":[\"其他\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"capture\":\"安装\\n- 官网有 Linux 的详细教程，安装省略，记录一下基本配置以及基础用法\\n 简介\\n\\n- Redis 是 `ket-value` 数据库。效率快，但功能单一；\\n- 常用做集中式会话管理（部署了负载均衡的服务之后，可用作 redis 来存储 _session_，可保证 _session_ 不用换一个服务请求一次）\\n- 用作缓存服务器（Redis 读取特别快：SET 操作每秒钟 110000 次，GET 操作每秒钟 81000 次。）\\n 基本命令\\n```sh\\n   启动redis，window启动方式\\n  redis-server redis.window.conf\\n   Linux启动\\n \"}],\"08\":[{\"url\":\"/basic/mapbox.html\",\"relativePath\":\"/01.前端/03. 工作技巧/mapbox.html\",\"frontmatter\":{\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"permalink\":\"/basic/mapbox\",\"tags\":[\"可视化\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"capture\":\"底图渲染\\n- 初次渲染地图很简单，按照官网的配置\\n- 我们需要一个地图渲染容器，需要用到 mapbox-gl 库，有时候你可能需要准备一个开发者 token，那我们开始吧\\n- 首先我们实例化一个 Map 类，在 mapbox-gl 里面有个 Map 类，该类接受一个 options 配置对象作为初始化地图的条件\\n```js\\nimport mapboxgl from 'mapbox-gl';\\nconst options = {\\n  container: '底图容器',\\n  style: '您的底图json',\\n  // 经度越大越靠左，纬度越大越靠下\\n  center: [108.5, 38],\"},{\"url\":\"/service/proxy.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx-requisite.html\",\"frontmatter\":{\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"permalink\":\"/service/proxy\",\"tags\":[\"其他\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"capture\":\"反向代理与负载均衡\\n\\n&gt;\\n&gt; - 解决跨域\\n&gt; - 请求过滤\\n&gt; - 配置 gzip\\n&gt; - 负载均衡\\n&gt; - 静态资源服务器\\n 代理\\n&gt; &emsp;`代理` 是在服务器和客户端之间架设的一层服务器，代理将接受客户端的请求将它转发给服务器，然后将服务端的响应转发给客户端。不管正向代理还是反向代理，都是实现此功能。&lt;br/&gt; &gt; &emsp;说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。&lt;br/&gt; &gt; &emsp;举个例子：比如说生活中的专卖\"},{\"url\":\"/FE/website-render.html\",\"relativePath\":\"/01.前端/04. 浏览器/website-render.html\",\"frontmatter\":{\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"permalink\":\"/FE/website-render\",\"tags\":[\"基础\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"capture\":\"简单流程\\n\\n URL\\n- URL（_Uniform Resource Locator_），统一资源定位符，用于定位互联网上资源，俗称网址\\n- 一个基本的URL由以下几部分组成\\n  1. 协议部分（_protocol_）：常见的协议有 _http、https、ftp、file_，其中最常见的类型是 _http_，而 _https_ 则是进行加密的网络传输\\n  2. 域名部分（_domain_）：该 URL 的域名部分为 _www.aspxfans.com_。一个 URL 中，也可以使用 IP 地址作为域名使用，_www_ 也是 _http_ 的默认主机（_host_）\\n  3. 端口部分（_po\"}],\"07\":[{\"url\":\"/service/mysql.html\",\"relativePath\":\"/02.服务端/02.mysql.html\",\"frontmatter\":{\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"permalink\":\"/service/mysql\",\"tags\":[\"MySQL\"],\"categories\":[\"MySQL\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"capture\":\"数据库操作\\n\\n 基本操作\\n```sql\\n  -- 创建数据库\\n  CREATE database_name;\\n  -- 查看数据库信息\\n  SHOW CREATE DATABASE database_name;\\n  -- 设置为 utf-8 格式的\\n  SET names utf8;\\n  -- 查看数据库\\n  SHOW DATABASES;\\n  -- 使用数据库，use 数据库名\\n  USE database_name;\\n  -- 创建表\\n  CREATE TABLE table_name (\\n    id    int(10),\\n    name  varchar(20),\\n    age \"},{\"url\":\"/service/nginx.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx.html\",\"frontmatter\":{\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"permalink\":\"/service/nginx\",\"tags\":[\"Nginx\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"capture\":\"安装\\n- 安装就暂时略过了，记录一下配置\\n 常用命令\\n- 做了软链接或者配置了 nginx 的环境变量可以用以下语法，没有话就需要指定到 nginx 所在的目录\\n- nginx -s stop 停止 nginx\\n- nginx -s quit 退出 nginx\\n- nginx -s reload 重新加载配置（修改配置文件后）\\n- nginx -s reopen 重启 nginx\\n- nginx -v 查看版本\\n- nginx -t 查看配置文件目录，检测配置文件是否有语法错误，然后退出\\n nginx.conf 配置文件\\nNginx 配置文件主要分成四部分：main（全局设置）、server（\"}],\"06\":[{\"url\":\"/service/fs.html\",\"relativePath\":\"/02.服务端/node/fs.html\",\"frontmatter\":{\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/fs\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"文件操作\\n 读取文件\\n- fs 模块所有的都有同步和异步语法，异步语法直接写 api，同步写法就是 api 后紧跟 sync(同步)\\n- fs.readFile() 就是异步写法，那么同步写法就是 fs.readFilSync()\\n- 异步写法的返回值在回调函数中，同步写发直接就有返回值，这基本上也是 fs 所有模块的写法\\n```js\\nconst fs = require('fs');\\nconst path = require('path');\\nconst resolve = dir =&gt; path.join(__dirname, '..', dir);\\n// 异步写法\\nfs.readF\"},{\"url\":\"/service/process.html\",\"relativePath\":\"/02.服务端/node/process-undone.html\",\"frontmatter\":{\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/process\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"进程对象属性\\n| 属性       | 说明                                         |\\n|----------|--------------------------------------------|\\n| execPath | 可执行文件的绝对路径，如 `/usr/local/bin/node`         |\\n| version  | 版本号                                        |\\n| versions | 依赖库的版本号                                    |\\n| p\"},{\"url\":\"/tools/vue.html\",\"relativePath\":\"/03.工具/Webpack 相关/vue.html\",\"frontmatter\":{\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"permalink\":\"/tools/vue\",\"tags\":[\"webpack\",\"vue\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"capture\":\"从 0 开始搭建 vue 项目\\n&lt;!-- 第一行的东西会被作为标题来展示 --\\n`webpack` 打包部署 js 项目从以下几个方面考虑：\\n- js 的处理：转换 ES6 代码，解决浏览器兼容问题\\n- css 的处理：编译 css，自动添加前缀，抽取 css 到独立文件\\n- html 的处理：复制并压缩 html 文件\\n- dist 的清理：打包前清理源目录文件\\n- assets 的处理：静态资源处理\\n- server 的启用：development 模式下启动服务器并实时刷新\\n 一、项目结构\\n我们按照 vue-cli 的目录结构来新建一些目录，然后 webpack 做相应的配置，打开\"}],\"05\":[{\"url\":\"/tools/webpack-1.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-1.html\",\"frontmatter\":{\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"capture\":\"webpack 介绍\\nWebpack 可以直接执行 webpack 命令进行打包，也可以通过手动配置实现更复杂的打包需求。配置文件为 webpack.config.js，可以导出一个对象或函数，函数接受两个参数：env（环境对象）和 argv（描述传递给 webpack 选项的 map 对象）。\\n来看一下这两个参数：\\n```js\\n  // 在 webpack.config.js 中输入以下代码\\n  module.exports = function(env, argv) {\\n    console.log(env, argv)\\n  }\\n  // 在控制台执行\\n  webpack --env=c\"},{\"url\":\"/basic/js.html\",\"relativePath\":\"/01.前端/01. 基础/javascript.html\",\"frontmatter\":{\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"permalink\":\"/basic/js\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"capture\":\"类型转换\\n 一个有趣的问题\\n&lt;p align=\\\"center\\\" class=\\\"p-images\\\"\\n  &lt;img src=\\\"/imgs/basis-javascript-type-change.jpg\\\" height=\\\"260\\\" /&gt;\\n&lt;/p&gt;\\n&gt; 看到了这个我亲自尝试了下，结果发现自己对 js 基础越来越陌生了，现在好好复习下吧\\n```js\\n0 == '0'; // true\\n0 == []; // true\\n'0' == []; // false\\n```\\n 为什么？\\n&gt; 为什么 '0' == [] 是 false ？&lt;br&gt;\\n&gt; 为\"},{\"url\":\"/basic/css.html\",\"relativePath\":\"/01.前端/01. 基础/css.html\",\"frontmatter\":{\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"permalink\":\"/basic/css\",\"tags\":[\"css\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"capture\":\"css 加载会造成阻塞吗\\n\\n css 加载会造成 DOM 树的阻塞嘛？\\n- 首先，_css_ 加载会阻塞 _DOM_ 树渲染，但是 _css_ 并不会阻塞 _DOM_ 树的解析\\n- 也就是说，你可以在 _css_ 加载完之前可以在 _js_ 中获取到 _DOM_ 元素，但是 _DOM_ 却是没有渲染到页面上，需要等到 _css_ 加载完毕才渲染\\n- 为什么会这样？\\n  - 在你加载 _css_ 的时候，可能会修改 _DOM_ 节点的样式，如果 _css_ 加载不阻塞 _DOM_ 树渲染的话，那么当 _css_ 加载完之后， _DOM_ 树可有又得重绘或者回流了\\n  - 所以干脆先把 _DOM_\"}]}},\"groupPosts\":{\"categories\":{\"基础\":[{\"url\":\"/basic/modulo.html\",\"relativePath\":\"/01.前端/03. 工作技巧/01.modulo.html\",\"frontmatter\":{\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"permalink\":\"/basic/modulo\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"capture\":\"&gt; 最近面试被问到一个倒计时相关问题，又一次用到了取余（Modulo）。说实话，刚入行那会儿，总觉得这玩意儿不就是小学数学里的`求余数`\\n&gt; 吗？除了面试题里用来判断奇偶数，平时好像也没啥大用。\\n&gt;\\n&gt; 但随着代码写得越来越多，逐渐发现 `%` 符号背后其实隐藏着一种处理数据的思维模型——它能把无限延伸的线性世界，折叠成有限可控的\\n周期世界。今天想和大家分享一下我对取余的重新思考，看看它是怎么帮我们优雅地解决那些头疼的边界问题。\\n 重新认识 `%`\\n取余的本质，是将任意数值强行`限定`在一个固定的循环范围内。无论数字跑多远，`% N` 都能让它回归到 `0` 至 `N-\"},{\"url\":\"/basic/interview.html\",\"relativePath\":\"/01.前端/01. 基础/1. interview.html\",\"frontmatter\":{\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"permalink\":\"/basic/interview\",\"name\":\"面试题\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"capture\":\"1. 关于函数的 length 属性\\n360 面试过程遇到一个很有趣的问题，是关于函数的 length 属性的，题简写如下\\n```js\\n(() =\\n```\\n我所理解的拥有 `length` 的对象一般都是数组或者类数组对象，或者定义了 `length` 属性的对象，所以我回答说这个应该是 `false` 吧，后来面试告诉我函数是有 `length` 属性的，函数的 `length` 属性就是函数参数的个数，瞬间我恍然大悟，函数的参数就是 `arguments` ，而 `arguments` 也是一个类数组对象所以他是有 `length` 属性的\\n```js\\n// so\\n(() =&gt; 1)\"},{\"url\":\"/basic/array.html\",\"relativePath\":\"/01.前端/02. 代码实现/array.html\",\"frontmatter\":{\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"permalink\":\"/basic/array\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"capture\":\"在日常开发中，我们经常使用数组的 API。本文将详细介绍一些常用的数组操作方法，并提供其实现代码。\\n 任意位置插入单个成员\\n数组任意位置插入单个成员，这个 api 几乎可以作为数组插入的一个最基本的方法来处理，实现如下\\n按照数组 api 的规则，我们为数组增加了成员，那么要返回数组的长度\\n```js\\nfunction insert(arr, idx, item) {\\n  // 循环为什么要倒着写？看下面解释\\n  for (let i = arr.length - 1; i \\n    arr[i + 1] = arr[i];\\n  }\\n  arr[idx] = item;\\n  return arr\"},{\"url\":\"/basic/vue.html\",\"relativePath\":\"/01.前端/02. 代码实现/vue-undone.html\",\"frontmatter\":{\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/vue\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"vue\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"capture\":\"数据劫持\\n 对象的劫持\\n2.x 版本的数据劫持是根据 Object.defineProperty 来实现的\\n```js\\nfunction observe(data) {\\n  // 不是对象直接返回\\n  if (!(typeof data === 'object' && data !== null)) return;\\n  return observer(data);\\n}\\nfunction observer(data) {\\n  if (Array.isArray(data)) {\\n    observeArray(data);\\n  } else {\\n    observeObject(data);\"},{\"url\":\"/basic/promise.html\",\"relativePath\":\"/01.前端/02. 代码实现/promise.html\",\"frontmatter\":{\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/promise\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"capture\":\"`promise` 的出现改变了以前 js 的回调风格。`promise` 核心是三种状态，`pending、resolve、reject`，状态一旦从 `pending` 变成其他状态则不可逆，其他用法细节将在实现 `promise` 的过程中一步步记录\\n 简单版 promise\\n- 首先我们实现函数异步函数执行的问题\\n```js\\n// 首先是三种状态\\nconst PENDING = 'pending';\\nconst RESOLVED = 'resolve';\\nconst REJECTED = 'reject';\\nfunction Promise(execute) {\\n  this.stat\"},{\"url\":\"/tools/command.html\",\"relativePath\":\"/03.工具/Npm 相关/command.html\",\"frontmatter\":{\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"permalink\":\"/tools/command\",\"tags\":[\"cli\",\"基础\",\"node\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"capture\":\"命令行\\n不管在 windows 还是 Mac、Linux 系统都会有很多命令来提供一些便捷的操作，比如在 window 中 打开 cmd 输入 `start snippingtool` 就可以打开绘图工具，cmd 里面执行的其实就是一个以 .bat 执行脚本，你也可以直接新建一个文件，然后在文件内部写入 `start snippingtool`，然后保存为 .bat 结尾的文件即可直接双击执行这个文件。在 Mac 和 Linux 中可以直接写内容，不需要后缀名，以 .sh 结尾也可以，但是 Mac 和 Linux 默认新建的脚本是没有执行权限的，需要 执行 `chmod +x 文件名` 给文件\"},{\"url\":\"/FE/jwt.html\",\"relativePath\":\"/01.前端/04. 浏览器/jwt.html\",\"frontmatter\":{\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"permalink\":\"/FE/jwt\",\"tags\":[\"http\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"capture\":\"还有几分钟就要跨年了，2019 即将结束，跨年夜独自一人闲来无趣，整理一下 `cookie、token` 和 `jwt` 的，记得在学校的时候我就很奇怪 `cookie` 是什么，当时老师只对我们说他就是用来存储数据的，只能存储 `4kb`，超过 `4kb` 之后就会开始删除之前的 `cookie` 值，不同浏览器删除的行为是不一样的。然后就没了。直到后来参加工作了，刚入公司没多久一次接触到了 `cookie` 让我一脸懵逼（当时带我的大佬有事回家了），项目出了 bug 因为 `cookie` 传递的不对，后台解析不了，然后我折腾了一晚上（回想当初小白的时候是真的有趣）。\\n今天来记录下工作这么\"},{\"url\":\"/FE/cache.html\",\"relativePath\":\"/01.前端/04. 浏览器/cache.html\",\"frontmatter\":{\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"permalink\":\"/FE/cache\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"capture\":\"缓存会根据进来的请求保存输出内容的副本；当下一个请求来临的时候，如果是相同的 `URL`，缓存会根据缓存机制决定是直接使用副本响应请求还是向源服务器再次发送请求。比较常见的。\\n比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 `URL` 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。至于浏览器和网站服务器是如何标识网站页面是否更新的机制，将在后面介绍。\\n缓存可以减少网络带宽的消耗、减低服务器的压力、减少网络延迟，加快页面打开速度\\n这里主要记录浏览器缓存。\\n Memory Cache\\n`memory\"},{\"url\":\"/basic/issue.html\",\"relativePath\":\"/01.前端/03. 工作技巧/02.issue.html\",\"frontmatter\":{\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"permalink\":\"/basic/issue\",\"tags\":[\"基础\",\"工作\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"capture\":\"获取一个月有多少天\\n今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据\\n`new Date(year, month, date, hrs, min, sec)` ， `new Date` 可以接受这些参数创建一个时间对象\\n其中当我们把 `date` 设置为 `0` 的时候，可以直接通过 `getDate()` 获取到最后一天的日期然后得到我们要的最后一天\\n```js\\nnew Date(2019, 12, 0).getDate(); // 31\\nnew Date(2018, 2, 0).getDate(); // 28\\n// 根据这个我们可以得到一个方法\\nfunc\"},{\"url\":\"/basic/api.html\",\"relativePath\":\"/01.前端/02. 代码实现/api.html\",\"frontmatter\":{\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"permalink\":\"/basic/api\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"capture\":\"实现一个 new 操作符\\n&gt; 函数执行前面加个 `new` 做了哪些事情，为啥就会构造一个对象出来\\n- 创建了一个新对象\\n- 链接到了原型\\n- 执行函数，绑定了 this 指向新创建的对象上\\n- 返回一个对象，如果函数中有`return`关键字，看 return 了什么出来，如果是一个对象，那么返回这个对象，如果不是则返回我们新建的这个对象\\n- 实现过程如下：\\n```js\\nfunction New() {\\n  // 创建了一个新对象\\n  const obj = {};\\n  // 取得构造函数\\n  const F = [].shift.call(arguments);\\n  // 链接到了原\"},{\"url\":\"/basic/inherit.html\",\"relativePath\":\"/01.前端/01. 基础/inherit.html\",\"frontmatter\":{\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"permalink\":\"/basic/inherit\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"capture\":\"原型\\n 野史\\n&gt; 根据野史记载，Brendan Eich 用了一周的时间创造了今天的 JavaScript，当 Brendan Eich 在为 JavaScript 设计面向对象系统时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。而且 Brendan Eich 一开始就没有打算在 JavaScript 中加入类的概念，所以 JavaScript 是一门基于原型的语言。在原型编程的思想中，类并不是必须的，对象未必需要从类中创建而来，一个对象是通过另一个对象而得到的。\\n- 在曾探的《设计模式》中提到 JavaScript 中的原型继承会遵循以下这些原型编程的基本规则：\\n \"},{\"url\":\"/basic/js.html\",\"relativePath\":\"/01.前端/01. 基础/javascript.html\",\"frontmatter\":{\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"permalink\":\"/basic/js\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"capture\":\"类型转换\\n 一个有趣的问题\\n&lt;p align=\\\"center\\\" class=\\\"p-images\\\"\\n  &lt;img src=\\\"/imgs/basis-javascript-type-change.jpg\\\" height=\\\"260\\\" /&gt;\\n&lt;/p&gt;\\n&gt; 看到了这个我亲自尝试了下，结果发现自己对 js 基础越来越陌生了，现在好好复习下吧\\n```js\\n0 == '0'; // true\\n0 == []; // true\\n'0' == []; // false\\n```\\n 为什么？\\n&gt; 为什么 '0' == [] 是 false ？&lt;br&gt;\\n&gt; 为\"},{\"url\":\"/basic/css.html\",\"relativePath\":\"/01.前端/01. 基础/css.html\",\"frontmatter\":{\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"permalink\":\"/basic/css\",\"tags\":[\"css\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"capture\":\"css 加载会造成阻塞吗\\n\\n css 加载会造成 DOM 树的阻塞嘛？\\n- 首先，_css_ 加载会阻塞 _DOM_ 树渲染，但是 _css_ 并不会阻塞 _DOM_ 树的解析\\n- 也就是说，你可以在 _css_ 加载完之前可以在 _js_ 中获取到 _DOM_ 元素，但是 _DOM_ 却是没有渲染到页面上，需要等到 _css_ 加载完毕才渲染\\n- 为什么会这样？\\n  - 在你加载 _css_ 的时候，可能会修改 _DOM_ 节点的样式，如果 _css_ 加载不阻塞 _DOM_ 树渲染的话，那么当 _css_ 加载完之后， _DOM_ 树可有又得重绘或者回流了\\n  - 所以干脆先把 _DOM_\"}],\"经典\":[{\"url\":\"/scriptures/sutra.html\",\"relativePath\":\"/04.经典摘录/空性与妙用.html\",\"frontmatter\":{\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"permalink\":\"/scriptures/sutra\",\"tags\":[\"人生\"],\"categories\":[\"经典\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"capture\":\"金刚经的那句话\\n\\n&gt;\\n&gt; 虚妄不是说不存在，而是说太唯心。\\n---\\n&gt; 举个例子：  \\n&gt; 你面前有一个杯子——\\n&gt; - 你喝水，它就是 水杯；\\n&gt; - 你抽烟，它就是 烟灰缸；\\n&gt; - 你插花，它就是 花瓶；\\n&gt; - 你插笔，它就是 笔筒；\\n&gt; - 你愤怒时，它就是 一地的玻璃渣。\\n---\\n&gt; 杯子本身，其实它什么也不是，这叫 空性。\\n&gt;\\n&gt; 你用它来干什么，它就是什么，这叫 妙用。\\n&gt;\\n&gt; 你非要坚持，它一定就是杯子，这叫 住相。\\n&gt;\\n&gt; 为此，你不惜和别人争论抬杠，这叫 我执。\\n&gt;\\n&g\"}],\"前端\":[{\"url\":\"/basic/vite-plugin-unique-page-chunks.html\",\"relativePath\":\"/01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.html\",\"frontmatter\":{\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"permalink\":\"/basic/vite-plugin-unique-page-chunks\",\"tags\":[\"插件\",\"Vite\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"capture\":\"问题背景\\n在某项目初上线优化代码的时候，打包后看到了类似的结果\\n```txt\\ndist/assets/index-CMe6Kk4E.js       0.63 kB │ gzip:   0.38 kB\\ndist/assets/index-DbyJIfZt.js     104.19 kB │ gzip:  40.96 kB\\ndist/assets/index-BN6vN86v.js     874.79 kB │ gzip: 282.58 kB\\ndist/assets/index-zD3tofSk.js   1,128.82 kB │ gzip: 375.52 kB\\n```\\n这些文件的名称几乎\"},{\"url\":\"/tools/eslint.html\",\"relativePath\":\"/03.工具/Webpack 相关/lint.html\",\"frontmatter\":{\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/tools/eslint\",\"tags\":[\"eslint\",\"node\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"capture\":\"简介\\n本项目使用 express 脚手架初始化，并对其进行改造，从而实现一套完整的 eslint 工作流的 node 项目。本项目将全程使用 `pnpm` 作为包管理工具\\n本文将从以下几个方面过一遍 eslint 工作流\\n&lt;!--  --\\n&lt;p align=\\\"center\\\"&gt;\\n  &lt;img src=\\\"/imgs/eslint-process.svg\\\"/&gt;\\n&lt;/p&gt;\\n 初始化项目\\n```sh\\nnpx express-generator --view=pug express-template\\n```\\n也可以下全局下载 `express-generator`\"},{\"url\":\"/basic/getport.html\",\"relativePath\":\"/01.前端/03. 工作技巧/getport.html\",\"frontmatter\":{\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"permalink\":\"/basic/getport\",\"tags\":[\"webpack\",\"node\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"capture\":\"一个问题\\n前段时间，公司项目改版登录，所有管理后台、大屏可视化或者说电脑 web 端的登录做成了一个模块统一授权登录，登录的域名是配置出来的，等他们联调完之后，我发现我本地项目跑起来后登录不了啦，找相关开发人员了解情况后才知道后端限制了 `localhost` 的访问(就离谱)\\n他们推荐前端开发人员本地安装 nginx，配置本机 hosts，用 nginx 做跳转，后端可访问域名白名单中添加有我们 hosts 中配置的域名\\n我是习惯了项目跑完后点击项目启动完成后的提示信息跳转页面进行开发(主要我不想本地配 nginx)，继续与他们交谈我了解到后端允许 127.0.0.1 进行接口访问，只需要在\"},{\"url\":\"/FE/ast.html\",\"relativePath\":\"/01.前端/04. 浏览器/AST.html\",\"frontmatter\":{\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/FE/ast\",\"tags\":[\"ast\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"capture\":\"&lt;!--  背景 --\\n 什么是 AST\\n抽象语法树（`Abstract Syntax Tree`）简称 `AST`，是源代码的抽象语法结构的树状表现形式。`webpack`、`eslint` 等很多工具库的核心都是通过抽象语法书这个概念来实现对代码的检查、分析等操作。今天我为大家分享一下 JavaScript 这类解释型语言的抽象语法树的概念\\n我们常用的浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作。所以将 js 转化为抽象语法树更利于程序的分析。\\n&lt;!-- ast --&gt;\\n&lt;p align=\\\"left\\\" class=\\\"p-images\\\"&g\"},{\"url\":\"/basic/mapbox.html\",\"relativePath\":\"/01.前端/03. 工作技巧/mapbox.html\",\"frontmatter\":{\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"permalink\":\"/basic/mapbox\",\"tags\":[\"可视化\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"capture\":\"底图渲染\\n- 初次渲染地图很简单，按照官网的配置\\n- 我们需要一个地图渲染容器，需要用到 mapbox-gl 库，有时候你可能需要准备一个开发者 token，那我们开始吧\\n- 首先我们实例化一个 Map 类，在 mapbox-gl 里面有个 Map 类，该类接受一个 options 配置对象作为初始化地图的条件\\n```js\\nimport mapboxgl from 'mapbox-gl';\\nconst options = {\\n  container: '底图容器',\\n  style: '您的底图json',\\n  // 经度越大越靠左，纬度越大越靠下\\n  center: [108.5, 38],\"},{\"url\":\"/FE/website-render.html\",\"relativePath\":\"/01.前端/04. 浏览器/website-render.html\",\"frontmatter\":{\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"permalink\":\"/FE/website-render\",\"tags\":[\"基础\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"capture\":\"简单流程\\n\\n URL\\n- URL（_Uniform Resource Locator_），统一资源定位符，用于定位互联网上资源，俗称网址\\n- 一个基本的URL由以下几部分组成\\n  1. 协议部分（_protocol_）：常见的协议有 _http、https、ftp、file_，其中最常见的类型是 _http_，而 _https_ 则是进行加密的网络传输\\n  2. 域名部分（_domain_）：该 URL 的域名部分为 _www.aspxfans.com_。一个 URL 中，也可以使用 IP 地址作为域名使用，_www_ 也是 _http_ 的默认主机（_host_）\\n  3. 端口部分（_po\"},{\"url\":\"/tools/vue.html\",\"relativePath\":\"/03.工具/Webpack 相关/vue.html\",\"frontmatter\":{\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"permalink\":\"/tools/vue\",\"tags\":[\"webpack\",\"vue\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"capture\":\"从 0 开始搭建 vue 项目\\n&lt;!-- 第一行的东西会被作为标题来展示 --\\n`webpack` 打包部署 js 项目从以下几个方面考虑：\\n- js 的处理：转换 ES6 代码，解决浏览器兼容问题\\n- css 的处理：编译 css，自动添加前缀，抽取 css 到独立文件\\n- html 的处理：复制并压缩 html 文件\\n- dist 的清理：打包前清理源目录文件\\n- assets 的处理：静态资源处理\\n- server 的启用：development 模式下启动服务器并实时刷新\\n 一、项目结构\\n我们按照 vue-cli 的目录结构来新建一些目录，然后 webpack 做相应的配置，打开\"}],\"Git\":[{\"url\":\"/git/git-2.html\",\"relativePath\":\"/03.工具/Git 相关/git-2.html\",\"frontmatter\":{\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"permalink\":\"/git/git-2\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"capture\":\"前言\\n在第一篇中，我们掌握了 Git 的基础操作和核心概念。现在让我们继续深入，探索 Git 的高级特性和实战技巧。\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-2.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n 源的管理\\n```shell\\n 查看源仓库信息\\ngit remote -v\\n 修改源仓库信息\\ngit remote set-url &lt;origin_name&gt; &lt;url&gt;\\n 添加源仓库\\ngit remote add &lt;origin_name&gt; &lt;url&gt;\\n 删除源\"},{\"url\":\"/git/git-1.html\",\"relativePath\":\"/03.工具/Git 相关/git-1.html\",\"frontmatter\":{\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"permalink\":\"/git/git-1\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"capture\":\"前言\\nGit 是目前广泛使用的分布式版本控制系统，在日常开发中经常会用到。\\n这篇文章记录了一些 Git 的基础知识和常用操作，希望能对大家有所帮助\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-1.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n Git 简介\\nGit 是一个 分布式版本控制系统，最初由 Linux 之父 Linus Torvalds 编写。它可以帮助我们跟踪代码的修改历史、多人协作开发，并在出问题时迅速回滚。\\n&gt; ✅ Git vs SVN：Git 是分布式的，每个开发者都有完整历史记录；\"},{\"url\":\"/git/git-submodules.html\",\"relativePath\":\"/03.工具/Git 相关/git-submodules.html\",\"frontmatter\":{\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"permalink\":\"/git/git-submodules\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"capture\":\"项目背景\\n因公司项目要拆成多个模块，部分模块给分公司的小伙伴开发权限一起开发，所以最终决定使用 git 子模块来拆分项目，今天来复盘下项目拆分中爬过的一些坑。有兴趣的同学可以参考源码一起阅读，附源码。\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git-submodules.svg\\\"/&gt;\\n&lt;/p&gt;\\n 子模块\\n首先来科普一下 git 子模块\\n子模块允许你将一个 git 仓库作为另一个 git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。\\n官方中举了一个例子：某个工作中的项目需要包含并使用另一个\"}],\"算法\":[{\"url\":\"/basic/tree.html\",\"relativePath\":\"/01.前端/03. 工作技巧/tree.html\",\"frontmatter\":{\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"permalink\":\"/basic/tree\",\"tags\":[\"工作\",\"算法\"],\"categories\":[\"算法\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"capture\":\"前言\\n在工作中我们经常见到用树的场景，比如说写前端页面时，每个页面就有对应的 DOM 树、CSSOM 树、渲染树等，或者开发过程中的写的级联选择器、菜单树、权限树、人员树等\\n面试的时候会被问到算法相关的知识，而刷树相关的题，是特别培养算法思维的，回溯、动规、分治算法其实都是树的问题\\n本文将汇总一些工作中常用的一些树的操作以及面试可能会问到二叉树相关的问题\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/tree.svg\\\"/&gt;\\n&lt;/p&gt;\\n 树（工作）\\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个\"}],\"views\":[{\"url\":\"/pages/9492f1.html\",\"relativePath\":\"/views/plugins/chrome.html\",\"frontmatter\":{\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"tags\":[\"插件\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/9492f1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"\"},{\"url\":\"/pages/118849.html\",\"relativePath\":\"/views/plugins/vscode.html\",\"frontmatter\":{\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"插件\"],\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/118849\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"vscode 插件可以做什么\\nvscode 编辑器是可以高度自定义的，使用 vscode 插件几乎可以对 vscode 编辑器进行说有形式的自定义。\\nvscode 插件开发文档，中文文档\\nvscode 插件可以实现自定义指令、快捷键、自定义菜单项、自定义跳转、自动补全、悬浮提示、新增语言支持、语法检查、语法高亮、代码格式化等\\n 如何创建插件\\n我们使用官方来生成 vscode 插件模板项目\\n```sh\\n 安装 yo 和 generator-code\\nnpm install -g yo generator-code\\n 使用脚手架创建项目\\nyo code\\n```\\n yo 介绍\\nYeoman 是一个通\"}],\"plugins\":[{\"url\":\"/pages/9492f1.html\",\"relativePath\":\"/views/plugins/chrome.html\",\"frontmatter\":{\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"tags\":[\"插件\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/9492f1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"\"},{\"url\":\"/pages/118849.html\",\"relativePath\":\"/views/plugins/vscode.html\",\"frontmatter\":{\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"插件\"],\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/118849\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"vscode 插件可以做什么\\nvscode 编辑器是可以高度自定义的，使用 vscode 插件几乎可以对 vscode 编辑器进行说有形式的自定义。\\nvscode 插件开发文档，中文文档\\nvscode 插件可以实现自定义指令、快捷键、自定义菜单项、自定义跳转、自动补全、悬浮提示、新增语言支持、语法检查、语法高亮、代码格式化等\\n 如何创建插件\\n我们使用官方来生成 vscode 插件模板项目\\n```sh\\n 安装 yo 和 generator-code\\nnpm install -g yo generator-code\\n 使用脚手架创建项目\\nyo code\\n```\\n yo 介绍\\nYeoman 是一个通\"}],\"Webpack\":[{\"url\":\"/tools/webpack-3.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-3.html\",\"frontmatter\":{\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-3\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"capture\":\"介绍\\n接前两篇，这篇文章介绍一些使用 Webpack 的小技巧，以及在实际业务场景中如何自定义 Loader 和 Plugin。由于最近工作比较忙，这篇笔记写得断断续续，可能有些杂乱，后续会不断优化。\\n 小技巧：require.context\\n在开发项目时，如果需要引入很多文件，可以使用 require.context 函数创建一个文件引入的上下文。该函数接受三个参数：要搜索的目录、是否搜索子目录、匹配文件的正则表达式。\\n```js\\n// 语法如下\\nrequire.context(directory, (useSubdirectories = false), (regExp = /^\\\\.\\\\//\"},{\"url\":\"/tools/webpack-2.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-2.html\",\"frontmatter\":{\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"tagsPage\":true,\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-2\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 进阶篇\",\"date\":\"2020-03-08 08:00:00\",\"capture\":\"安装\\n- 推荐本地安装，不推荐全局安装\\n- 安装本地 Webpack：npm i webpack webpack-cli -D\\n webpack 可以进行 0 配置\\n- 不需要配置任何东西，直接执行 webpack 就可以打包我们的代码\\n- 打包工具 -\\n- 打包（支持 js 模块化）\\n 手动配置 webpack\\n- 默认配置文件是 webpack.config.js\\n- 但是如果你不想使用这个文件也是可以的，可以使用 `--config webpack.other.js` 来让 webpack 使用其他的配置文件\\n 传参\\n- 如果需要在命令行后面传参，需要使用 `--`\\n```sh\\nnpm \"},{\"url\":\"/tools/webpack-1.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-1.html\",\"frontmatter\":{\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"capture\":\"webpack 介绍\\nWebpack 可以直接执行 webpack 命令进行打包，也可以通过手动配置实现更复杂的打包需求。配置文件为 webpack.config.js，可以导出一个对象或函数，函数接受两个参数：env（环境对象）和 argv（描述传递给 webpack 选项的 map 对象）。\\n来看一下这两个参数：\\n```js\\n  // 在 webpack.config.js 中输入以下代码\\n  module.exports = function(env, argv) {\\n    console.log(env, argv)\\n  }\\n  // 在控制台执行\\n  webpack --env=c\"}],\"http\":[{\"url\":\"/service/https.html\",\"relativePath\":\"/02.服务端/https-undone.html\",\"frontmatter\":{\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"permalink\":\"/service/https\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"capture\":\"https\\n参照老左笔记进行实践\\n 准备东西\\n首先准备一台空的服务器\\n 安装的东西\\n- 安装 git、nginx\\n```sh\\nyum install git\\nyum install nginx\\n```\\n 快速获取 Let's Encrypt 免费 SSL 证书\\n执行以下脚本，域名换成自己的域名，邮箱换成自己的邮箱，然后一路同意\\n注意：执行脚本的时候一定要停掉 nginx，否则会出错\\n```sh\\ngit clone https://github.com/letsencrypt/letsencrypt\\ncd letsencrypt\\n./letsencrypt-auto certonly --sta\"},{\"url\":\"/service/http.html\",\"relativePath\":\"/02.服务端/http-undone.html\",\"frontmatter\":{\"title\":\"HTTP 笔记\",\"name\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"permalink\":\"/service/http\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"capture\":\"头部\\n 通用头\\n| 首部字段名        | 说明                       |\\n| ----------------- | -------------------------- |\\n| Cache-Control     | 控制缓存行为               |\\n| Connection        | 链接的管理                 |\\n| Date              | 报文日期                   |\\n| Pragma            | 报文指令                   |\\n| Trailer   \"}],\"node\":[{\"url\":\"/service/crypto.html\",\"relativePath\":\"/02.服务端/node/crypto.html\",\"frontmatter\":{\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"permalink\":\"/service/crypto\",\"tags\":[\"其他\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"capture\":\"crypto\\ncrypto 是 node 中实现加密解密的模块，使用 OpenSSL 类库作为内部实现加密解密的手段\\n 散列(哈希)算法\\n散列算法也叫哈希算法，用来把任意长度的输入换成固定长度的输出，常见的有 md5、sha1、sha256 等\\n散列算法好很多中，在 node 中可以使用 `crypto.getHashes()` 获取到 node 所支持的所有 hash 类型\\n 特点\\n- 相同的输入会产生相同的输出\\n- 不同的输出会产生不同的输出\\n- 任意的输入长度输出长度都是相同的\\n- 不能从输出推算输出的值（不能反解）\\n 用途\\n- 用来校验要下载的文件是否被改的\\n- 用来对数据库中保存的密\"},{\"url\":\"/service/fs.html\",\"relativePath\":\"/02.服务端/node/fs.html\",\"frontmatter\":{\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/fs\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"文件操作\\n 读取文件\\n- fs 模块所有的都有同步和异步语法，异步语法直接写 api，同步写法就是 api 后紧跟 sync(同步)\\n- fs.readFile() 就是异步写法，那么同步写法就是 fs.readFilSync()\\n- 异步写法的返回值在回调函数中，同步写发直接就有返回值，这基本上也是 fs 所有模块的写法\\n```js\\nconst fs = require('fs');\\nconst path = require('path');\\nconst resolve = dir =&gt; path.join(__dirname, '..', dir);\\n// 异步写法\\nfs.readF\"},{\"url\":\"/service/process.html\",\"relativePath\":\"/02.服务端/node/process-undone.html\",\"frontmatter\":{\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/process\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"进程对象属性\\n| 属性       | 说明                                         |\\n|----------|--------------------------------------------|\\n| execPath | 可执行文件的绝对路径，如 `/usr/local/bin/node`         |\\n| version  | 版本号                                        |\\n| versions | 依赖库的版本号                                    |\\n| p\"}],\"Linux\":[{\"url\":\"/service/linux.html\",\"relativePath\":\"/02.服务端/01.linux.html\",\"frontmatter\":{\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"permalink\":\"/service/linux\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"capture\":\"这篇文章涵盖了Linux系统中常见目录、文件管理、搜索、压缩解压等内容。我对其进行了语言优化和排版调整，以提高可读性和流畅性。\\n 常见目录\\n在 `Linux` 中一切皆文件\\n| 目录      | 作用                                                                                 |\\n| --------- | ------------------------------------------------------------------------------------ |\\n| /         | 根\"},{\"url\":\"/service/vmware.html\",\"relativePath\":\"/02.服务端/vmware-undone.html\",\"frontmatter\":{\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"permalink\":\"/service/vmware\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"],\"private\":true,\"privateRealm\":\"common\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"capture\":\"&lt;!-- 虽然都 0202 年了，现在都不流行装系统了，但是作为一个开发，经常与电脑打交道还是需要会装系统的。曾几何时，我们用 xp 系统的时候安装 --\\n 系统启动\\n计算机通电后，第一件事情就是读取输入 ROM 芯片的开机程序，这个程序叫做基本输入输出系统 `BIOS`（Basic Input/Output System）\\n`BIOS` 程序首先检查计算机硬件是否满足运行的基本条件，这个叫做硬件自检（Power-On Self-Test）\\n如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止，如果没有问题，屏幕会显示出 CPU、内存、硬盘等信息\\n硬件自检完成后，BIOS 会把控制权交给\"}],\"npm\":[{\"url\":\"/tools/npm-cli.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-cli.html\",\"frontmatter\":{\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"permalink\":\"/tools/npm-cli\",\"tags\":[\"cli\",\"node\",\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"capture\":\"思考\\n要开发一个脚手架需要捋清楚，脚手架是如何工作的？拿 `vue-cli` 来说，`vue-cli` 是将项目的模板放在 git 上面，执行 cli 命令的时候，再根据用户的交互选择不同的模板，然后经过模板引擎渲染出来生成项目。这样做将模板与脚手架分离，可以各自维护。\\n那我们先准备两套项目，一套作为自己的脚手架项目，一个作为模板\\n回想在使用 `vue-cli` 的时候，我们直接执行 `vue create projetcName` 然后进行一些交互便可以生成一个项目，生成的项目会拿到我们与用户交互的时候一些配置，会改变我们想要改变的一些文件。那我们就需要做完自己的脚手架后需要生成一个可以直接\"},{\"url\":\"/tools/npm-init.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-init.html\",\"frontmatter\":{\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"permalink\":\"/tools/npm-init\",\"tags\":[\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"capture\":\"npm init\\n初始化一个项目的时候，我们会在控制台输入 `npm init` 执行该命令后终端会依次询问 `name, version, description` 等字段，最后会为你生成一个 `package.json` 文件\\n如果想偷懒省去一路回车，可以在命令后面加 `--yes` 或者 `-y` 参数，这样会快速生成一个 `package.json` 文件\\n```sh\\n  npm init -y\\n```\\n这样生成出来的 `package.json` 是默认的配置，如果想要改变其默认配置怎么办？\\n 修改 npm 配置\\n初始化 `package.json` 时的字段默认值是可以自己配置的，\"}],\"Service\":[{\"url\":\"/service/conf.html\",\"relativePath\":\"/02.服务端/service-conf.html\",\"frontmatter\":{\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"permalink\":\"/service/conf\",\"tags\":[\"Linux\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"capture\":\"安装 nginx\\n&gt; 买了服务器，肯定先到控制台把服务器激活，然后重置登录密码，启动服务，然后怎么访问呢，那就先装个服务器呗，我选了 `nginx`，`nginx` 做内网转发还是挺不错的，现在也特别火，毕竟是轻量级的服务器。`nginx` 有什么好处我就不多说了，可以看看这篇文章讲解的很不错了\\n 安装前检查\\n- 安装 `nginx` 有两种方法，一种是源码包安装一种是 `yum` 安装，`yum` 安装可能不是最新版本的，这里我们选择了`源码包`安装\\n- 首先由于 `nginx` 的一些模块依赖一些 `lib` 库，所以在安装 `nginx` 之前，必须先安装这些 `lib` 库，这些\"},{\"url\":\"/service/redis.html\",\"relativePath\":\"/02.服务端/redis.html\",\"frontmatter\":{\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"permalink\":\"/service/redis\",\"tags\":[\"其他\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"capture\":\"安装\\n- 官网有 Linux 的详细教程，安装省略，记录一下基本配置以及基础用法\\n 简介\\n\\n- Redis 是 `ket-value` 数据库。效率快，但功能单一；\\n- 常用做集中式会话管理（部署了负载均衡的服务之后，可用作 redis 来存储 _session_，可保证 _session_ 不用换一个服务请求一次）\\n- 用作缓存服务器（Redis 读取特别快：SET 操作每秒钟 110000 次，GET 操作每秒钟 81000 次。）\\n 基本命令\\n```sh\\n   启动redis，window启动方式\\n  redis-server redis.window.conf\\n   Linux启动\\n \"}],\"Nginx\":[{\"url\":\"/service/proxy.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx-requisite.html\",\"frontmatter\":{\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"permalink\":\"/service/proxy\",\"tags\":[\"其他\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"capture\":\"反向代理与负载均衡\\n\\n&gt;\\n&gt; - 解决跨域\\n&gt; - 请求过滤\\n&gt; - 配置 gzip\\n&gt; - 负载均衡\\n&gt; - 静态资源服务器\\n 代理\\n&gt; &emsp;`代理` 是在服务器和客户端之间架设的一层服务器，代理将接受客户端的请求将它转发给服务器，然后将服务端的响应转发给客户端。不管正向代理还是反向代理，都是实现此功能。&lt;br/&gt; &gt; &emsp;说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。&lt;br/&gt; &gt; &emsp;举个例子：比如说生活中的专卖\"},{\"url\":\"/service/nginx.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx.html\",\"frontmatter\":{\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"permalink\":\"/service/nginx\",\"tags\":[\"Nginx\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"capture\":\"安装\\n- 安装就暂时略过了，记录一下配置\\n 常用命令\\n- 做了软链接或者配置了 nginx 的环境变量可以用以下语法，没有话就需要指定到 nginx 所在的目录\\n- nginx -s stop 停止 nginx\\n- nginx -s quit 退出 nginx\\n- nginx -s reload 重新加载配置（修改配置文件后）\\n- nginx -s reopen 重启 nginx\\n- nginx -v 查看版本\\n- nginx -t 查看配置文件目录，检测配置文件是否有语法错误，然后退出\\n nginx.conf 配置文件\\nNginx 配置文件主要分成四部分：main（全局设置）、server（\"}],\"MySQL\":[{\"url\":\"/service/mysql.html\",\"relativePath\":\"/02.服务端/02.mysql.html\",\"frontmatter\":{\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"permalink\":\"/service/mysql\",\"tags\":[\"MySQL\"],\"categories\":[\"MySQL\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"capture\":\"数据库操作\\n\\n 基本操作\\n```sql\\n  -- 创建数据库\\n  CREATE database_name;\\n  -- 查看数据库信息\\n  SHOW CREATE DATABASE database_name;\\n  -- 设置为 utf-8 格式的\\n  SET names utf8;\\n  -- 查看数据库\\n  SHOW DATABASES;\\n  -- 使用数据库，use 数据库名\\n  USE database_name;\\n  -- 创建表\\n  CREATE TABLE table_name (\\n    id    int(10),\\n    name  varchar(20),\\n    age \"}]},\"tags\":{\"基础\":[{\"url\":\"/basic/modulo.html\",\"relativePath\":\"/01.前端/03. 工作技巧/01.modulo.html\",\"frontmatter\":{\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"permalink\":\"/basic/modulo\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"聊聊编程里的“魔法棒”：取余运算（Modulo）\",\"date\":\"2026-02-11 00:00:00\",\"capture\":\"&gt; 最近面试被问到一个倒计时相关问题，又一次用到了取余（Modulo）。说实话，刚入行那会儿，总觉得这玩意儿不就是小学数学里的`求余数`\\n&gt; 吗？除了面试题里用来判断奇偶数，平时好像也没啥大用。\\n&gt;\\n&gt; 但随着代码写得越来越多，逐渐发现 `%` 符号背后其实隐藏着一种处理数据的思维模型——它能把无限延伸的线性世界，折叠成有限可控的\\n周期世界。今天想和大家分享一下我对取余的重新思考，看看它是怎么帮我们优雅地解决那些头疼的边界问题。\\n 重新认识 `%`\\n取余的本质，是将任意数值强行`限定`在一个固定的循环范围内。无论数字跑多远，`% N` 都能让它回归到 `0` 至 `N-\"},{\"url\":\"/basic/interview.html\",\"relativePath\":\"/01.前端/01. 基础/1. interview.html\",\"frontmatter\":{\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"permalink\":\"/basic/interview\",\"name\":\"面试题\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"面试题收录\",\"date\":\"2021-08-04 00:00:00\",\"capture\":\"1. 关于函数的 length 属性\\n360 面试过程遇到一个很有趣的问题，是关于函数的 length 属性的，题简写如下\\n```js\\n(() =\\n```\\n我所理解的拥有 `length` 的对象一般都是数组或者类数组对象，或者定义了 `length` 属性的对象，所以我回答说这个应该是 `false` 吧，后来面试告诉我函数是有 `length` 属性的，函数的 `length` 属性就是函数参数的个数，瞬间我恍然大悟，函数的参数就是 `arguments` ，而 `arguments` 也是一个类数组对象所以他是有 `length` 属性的\\n```js\\n// so\\n(() =&gt; 1)\"},{\"url\":\"/basic/array.html\",\"relativePath\":\"/01.前端/02. 代码实现/array.html\",\"frontmatter\":{\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"permalink\":\"/basic/array\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"数组 api 实现\",\"date\":\"2021-05-21 00:00:00\",\"capture\":\"在日常开发中，我们经常使用数组的 API。本文将详细介绍一些常用的数组操作方法，并提供其实现代码。\\n 任意位置插入单个成员\\n数组任意位置插入单个成员，这个 api 几乎可以作为数组插入的一个最基本的方法来处理，实现如下\\n按照数组 api 的规则，我们为数组增加了成员，那么要返回数组的长度\\n```js\\nfunction insert(arr, idx, item) {\\n  // 循环为什么要倒着写？看下面解释\\n  for (let i = arr.length - 1; i \\n    arr[i + 1] = arr[i];\\n  }\\n  arr[idx] = item;\\n  return arr\"},{\"url\":\"/basic/promise.html\",\"relativePath\":\"/01.前端/02. 代码实现/promise.html\",\"frontmatter\":{\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/promise\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"实现一个 Promise\",\"date\":\"2020-03-22 00:00:00\",\"capture\":\"`promise` 的出现改变了以前 js 的回调风格。`promise` 核心是三种状态，`pending、resolve、reject`，状态一旦从 `pending` 变成其他状态则不可逆，其他用法细节将在实现 `promise` 的过程中一步步记录\\n 简单版 promise\\n- 首先我们实现函数异步函数执行的问题\\n```js\\n// 首先是三种状态\\nconst PENDING = 'pending';\\nconst RESOLVED = 'resolve';\\nconst REJECTED = 'reject';\\nfunction Promise(execute) {\\n  this.stat\"},{\"url\":\"/tools/command.html\",\"relativePath\":\"/03.工具/Npm 相关/command.html\",\"frontmatter\":{\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"permalink\":\"/tools/command\",\"tags\":[\"cli\",\"基础\",\"node\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"capture\":\"命令行\\n不管在 windows 还是 Mac、Linux 系统都会有很多命令来提供一些便捷的操作，比如在 window 中 打开 cmd 输入 `start snippingtool` 就可以打开绘图工具，cmd 里面执行的其实就是一个以 .bat 执行脚本，你也可以直接新建一个文件，然后在文件内部写入 `start snippingtool`，然后保存为 .bat 结尾的文件即可直接双击执行这个文件。在 Mac 和 Linux 中可以直接写内容，不需要后缀名，以 .sh 结尾也可以，但是 Mac 和 Linux 默认新建的脚本是没有执行权限的，需要 执行 `chmod +x 文件名` 给文件\"},{\"url\":\"/FE/jwt.html\",\"relativePath\":\"/01.前端/04. 浏览器/jwt.html\",\"frontmatter\":{\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"permalink\":\"/FE/jwt\",\"tags\":[\"http\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"capture\":\"还有几分钟就要跨年了，2019 即将结束，跨年夜独自一人闲来无趣，整理一下 `cookie、token` 和 `jwt` 的，记得在学校的时候我就很奇怪 `cookie` 是什么，当时老师只对我们说他就是用来存储数据的，只能存储 `4kb`，超过 `4kb` 之后就会开始删除之前的 `cookie` 值，不同浏览器删除的行为是不一样的。然后就没了。直到后来参加工作了，刚入公司没多久一次接触到了 `cookie` 让我一脸懵逼（当时带我的大佬有事回家了），项目出了 bug 因为 `cookie` 传递的不对，后台解析不了，然后我折腾了一晚上（回想当初小白的时候是真的有趣）。\\n今天来记录下工作这么\"},{\"url\":\"/FE/cache.html\",\"relativePath\":\"/01.前端/04. 浏览器/cache.html\",\"frontmatter\":{\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"permalink\":\"/FE/cache\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器缓存\",\"date\":\"2019-12-22 00:00:00\",\"capture\":\"缓存会根据进来的请求保存输出内容的副本；当下一个请求来临的时候，如果是相同的 `URL`，缓存会根据缓存机制决定是直接使用副本响应请求还是向源服务器再次发送请求。比较常见的。\\n比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 `URL` 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。至于浏览器和网站服务器是如何标识网站页面是否更新的机制，将在后面介绍。\\n缓存可以减少网络带宽的消耗、减低服务器的压力、减少网络延迟，加快页面打开速度\\n这里主要记录浏览器缓存。\\n Memory Cache\\n`memory\"},{\"url\":\"/basic/issue.html\",\"relativePath\":\"/01.前端/03. 工作技巧/02.issue.html\",\"frontmatter\":{\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"permalink\":\"/basic/issue\",\"tags\":[\"基础\",\"工作\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"capture\":\"获取一个月有多少天\\n今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据\\n`new Date(year, month, date, hrs, min, sec)` ， `new Date` 可以接受这些参数创建一个时间对象\\n其中当我们把 `date` 设置为 `0` 的时候，可以直接通过 `getDate()` 获取到最后一天的日期然后得到我们要的最后一天\\n```js\\nnew Date(2019, 12, 0).getDate(); // 31\\nnew Date(2018, 2, 0).getDate(); // 28\\n// 根据这个我们可以得到一个方法\\nfunc\"},{\"url\":\"/basic/api.html\",\"relativePath\":\"/01.前端/02. 代码实现/api.html\",\"frontmatter\":{\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"permalink\":\"/basic/api\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常用 api 的实现\",\"date\":\"2019-10-27 00:00:00\",\"capture\":\"实现一个 new 操作符\\n&gt; 函数执行前面加个 `new` 做了哪些事情，为啥就会构造一个对象出来\\n- 创建了一个新对象\\n- 链接到了原型\\n- 执行函数，绑定了 this 指向新创建的对象上\\n- 返回一个对象，如果函数中有`return`关键字，看 return 了什么出来，如果是一个对象，那么返回这个对象，如果不是则返回我们新建的这个对象\\n- 实现过程如下：\\n```js\\nfunction New() {\\n  // 创建了一个新对象\\n  const obj = {};\\n  // 取得构造函数\\n  const F = [].shift.call(arguments);\\n  // 链接到了原\"},{\"url\":\"/basic/inherit.html\",\"relativePath\":\"/01.前端/01. 基础/inherit.html\",\"frontmatter\":{\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"permalink\":\"/basic/inherit\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 继承\",\"date\":\"2019-10-16 00:00:00\",\"capture\":\"原型\\n 野史\\n&gt; 根据野史记载，Brendan Eich 用了一周的时间创造了今天的 JavaScript，当 Brendan Eich 在为 JavaScript 设计面向对象系统时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。而且 Brendan Eich 一开始就没有打算在 JavaScript 中加入类的概念，所以 JavaScript 是一门基于原型的语言。在原型编程的思想中，类并不是必须的，对象未必需要从类中创建而来，一个对象是通过另一个对象而得到的。\\n- 在曾探的《设计模式》中提到 JavaScript 中的原型继承会遵循以下这些原型编程的基本规则：\\n \"},{\"url\":\"/FE/website-render.html\",\"relativePath\":\"/01.前端/04. 浏览器/website-render.html\",\"frontmatter\":{\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"permalink\":\"/FE/website-render\",\"tags\":[\"基础\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"浏览器渲染流程\",\"date\":\"2019-08-01 00:00:00\",\"capture\":\"简单流程\\n\\n URL\\n- URL（_Uniform Resource Locator_），统一资源定位符，用于定位互联网上资源，俗称网址\\n- 一个基本的URL由以下几部分组成\\n  1. 协议部分（_protocol_）：常见的协议有 _http、https、ftp、file_，其中最常见的类型是 _http_，而 _https_ 则是进行加密的网络传输\\n  2. 域名部分（_domain_）：该 URL 的域名部分为 _www.aspxfans.com_。一个 URL 中，也可以使用 IP 地址作为域名使用，_www_ 也是 _http_ 的默认主机（_host_）\\n  3. 端口部分（_po\"},{\"url\":\"/basic/js.html\",\"relativePath\":\"/01.前端/01. 基础/javascript.html\",\"frontmatter\":{\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"permalink\":\"/basic/js\",\"tags\":[\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"JavaScript 基础知识\",\"date\":\"2019-05-12 00:00:00\",\"capture\":\"类型转换\\n 一个有趣的问题\\n&lt;p align=\\\"center\\\" class=\\\"p-images\\\"\\n  &lt;img src=\\\"/imgs/basis-javascript-type-change.jpg\\\" height=\\\"260\\\" /&gt;\\n&lt;/p&gt;\\n&gt; 看到了这个我亲自尝试了下，结果发现自己对 js 基础越来越陌生了，现在好好复习下吧\\n```js\\n0 == '0'; // true\\n0 == []; // true\\n'0' == []; // false\\n```\\n 为什么？\\n&gt; 为什么 '0' == [] 是 false ？&lt;br&gt;\\n&gt; 为\"},{\"url\":\"/basic/css.html\",\"relativePath\":\"/01.前端/01. 基础/css.html\",\"frontmatter\":{\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"permalink\":\"/basic/css\",\"tags\":[\"css\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"capture\":\"css 加载会造成阻塞吗\\n\\n css 加载会造成 DOM 树的阻塞嘛？\\n- 首先，_css_ 加载会阻塞 _DOM_ 树渲染，但是 _css_ 并不会阻塞 _DOM_ 树的解析\\n- 也就是说，你可以在 _css_ 加载完之前可以在 _js_ 中获取到 _DOM_ 元素，但是 _DOM_ 却是没有渲染到页面上，需要等到 _css_ 加载完毕才渲染\\n- 为什么会这样？\\n  - 在你加载 _css_ 的时候，可能会修改 _DOM_ 节点的样式，如果 _css_ 加载不阻塞 _DOM_ 树渲染的话，那么当 _css_ 加载完之后， _DOM_ 树可有又得重绘或者回流了\\n  - 所以干脆先把 _DOM_\"}],\"人生\":[{\"url\":\"/scriptures/sutra.html\",\"relativePath\":\"/04.经典摘录/空性与妙用.html\",\"frontmatter\":{\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"permalink\":\"/scriptures/sutra\",\"tags\":[\"人生\"],\"categories\":[\"经典\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"空性与妙用：从一只杯子看世界本质\",\"date\":\"2025-09-23 00:00:00\",\"capture\":\"金刚经的那句话\\n\\n&gt;\\n&gt; 虚妄不是说不存在，而是说太唯心。\\n---\\n&gt; 举个例子：  \\n&gt; 你面前有一个杯子——\\n&gt; - 你喝水，它就是 水杯；\\n&gt; - 你抽烟，它就是 烟灰缸；\\n&gt; - 你插花，它就是 花瓶；\\n&gt; - 你插笔，它就是 笔筒；\\n&gt; - 你愤怒时，它就是 一地的玻璃渣。\\n---\\n&gt; 杯子本身，其实它什么也不是，这叫 空性。\\n&gt;\\n&gt; 你用它来干什么，它就是什么，这叫 妙用。\\n&gt;\\n&gt; 你非要坚持，它一定就是杯子，这叫 住相。\\n&gt;\\n&gt; 为此，你不惜和别人争论抬杠，这叫 我执。\\n&gt;\\n&g\"}],\"插件\":[{\"url\":\"/basic/vite-plugin-unique-page-chunks.html\",\"relativePath\":\"/01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.html\",\"frontmatter\":{\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"permalink\":\"/basic/vite-plugin-unique-page-chunks\",\"tags\":[\"插件\",\"Vite\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"capture\":\"问题背景\\n在某项目初上线优化代码的时候，打包后看到了类似的结果\\n```txt\\ndist/assets/index-CMe6Kk4E.js       0.63 kB │ gzip:   0.38 kB\\ndist/assets/index-DbyJIfZt.js     104.19 kB │ gzip:  40.96 kB\\ndist/assets/index-BN6vN86v.js     874.79 kB │ gzip: 282.58 kB\\ndist/assets/index-zD3tofSk.js   1,128.82 kB │ gzip: 375.52 kB\\n```\\n这些文件的名称几乎\"},{\"url\":\"/pages/9492f1.html\",\"relativePath\":\"/views/plugins/chrome.html\",\"frontmatter\":{\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"tags\":[\"插件\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/9492f1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Chrome 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"\"},{\"url\":\"/pages/118849.html\",\"relativePath\":\"/views/plugins/vscode.html\",\"frontmatter\":{\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"插件\"],\"categories\":[\"views\",\"plugins\"],\"permalink\":\"/pages/118849\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vscode 插件开发\",\"date\":\"2021-03-20 16:00:00\",\"capture\":\"vscode 插件可以做什么\\nvscode 编辑器是可以高度自定义的，使用 vscode 插件几乎可以对 vscode 编辑器进行说有形式的自定义。\\nvscode 插件开发文档，中文文档\\nvscode 插件可以实现自定义指令、快捷键、自定义菜单项、自定义跳转、自动补全、悬浮提示、新增语言支持、语法检查、语法高亮、代码格式化等\\n 如何创建插件\\n我们使用官方来生成 vscode 插件模板项目\\n```sh\\n 安装 yo 和 generator-code\\nnpm install -g yo generator-code\\n 使用脚手架创建项目\\nyo code\\n```\\n yo 介绍\\nYeoman 是一个通\"}],\"Vite\":[{\"url\":\"/basic/vite-plugin-unique-page-chunks.html\",\"relativePath\":\"/01.前端/03. 工作技巧/vite-plugin-unique-page-chunks.html\",\"frontmatter\":{\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"permalink\":\"/basic/vite-plugin-unique-page-chunks\",\"tags\":[\"插件\",\"Vite\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"优雅的解决 vite + vue3 同名组件无法区分问题\",\"date\":\"2025-09-21 00:00:00\",\"capture\":\"问题背景\\n在某项目初上线优化代码的时候，打包后看到了类似的结果\\n```txt\\ndist/assets/index-CMe6Kk4E.js       0.63 kB │ gzip:   0.38 kB\\ndist/assets/index-DbyJIfZt.js     104.19 kB │ gzip:  40.96 kB\\ndist/assets/index-BN6vN86v.js     874.79 kB │ gzip: 282.58 kB\\ndist/assets/index-zD3tofSk.js   1,128.82 kB │ gzip: 375.52 kB\\n```\\n这些文件的名称几乎\"}],\"Git\":[{\"url\":\"/git/git-2.html\",\"relativePath\":\"/03.工具/Git 相关/git-2.html\",\"frontmatter\":{\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"permalink\":\"/git/git-2\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"capture\":\"前言\\n在第一篇中，我们掌握了 Git 的基础操作和核心概念。现在让我们继续深入，探索 Git 的高级特性和实战技巧。\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-2.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n 源的管理\\n```shell\\n 查看源仓库信息\\ngit remote -v\\n 修改源仓库信息\\ngit remote set-url &lt;origin_name&gt; &lt;url&gt;\\n 添加源仓库\\ngit remote add &lt;origin_name&gt; &lt;url&gt;\\n 删除源\"},{\"url\":\"/git/git-1.html\",\"relativePath\":\"/03.工具/Git 相关/git-1.html\",\"frontmatter\":{\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"permalink\":\"/git/git-1\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"capture\":\"前言\\nGit 是目前广泛使用的分布式版本控制系统，在日常开发中经常会用到。\\n这篇文章记录了一些 Git 的基础知识和常用操作，希望能对大家有所帮助\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-1.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n Git 简介\\nGit 是一个 分布式版本控制系统，最初由 Linux 之父 Linus Torvalds 编写。它可以帮助我们跟踪代码的修改历史、多人协作开发，并在出问题时迅速回滚。\\n&gt; ✅ Git vs SVN：Git 是分布式的，每个开发者都有完整历史记录；\"},{\"url\":\"/git/git-submodules.html\",\"relativePath\":\"/03.工具/Git 相关/git-submodules.html\",\"frontmatter\":{\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"permalink\":\"/git/git-submodules\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"capture\":\"项目背景\\n因公司项目要拆成多个模块，部分模块给分公司的小伙伴开发权限一起开发，所以最终决定使用 git 子模块来拆分项目，今天来复盘下项目拆分中爬过的一些坑。有兴趣的同学可以参考源码一起阅读，附源码。\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git-submodules.svg\\\"/&gt;\\n&lt;/p&gt;\\n 子模块\\n首先来科普一下 git 子模块\\n子模块允许你将一个 git 仓库作为另一个 git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。\\n官方中举了一个例子：某个工作中的项目需要包含并使用另一个\"}],\"其他\":[{\"url\":\"/git/git-2.html\",\"relativePath\":\"/03.工具/Git 相关/git-2.html\",\"frontmatter\":{\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"permalink\":\"/git/git-2\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 进阶篇\",\"date\":\"2025-07-01 00:00:00\",\"capture\":\"前言\\n在第一篇中，我们掌握了 Git 的基础操作和核心概念。现在让我们继续深入，探索 Git 的高级特性和实战技巧。\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-2.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n 源的管理\\n```shell\\n 查看源仓库信息\\ngit remote -v\\n 修改源仓库信息\\ngit remote set-url &lt;origin_name&gt; &lt;url&gt;\\n 添加源仓库\\ngit remote add &lt;origin_name&gt; &lt;url&gt;\\n 删除源\"},{\"url\":\"/git/git-1.html\",\"relativePath\":\"/03.工具/Git 相关/git-1.html\",\"frontmatter\":{\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"permalink\":\"/git/git-1\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 基础篇\",\"date\":\"2025-06-25 00:00:00\",\"capture\":\"前言\\nGit 是目前广泛使用的分布式版本控制系统，在日常开发中经常会用到。\\n这篇文章记录了一些 Git 的基础知识和常用操作，希望能对大家有所帮助\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git/git-1.svg\\\" alt=\\\"文章导览\\\" /&gt;\\n&lt;/p&gt;\\n Git 简介\\nGit 是一个 分布式版本控制系统，最初由 Linux 之父 Linus Torvalds 编写。它可以帮助我们跟踪代码的修改历史、多人协作开发，并在出问题时迅速回滚。\\n&gt; ✅ Git vs SVN：Git 是分布式的，每个开发者都有完整历史记录；\"},{\"url\":\"/git/git-submodules.html\",\"relativePath\":\"/03.工具/Git 相关/git-submodules.html\",\"frontmatter\":{\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"permalink\":\"/git/git-submodules\",\"tags\":[\"Git\",\"其他\"],\"categories\":[\"Git\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Git 子模块\",\"date\":\"2022-05-11 00:00:00\",\"capture\":\"项目背景\\n因公司项目要拆成多个模块，部分模块给分公司的小伙伴开发权限一起开发，所以最终决定使用 git 子模块来拆分项目，今天来复盘下项目拆分中爬过的一些坑。有兴趣的同学可以参考源码一起阅读，附源码。\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/git-submodules.svg\\\"/&gt;\\n&lt;/p&gt;\\n 子模块\\n首先来科普一下 git 子模块\\n子模块允许你将一个 git 仓库作为另一个 git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。\\n官方中举了一个例子：某个工作中的项目需要包含并使用另一个\"},{\"url\":\"/service/crypto.html\",\"relativePath\":\"/02.服务端/node/crypto.html\",\"frontmatter\":{\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"permalink\":\"/service/crypto\",\"tags\":[\"其他\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"加密解密\",\"date\":\"2020-02-23 00:00:00\",\"capture\":\"crypto\\ncrypto 是 node 中实现加密解密的模块，使用 OpenSSL 类库作为内部实现加密解密的手段\\n 散列(哈希)算法\\n散列算法也叫哈希算法，用来把任意长度的输入换成固定长度的输出，常见的有 md5、sha1、sha256 等\\n散列算法好很多中，在 node 中可以使用 `crypto.getHashes()` 获取到 node 所支持的所有 hash 类型\\n 特点\\n- 相同的输入会产生相同的输出\\n- 不同的输出会产生不同的输出\\n- 任意的输入长度输出长度都是相同的\\n- 不能从输出推算输出的值（不能反解）\\n 用途\\n- 用来校验要下载的文件是否被改的\\n- 用来对数据库中保存的密\"},{\"url\":\"/service/redis.html\",\"relativePath\":\"/02.服务端/redis.html\",\"frontmatter\":{\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"permalink\":\"/service/redis\",\"tags\":[\"其他\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Redis 小记\",\"date\":\"2019-09-14 00:00:00\",\"capture\":\"安装\\n- 官网有 Linux 的详细教程，安装省略，记录一下基本配置以及基础用法\\n 简介\\n\\n- Redis 是 `ket-value` 数据库。效率快，但功能单一；\\n- 常用做集中式会话管理（部署了负载均衡的服务之后，可用作 redis 来存储 _session_，可保证 _session_ 不用换一个服务请求一次）\\n- 用作缓存服务器（Redis 读取特别快：SET 操作每秒钟 110000 次，GET 操作每秒钟 81000 次。）\\n 基本命令\\n```sh\\n   启动redis，window启动方式\\n  redis-server redis.window.conf\\n   Linux启动\\n \"},{\"url\":\"/service/proxy.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx-requisite.html\",\"frontmatter\":{\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"permalink\":\"/service/proxy\",\"tags\":[\"其他\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"反向代理与负载均衡\",\"date\":\"2019-08-16 00:00:00\",\"capture\":\"反向代理与负载均衡\\n\\n&gt;\\n&gt; - 解决跨域\\n&gt; - 请求过滤\\n&gt; - 配置 gzip\\n&gt; - 负载均衡\\n&gt; - 静态资源服务器\\n 代理\\n&gt; &emsp;`代理` 是在服务器和客户端之间架设的一层服务器，代理将接受客户端的请求将它转发给服务器，然后将服务端的响应转发给客户端。不管正向代理还是反向代理，都是实现此功能。&lt;br/&gt; &gt; &emsp;说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。&lt;br/&gt; &gt; &emsp;举个例子：比如说生活中的专卖\"}],\"eslint\":[{\"url\":\"/tools/eslint.html\",\"relativePath\":\"/03.工具/Webpack 相关/lint.html\",\"frontmatter\":{\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/tools/eslint\",\"tags\":[\"eslint\",\"node\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"capture\":\"简介\\n本项目使用 express 脚手架初始化，并对其进行改造，从而实现一套完整的 eslint 工作流的 node 项目。本项目将全程使用 `pnpm` 作为包管理工具\\n本文将从以下几个方面过一遍 eslint 工作流\\n&lt;!--  --\\n&lt;p align=\\\"center\\\"&gt;\\n  &lt;img src=\\\"/imgs/eslint-process.svg\\\"/&gt;\\n&lt;/p&gt;\\n 初始化项目\\n```sh\\nnpx express-generator --view=pug express-template\\n```\\n也可以下全局下载 `express-generator`\"}],\"node\":[{\"url\":\"/tools/eslint.html\",\"relativePath\":\"/03.工具/Webpack 相关/lint.html\",\"frontmatter\":{\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/tools/eslint\",\"tags\":[\"eslint\",\"node\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"一文带你打造eslint工作流\",\"date\":\"2022-10-24 00:00:00\",\"capture\":\"简介\\n本项目使用 express 脚手架初始化，并对其进行改造，从而实现一套完整的 eslint 工作流的 node 项目。本项目将全程使用 `pnpm` 作为包管理工具\\n本文将从以下几个方面过一遍 eslint 工作流\\n&lt;!--  --\\n&lt;p align=\\\"center\\\"&gt;\\n  &lt;img src=\\\"/imgs/eslint-process.svg\\\"/&gt;\\n&lt;/p&gt;\\n 初始化项目\\n```sh\\nnpx express-generator --view=pug express-template\\n```\\n也可以下全局下载 `express-generator`\"},{\"url\":\"/basic/getport.html\",\"relativePath\":\"/01.前端/03. 工作技巧/getport.html\",\"frontmatter\":{\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"permalink\":\"/basic/getport\",\"tags\":[\"webpack\",\"node\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"capture\":\"一个问题\\n前段时间，公司项目改版登录，所有管理后台、大屏可视化或者说电脑 web 端的登录做成了一个模块统一授权登录，登录的域名是配置出来的，等他们联调完之后，我发现我本地项目跑起来后登录不了啦，找相关开发人员了解情况后才知道后端限制了 `localhost` 的访问(就离谱)\\n他们推荐前端开发人员本地安装 nginx，配置本机 hosts，用 nginx 做跳转，后端可访问域名白名单中添加有我们 hosts 中配置的域名\\n我是习惯了项目跑完后点击项目启动完成后的提示信息跳转页面进行开发(主要我不想本地配 nginx)，继续与他们交谈我了解到后端允许 127.0.0.1 进行接口访问，只需要在\"},{\"url\":\"/tools/command.html\",\"relativePath\":\"/03.工具/Npm 相关/command.html\",\"frontmatter\":{\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"permalink\":\"/tools/command\",\"tags\":[\"cli\",\"基础\",\"node\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"capture\":\"命令行\\n不管在 windows 还是 Mac、Linux 系统都会有很多命令来提供一些便捷的操作，比如在 window 中 打开 cmd 输入 `start snippingtool` 就可以打开绘图工具，cmd 里面执行的其实就是一个以 .bat 执行脚本，你也可以直接新建一个文件，然后在文件内部写入 `start snippingtool`，然后保存为 .bat 结尾的文件即可直接双击执行这个文件。在 Mac 和 Linux 中可以直接写内容，不需要后缀名，以 .sh 结尾也可以，但是 Mac 和 Linux 默认新建的脚本是没有执行权限的，需要 执行 `chmod +x 文件名` 给文件\"},{\"url\":\"/tools/npm-cli.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-cli.html\",\"frontmatter\":{\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"permalink\":\"/tools/npm-cli\",\"tags\":[\"cli\",\"node\",\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"capture\":\"思考\\n要开发一个脚手架需要捋清楚，脚手架是如何工作的？拿 `vue-cli` 来说，`vue-cli` 是将项目的模板放在 git 上面，执行 cli 命令的时候，再根据用户的交互选择不同的模板，然后经过模板引擎渲染出来生成项目。这样做将模板与脚手架分离，可以各自维护。\\n那我们先准备两套项目，一套作为自己的脚手架项目，一个作为模板\\n回想在使用 `vue-cli` 的时候，我们直接执行 `vue create projetcName` 然后进行一些交互便可以生成一个项目，生成的项目会拿到我们与用户交互的时候一些配置，会改变我们想要改变的一些文件。那我们就需要做完自己的脚手架后需要生成一个可以直接\"},{\"url\":\"/service/fs.html\",\"relativePath\":\"/02.服务端/node/fs.html\",\"frontmatter\":{\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/fs\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"fs 文件系统\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"文件操作\\n 读取文件\\n- fs 模块所有的都有同步和异步语法，异步语法直接写 api，同步写法就是 api 后紧跟 sync(同步)\\n- fs.readFile() 就是异步写法，那么同步写法就是 fs.readFilSync()\\n- 异步写法的返回值在回调函数中，同步写发直接就有返回值，这基本上也是 fs 所有模块的写法\\n```js\\nconst fs = require('fs');\\nconst path = require('path');\\nconst resolve = dir =&gt; path.join(__dirname, '..', dir);\\n// 异步写法\\nfs.readF\"},{\"url\":\"/service/process.html\",\"relativePath\":\"/02.服务端/node/process-undone.html\",\"frontmatter\":{\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"permalink\":\"/service/process\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"node\"],\"categories\":[\"node\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Process 对象\",\"date\":\"2019-06-28 00:00:00\",\"capture\":\"进程对象属性\\n| 属性       | 说明                                         |\\n|----------|--------------------------------------------|\\n| execPath | 可执行文件的绝对路径，如 `/usr/local/bin/node`         |\\n| version  | 版本号                                        |\\n| versions | 依赖库的版本号                                    |\\n| p\"}],\"webpack\":[{\"url\":\"/basic/getport.html\",\"relativePath\":\"/01.前端/03. 工作技巧/getport.html\",\"frontmatter\":{\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"permalink\":\"/basic/getport\",\"tags\":[\"webpack\",\"node\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"如何优雅的解决端口被占用\",\"date\":\"2022-04-04 00:00:00\",\"capture\":\"一个问题\\n前段时间，公司项目改版登录，所有管理后台、大屏可视化或者说电脑 web 端的登录做成了一个模块统一授权登录，登录的域名是配置出来的，等他们联调完之后，我发现我本地项目跑起来后登录不了啦，找相关开发人员了解情况后才知道后端限制了 `localhost` 的访问(就离谱)\\n他们推荐前端开发人员本地安装 nginx，配置本机 hosts，用 nginx 做跳转，后端可访问域名白名单中添加有我们 hosts 中配置的域名\\n我是习惯了项目跑完后点击项目启动完成后的提示信息跳转页面进行开发(主要我不想本地配 nginx)，继续与他们交谈我了解到后端允许 127.0.0.1 进行接口访问，只需要在\"},{\"url\":\"/tools/vue.html\",\"relativePath\":\"/03.工具/Webpack 相关/vue.html\",\"frontmatter\":{\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"permalink\":\"/tools/vue\",\"tags\":[\"webpack\",\"vue\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"capture\":\"从 0 开始搭建 vue 项目\\n&lt;!-- 第一行的东西会被作为标题来展示 --\\n`webpack` 打包部署 js 项目从以下几个方面考虑：\\n- js 的处理：转换 ES6 代码，解决浏览器兼容问题\\n- css 的处理：编译 css，自动添加前缀，抽取 css 到独立文件\\n- html 的处理：复制并压缩 html 文件\\n- dist 的清理：打包前清理源目录文件\\n- assets 的处理：静态资源处理\\n- server 的启用：development 模式下启动服务器并实时刷新\\n 一、项目结构\\n我们按照 vue-cli 的目录结构来新建一些目录，然后 webpack 做相应的配置，打开\"}],\"工作\":[{\"url\":\"/basic/tree.html\",\"relativePath\":\"/01.前端/03. 工作技巧/tree.html\",\"frontmatter\":{\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"permalink\":\"/basic/tree\",\"tags\":[\"工作\",\"算法\"],\"categories\":[\"算法\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"capture\":\"前言\\n在工作中我们经常见到用树的场景，比如说写前端页面时，每个页面就有对应的 DOM 树、CSSOM 树、渲染树等，或者开发过程中的写的级联选择器、菜单树、权限树、人员树等\\n面试的时候会被问到算法相关的知识，而刷树相关的题，是特别培养算法思维的，回溯、动规、分治算法其实都是树的问题\\n本文将汇总一些工作中常用的一些树的操作以及面试可能会问到二叉树相关的问题\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/tree.svg\\\"/&gt;\\n&lt;/p&gt;\\n 树（工作）\\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个\"},{\"url\":\"/basic/issue.html\",\"relativePath\":\"/01.前端/03. 工作技巧/02.issue.html\",\"frontmatter\":{\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"permalink\":\"/basic/issue\",\"tags\":[\"基础\",\"工作\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"工作遇到的小技巧\",\"date\":\"2019-12-14 00:00:00\",\"capture\":\"获取一个月有多少天\\n今天遇到一个需求，已知月份，得到这个月的第一天和最后一天作为查询条件查范围内的数据\\n`new Date(year, month, date, hrs, min, sec)` ， `new Date` 可以接受这些参数创建一个时间对象\\n其中当我们把 `date` 设置为 `0` 的时候，可以直接通过 `getDate()` 获取到最后一天的日期然后得到我们要的最后一天\\n```js\\nnew Date(2019, 12, 0).getDate(); // 31\\nnew Date(2018, 2, 0).getDate(); // 28\\n// 根据这个我们可以得到一个方法\\nfunc\"}],\"算法\":[{\"url\":\"/basic/tree.html\",\"relativePath\":\"/01.前端/03. 工作技巧/tree.html\",\"frontmatter\":{\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"permalink\":\"/basic/tree\",\"tags\":[\"工作\",\"算法\"],\"categories\":[\"算法\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"树在工作面试中的应用\",\"date\":\"2022-03-12 00:00:00\",\"capture\":\"前言\\n在工作中我们经常见到用树的场景，比如说写前端页面时，每个页面就有对应的 DOM 树、CSSOM 树、渲染树等，或者开发过程中的写的级联选择器、菜单树、权限树、人员树等\\n面试的时候会被问到算法相关的知识，而刷树相关的题，是特别培养算法思维的，回溯、动规、分治算法其实都是树的问题\\n本文将汇总一些工作中常用的一些树的操作以及面试可能会问到二叉树相关的问题\\n 文章导览\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"/imgs/tree.svg\\\"/&gt;\\n&lt;/p&gt;\\n 树（工作）\\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个\"}],\"Webpack\":[{\"url\":\"/tools/webpack-3.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-3.html\",\"frontmatter\":{\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-3\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 深入篇\",\"date\":\"2020-09-13 08:00:00\",\"capture\":\"介绍\\n接前两篇，这篇文章介绍一些使用 Webpack 的小技巧，以及在实际业务场景中如何自定义 Loader 和 Plugin。由于最近工作比较忙，这篇笔记写得断断续续，可能有些杂乱，后续会不断优化。\\n 小技巧：require.context\\n在开发项目时，如果需要引入很多文件，可以使用 require.context 函数创建一个文件引入的上下文。该函数接受三个参数：要搜索的目录、是否搜索子目录、匹配文件的正则表达式。\\n```js\\n// 语法如下\\nrequire.context(directory, (useSubdirectories = false), (regExp = /^\\\\.\\\\//\"},{\"url\":\"/tools/webpack-1.html\",\"relativePath\":\"/03.工具/Webpack 相关/webpack-1.html\",\"frontmatter\":{\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"tags\":[\"Webpack\"],\"categories\":[\"Webpack\"],\"permalink\":\"/tools/webpack-1\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Webpack 基础篇\",\"date\":\"2019-05-21 08:00:00\",\"capture\":\"webpack 介绍\\nWebpack 可以直接执行 webpack 命令进行打包，也可以通过手动配置实现更复杂的打包需求。配置文件为 webpack.config.js，可以导出一个对象或函数，函数接受两个参数：env（环境对象）和 argv（描述传递给 webpack 选项的 map 对象）。\\n来看一下这两个参数：\\n```js\\n  // 在 webpack.config.js 中输入以下代码\\n  module.exports = function(env, argv) {\\n    console.log(env, argv)\\n  }\\n  // 在控制台执行\\n  webpack --env=c\"}],\"vue\":[{\"url\":\"/basic/vue.html\",\"relativePath\":\"/01.前端/02. 代码实现/vue-undone.html\",\"frontmatter\":{\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"author\":\"chengyuming\",\"permalink\":\"/basic/vue\",\"private\":true,\"privateRealm\":\"common\",\"tags\":[\"vue\"],\"categories\":[\"基础\"]},\"author\":\"chengyuming\",\"title\":\"Vue 2.x 版本源码分析\",\"date\":\"2020-06-14 00:00:00\",\"capture\":\"数据劫持\\n 对象的劫持\\n2.x 版本的数据劫持是根据 Object.defineProperty 来实现的\\n```js\\nfunction observe(data) {\\n  // 不是对象直接返回\\n  if (!(typeof data === 'object' && data !== null)) return;\\n  return observer(data);\\n}\\nfunction observer(data) {\\n  if (Array.isArray(data)) {\\n    observeArray(data);\\n  } else {\\n    observeObject(data);\"},{\"url\":\"/tools/vue.html\",\"relativePath\":\"/03.工具/Webpack 相关/vue.html\",\"frontmatter\":{\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"permalink\":\"/tools/vue\",\"tags\":[\"webpack\",\"vue\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"vue 项目的配置\",\"date\":\"2019-06-13 00:00:00\",\"capture\":\"从 0 开始搭建 vue 项目\\n&lt;!-- 第一行的东西会被作为标题来展示 --\\n`webpack` 打包部署 js 项目从以下几个方面考虑：\\n- js 的处理：转换 ES6 代码，解决浏览器兼容问题\\n- css 的处理：编译 css，自动添加前缀，抽取 css 到独立文件\\n- html 的处理：复制并压缩 html 文件\\n- dist 的清理：打包前清理源目录文件\\n- assets 的处理：静态资源处理\\n- server 的启用：development 模式下启动服务器并实时刷新\\n 一、项目结构\\n我们按照 vue-cli 的目录结构来新建一些目录，然后 webpack 做相应的配置，打开\"}],\"ast\":[{\"url\":\"/FE/ast.html\",\"relativePath\":\"/01.前端/04. 浏览器/AST.html\",\"frontmatter\":{\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"author\":\"fecym\",\"permalink\":\"/FE/ast\",\"tags\":[\"ast\"],\"categories\":[\"前端\"]},\"author\":\"fecym\",\"title\":\"AST 团队分享\",\"date\":\"2020-06-05 00:00:00\",\"capture\":\"&lt;!--  背景 --\\n 什么是 AST\\n抽象语法树（`Abstract Syntax Tree`）简称 `AST`，是源代码的抽象语法结构的树状表现形式。`webpack`、`eslint` 等很多工具库的核心都是通过抽象语法书这个概念来实现对代码的检查、分析等操作。今天我为大家分享一下 JavaScript 这类解释型语言的抽象语法树的概念\\n我们常用的浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作。所以将 js 转化为抽象语法树更利于程序的分析。\\n&lt;!-- ast --&gt;\\n&lt;p align=\\\"left\\\" class=\\\"p-images\\\"&g\"}],\"cli\":[{\"url\":\"/tools/command.html\",\"relativePath\":\"/03.工具/Npm 相关/command.html\",\"frontmatter\":{\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"permalink\":\"/tools/command\",\"tags\":[\"cli\",\"基础\",\"node\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"命令行参数是怎么解析的？\",\"date\":\"2020-03-01 00:00:00\",\"capture\":\"命令行\\n不管在 windows 还是 Mac、Linux 系统都会有很多命令来提供一些便捷的操作，比如在 window 中 打开 cmd 输入 `start snippingtool` 就可以打开绘图工具，cmd 里面执行的其实就是一个以 .bat 执行脚本，你也可以直接新建一个文件，然后在文件内部写入 `start snippingtool`，然后保存为 .bat 结尾的文件即可直接双击执行这个文件。在 Mac 和 Linux 中可以直接写内容，不需要后缀名，以 .sh 结尾也可以，但是 Mac 和 Linux 默认新建的脚本是没有执行权限的，需要 执行 `chmod +x 文件名` 给文件\"},{\"url\":\"/tools/npm-cli.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-cli.html\",\"frontmatter\":{\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"permalink\":\"/tools/npm-cli\",\"tags\":[\"cli\",\"node\",\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"capture\":\"思考\\n要开发一个脚手架需要捋清楚，脚手架是如何工作的？拿 `vue-cli` 来说，`vue-cli` 是将项目的模板放在 git 上面，执行 cli 命令的时候，再根据用户的交互选择不同的模板，然后经过模板引擎渲染出来生成项目。这样做将模板与脚手架分离，可以各自维护。\\n那我们先准备两套项目，一套作为自己的脚手架项目，一个作为模板\\n回想在使用 `vue-cli` 的时候，我们直接执行 `vue create projetcName` 然后进行一些交互便可以生成一个项目，生成的项目会拿到我们与用户交互的时候一些配置，会改变我们想要改变的一些文件。那我们就需要做完自己的脚手架后需要生成一个可以直接\"}],\"http\":[{\"url\":\"/service/https.html\",\"relativePath\":\"/02.服务端/https-undone.html\",\"frontmatter\":{\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"permalink\":\"/service/https\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTPS 笔记\",\"date\":\"2020-02-27 00:00:00\",\"capture\":\"https\\n参照老左笔记进行实践\\n 准备东西\\n首先准备一台空的服务器\\n 安装的东西\\n- 安装 git、nginx\\n```sh\\nyum install git\\nyum install nginx\\n```\\n 快速获取 Let's Encrypt 免费 SSL 证书\\n执行以下脚本，域名换成自己的域名，邮箱换成自己的邮箱，然后一路同意\\n注意：执行脚本的时候一定要停掉 nginx，否则会出错\\n```sh\\ngit clone https://github.com/letsencrypt/letsencrypt\\ncd letsencrypt\\n./letsencrypt-auto certonly --sta\"},{\"url\":\"/service/http.html\",\"relativePath\":\"/02.服务端/http-undone.html\",\"frontmatter\":{\"title\":\"HTTP 笔记\",\"name\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"permalink\":\"/service/http\",\"tags\":[\"http\"],\"private\":true,\"privateRealm\":\"common\",\"categories\":[\"http\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"HTTP 笔记\",\"date\":\"2020-02-18 00:00:00\",\"capture\":\"头部\\n 通用头\\n| 首部字段名        | 说明                       |\\n| ----------------- | -------------------------- |\\n| Cache-Control     | 控制缓存行为               |\\n| Connection        | 链接的管理                 |\\n| Date              | 报文日期                   |\\n| Pragma            | 报文指令                   |\\n| Trailer   \"},{\"url\":\"/FE/jwt.html\",\"relativePath\":\"/01.前端/04. 浏览器/jwt.html\",\"frontmatter\":{\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"permalink\":\"/FE/jwt\",\"tags\":[\"http\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"常见的 HTTP 认证方式\",\"date\":\"2019-12-31 00:00:00\",\"capture\":\"还有几分钟就要跨年了，2019 即将结束，跨年夜独自一人闲来无趣，整理一下 `cookie、token` 和 `jwt` 的，记得在学校的时候我就很奇怪 `cookie` 是什么，当时老师只对我们说他就是用来存储数据的，只能存储 `4kb`，超过 `4kb` 之后就会开始删除之前的 `cookie` 值，不同浏览器删除的行为是不一样的。然后就没了。直到后来参加工作了，刚入公司没多久一次接触到了 `cookie` 让我一脸懵逼（当时带我的大佬有事回家了），项目出了 bug 因为 `cookie` 传递的不对，后台解析不了，然后我折腾了一晚上（回想当初小白的时候是真的有趣）。\\n今天来记录下工作这么\"}],\"Linux\":[{\"url\":\"/service/linux.html\",\"relativePath\":\"/02.服务端/01.linux.html\",\"frontmatter\":{\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"permalink\":\"/service/linux\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Linux 常用命令\",\"date\":\"2020-01-27 00:00:00\",\"capture\":\"这篇文章涵盖了Linux系统中常见目录、文件管理、搜索、压缩解压等内容。我对其进行了语言优化和排版调整，以提高可读性和流畅性。\\n 常见目录\\n在 `Linux` 中一切皆文件\\n| 目录      | 作用                                                                                 |\\n| --------- | ------------------------------------------------------------------------------------ |\\n| /         | 根\"},{\"url\":\"/service/vmware.html\",\"relativePath\":\"/02.服务端/vmware-undone.html\",\"frontmatter\":{\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"permalink\":\"/service/vmware\",\"tags\":[\"Linux\"],\"categories\":[\"Linux\"],\"private\":true,\"privateRealm\":\"common\"},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"虚拟机 日记\",\"date\":\"2020-01-26 00:00:00\",\"capture\":\"&lt;!-- 虽然都 0202 年了，现在都不流行装系统了，但是作为一个开发，经常与电脑打交道还是需要会装系统的。曾几何时，我们用 xp 系统的时候安装 --\\n 系统启动\\n计算机通电后，第一件事情就是读取输入 ROM 芯片的开机程序，这个程序叫做基本输入输出系统 `BIOS`（Basic Input/Output System）\\n`BIOS` 程序首先检查计算机硬件是否满足运行的基本条件，这个叫做硬件自检（Power-On Self-Test）\\n如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止，如果没有问题，屏幕会显示出 CPU、内存、硬盘等信息\\n硬件自检完成后，BIOS 会把控制权交给\"},{\"url\":\"/service/conf.html\",\"relativePath\":\"/02.服务端/service-conf.html\",\"frontmatter\":{\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"permalink\":\"/service/conf\",\"tags\":[\"Linux\"],\"categories\":[\"Service\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次购买服务器\",\"date\":\"2019-11-06 00:00:00\",\"capture\":\"安装 nginx\\n&gt; 买了服务器，肯定先到控制台把服务器激活，然后重置登录密码，启动服务，然后怎么访问呢，那就先装个服务器呗，我选了 `nginx`，`nginx` 做内网转发还是挺不错的，现在也特别火，毕竟是轻量级的服务器。`nginx` 有什么好处我就不多说了，可以看看这篇文章讲解的很不错了\\n 安装前检查\\n- 安装 `nginx` 有两种方法，一种是源码包安装一种是 `yum` 安装，`yum` 安装可能不是最新版本的，这里我们选择了`源码包`安装\\n- 首先由于 `nginx` 的一些模块依赖一些 `lib` 库，所以在安装 `nginx` 之前，必须先安装这些 `lib` 库，这些\"}],\"npm\":[{\"url\":\"/tools/npm-cli.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-cli.html\",\"frontmatter\":{\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"permalink\":\"/tools/npm-cli\",\"tags\":[\"cli\",\"node\",\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"记一次开发自己的 cli\",\"date\":\"2019-12-12 00:00:00\",\"capture\":\"思考\\n要开发一个脚手架需要捋清楚，脚手架是如何工作的？拿 `vue-cli` 来说，`vue-cli` 是将项目的模板放在 git 上面，执行 cli 命令的时候，再根据用户的交互选择不同的模板，然后经过模板引擎渲染出来生成项目。这样做将模板与脚手架分离，可以各自维护。\\n那我们先准备两套项目，一套作为自己的脚手架项目，一个作为模板\\n回想在使用 `vue-cli` 的时候，我们直接执行 `vue create projetcName` 然后进行一些交互便可以生成一个项目，生成的项目会拿到我们与用户交互的时候一些配置，会改变我们想要改变的一些文件。那我们就需要做完自己的脚手架后需要生成一个可以直接\"},{\"url\":\"/tools/npm-init.html\",\"relativePath\":\"/03.工具/Npm 相关/npm-init.html\",\"frontmatter\":{\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"permalink\":\"/tools/npm-init\",\"tags\":[\"npm\"],\"categories\":[\"npm\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"你应该了解的 npm 知识\",\"date\":\"2019-12-09 00:00:00\",\"capture\":\"npm init\\n初始化一个项目的时候，我们会在控制台输入 `npm init` 执行该命令后终端会依次询问 `name, version, description` 等字段，最后会为你生成一个 `package.json` 文件\\n如果想偷懒省去一路回车，可以在命令后面加 `--yes` 或者 `-y` 参数，这样会快速生成一个 `package.json` 文件\\n```sh\\n  npm init -y\\n```\\n这样生成出来的 `package.json` 是默认的配置，如果想要改变其默认配置怎么办？\\n 修改 npm 配置\\n初始化 `package.json` 时的字段默认值是可以自己配置的，\"}],\"可视化\":[{\"url\":\"/basic/mapbox.html\",\"relativePath\":\"/01.前端/03. 工作技巧/mapbox.html\",\"frontmatter\":{\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"permalink\":\"/basic/mapbox\",\"tags\":[\"可视化\"],\"categories\":[\"前端\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Mapbox 基本使用\",\"date\":\"2019-08-24 00:00:00\",\"capture\":\"底图渲染\\n- 初次渲染地图很简单，按照官网的配置\\n- 我们需要一个地图渲染容器，需要用到 mapbox-gl 库，有时候你可能需要准备一个开发者 token，那我们开始吧\\n- 首先我们实例化一个 Map 类，在 mapbox-gl 里面有个 Map 类，该类接受一个 options 配置对象作为初始化地图的条件\\n```js\\nimport mapboxgl from 'mapbox-gl';\\nconst options = {\\n  container: '底图容器',\\n  style: '您的底图json',\\n  // 经度越大越靠左，纬度越大越靠下\\n  center: [108.5, 38],\"}],\"MySQL\":[{\"url\":\"/service/mysql.html\",\"relativePath\":\"/02.服务端/02.mysql.html\",\"frontmatter\":{\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"permalink\":\"/service/mysql\",\"tags\":[\"MySQL\"],\"categories\":[\"MySQL\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"MySQL 常用操作\",\"date\":\"2019-07-23 00:00:00\",\"capture\":\"数据库操作\\n\\n 基本操作\\n```sql\\n  -- 创建数据库\\n  CREATE database_name;\\n  -- 查看数据库信息\\n  SHOW CREATE DATABASE database_name;\\n  -- 设置为 utf-8 格式的\\n  SET names utf8;\\n  -- 查看数据库\\n  SHOW DATABASES;\\n  -- 使用数据库，use 数据库名\\n  USE database_name;\\n  -- 创建表\\n  CREATE TABLE table_name (\\n    id    int(10),\\n    name  varchar(20),\\n    age \"}],\"Nginx\":[{\"url\":\"/service/nginx.html\",\"relativePath\":\"/02.服务端/Nginx 相关/nginx.html\",\"frontmatter\":{\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"permalink\":\"/service/nginx\",\"tags\":[\"Nginx\"],\"categories\":[\"Nginx\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"Nginx 常用配置\",\"date\":\"2019-07-10 00:00:00\",\"capture\":\"安装\\n- 安装就暂时略过了，记录一下配置\\n 常用命令\\n- 做了软链接或者配置了 nginx 的环境变量可以用以下语法，没有话就需要指定到 nginx 所在的目录\\n- nginx -s stop 停止 nginx\\n- nginx -s quit 退出 nginx\\n- nginx -s reload 重新加载配置（修改配置文件后）\\n- nginx -s reopen 重启 nginx\\n- nginx -v 查看版本\\n- nginx -t 查看配置文件目录，检测配置文件是否有语法错误，然后退出\\n nginx.conf 配置文件\\nNginx 配置文件主要分成四部分：main（全局设置）、server（\"}],\"css\":[{\"url\":\"/basic/css.html\",\"relativePath\":\"/01.前端/01. 基础/css.html\",\"frontmatter\":{\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"permalink\":\"/basic/css\",\"tags\":[\"css\",\"基础\"],\"categories\":[\"基础\"]},\"author\":{\"name\":\"fecym\",\"link\":\"https://github.com/fecym\"},\"title\":\"CSS 基础知识\",\"date\":\"2019-05-01 00:00:00\",\"capture\":\"css 加载会造成阻塞吗\\n\\n css 加载会造成 DOM 树的阻塞嘛？\\n- 首先，_css_ 加载会阻塞 _DOM_ 树渲染，但是 _css_ 并不会阻塞 _DOM_ 树的解析\\n- 也就是说，你可以在 _css_ 加载完之前可以在 _js_ 中获取到 _DOM_ 元素，但是 _DOM_ 却是没有渲染到页面上，需要等到 _css_ 加载完毕才渲染\\n- 为什么会这样？\\n  - 在你加载 _css_ 的时候，可能会修改 _DOM_ 节点的样式，如果 _css_ 加载不阻塞 _DOM_ 树渲染的话，那么当 _css_ 加载完之后， _DOM_ 树可有又得重绘或者回流了\\n  - 所以干脆先把 _DOM_\"}]}},\"groupCards\":{\"categories\":[{\"name\":\"基础\",\"length\":13},{\"name\":\"经典\",\"length\":1},{\"name\":\"前端\",\"length\":7},{\"name\":\"Git\",\"length\":3},{\"name\":\"算法\",\"length\":1},{\"name\":\"views\",\"length\":2},{\"name\":\"plugins\",\"length\":2},{\"name\":\"Webpack\",\"length\":3},{\"name\":\"http\",\"length\":2},{\"name\":\"node\",\"length\":3},{\"name\":\"Linux\",\"length\":2},{\"name\":\"npm\",\"length\":2},{\"name\":\"Service\",\"length\":2},{\"name\":\"Nginx\",\"length\":2},{\"name\":\"MySQL\",\"length\":1}],\"tags\":[{\"name\":\"基础\",\"length\":13},{\"name\":\"人生\",\"length\":1},{\"name\":\"插件\",\"length\":3},{\"name\":\"Vite\",\"length\":1},{\"name\":\"Git\",\"length\":3},{\"name\":\"其他\",\"length\":6},{\"name\":\"eslint\",\"length\":1},{\"name\":\"node\",\"length\":6},{\"name\":\"webpack\",\"length\":2},{\"name\":\"工作\",\"length\":2},{\"name\":\"算法\",\"length\":1},{\"name\":\"Webpack\",\"length\":2},{\"name\":\"vue\",\"length\":2},{\"name\":\"ast\",\"length\":1},{\"name\":\"cli\",\"length\":2},{\"name\":\"http\",\"length\":3},{\"name\":\"Linux\",\"length\":3},{\"name\":\"npm\",\"length\":2},{\"name\":\"可视化\",\"length\":1},{\"name\":\"MySQL\",\"length\":1},{\"name\":\"Nginx\",\"length\":1},{\"name\":\"css\",\"length\":1}]}}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}"));