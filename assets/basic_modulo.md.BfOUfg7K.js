import{_ as i,c as a,o as n,aM as l}from"./chunks/framework.GYo0AZhN.js";const g=JSON.parse('{"title":"聊聊编程里的“魔法棒”：取余运算（Modulo）","description":"","frontmatter":{"title":"聊聊编程里的“魔法棒”：取余运算（Modulo）","date":"2026-02-11T00:00:00.000Z","permalink":"/basic/modulo","tags":["基础"],"categories":["基础"]},"headers":[],"relativePath":"basic/modulo.md","filePath":"01.前端/03. 工作技巧/01.modulo.md","lastUpdated":1770875936000}'),t={name:"basic/modulo.md"};function e(h,s,p,k,r,d){return n(),a("div",null,s[0]||(s[0]=[l(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /docs/01.前端/03. 工作技巧/01.modulo.md for this page in Markdown format</div><h1 id="聊聊编程里的-魔法棒-取余运算-modulo" tabindex="-1">聊聊编程里的“魔法棒”：取余运算（Modulo） <a class="header-anchor" href="#聊聊编程里的-魔法棒-取余运算-modulo" aria-label="Permalink to &quot;聊聊编程里的“魔法棒”：取余运算（Modulo）&quot;">​</a></h1><blockquote><p>💡 <strong>写在前面</strong>： 最近面试被问到一个倒计时相关问题，又一次用到了取余（Modulo）。说实话，刚入行那会儿，总觉得这玩意儿不就是小学数学里的<code>求余数</code> 吗？除了面试题里用来判断奇偶数，平时好像也没啥大用。</p><p>但随着代码写得越来越多，逐渐发现 <code>%</code> 符号背后其实隐藏着一种处理数据的<strong>思维模型</strong>——它能把无限延伸的线性世界，折叠成有限可控的 <strong>周期世界</strong>。今天想和大家分享一下我对取余的重新思考，看看它是怎么帮我们优雅地解决那些头疼的边界问题。</p></blockquote><h2 id="重新认识" tabindex="-1">重新认识 <code>%</code> <a class="header-anchor" href="#重新认识" aria-label="Permalink to &quot;重新认识 \`%\`&quot;">​</a></h2><p>取余的本质，是将任意数值强行<code>限定</code>在一个固定的循环范围内。无论数字跑多远，<code>% N</code> 都能让它回归到 <code>0</code> 至 <code>N-1</code> 的闭环中。</p><p>在教科书里，取余的公式是 <code>a % n = r</code></p><ul><li><code>a</code>：被除数</li><li><code>n</code>：除数</li><li><code>r</code>：余数</li></ul><p>但在代码逻辑里，我更愿意把它理解为两个超级好用的思维模型：</p><h3 id="🔄-循环" tabindex="-1">🔄 循环 <a class="header-anchor" href="#🔄-循环" aria-label="Permalink to &quot;🔄 循环&quot;">​</a></h3><p>想象一下家里的挂钟。不管时间怎么流逝，时针转了一圈又一圈，它永远只会停在 <code>1</code> 到 <code>12</code> 之间。取余就是这个<strong>表盘</strong> ，它能让无限增长的数字，乖乖地在一个固定的&quot;圈&quot;里打转。</p><h3 id="✂️-限制" tabindex="-1">✂️ 限制 <a class="header-anchor" href="#✂️-限制" aria-label="Permalink to &quot;✂️ 限制&quot;">​</a></h3><p>无论你给我的数字有多大，<code>% n</code> 就像一把剪刀，强行把多出来的部分剪掉，只保留 <code>0</code> 到 <code>n-1</code> 这一小段。</p><p>就可以理解为：</p><ul><li><code>a</code>：被除数（任意数值）</li><li><code>n</code>：除数（限定的范围大小，也就是&quot;表盘&quot;的大小）</li><li><code>r</code>：余数（结果永远在 <code>0</code> 到 <code>n-1</code> 之间）</li></ul><h2 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h2><h3 id="构建-周期闭环" tabindex="-1">构建&quot;周期闭环&quot; <a class="header-anchor" href="#构建-周期闭环" aria-label="Permalink to &quot;构建&quot;周期闭环&quot;&quot;">​</a></h3><p>说白了就是让数字一直在一个圈里转，永远跑不出去。比如轮播图或红绿灯，写 <code>if (index &gt;= length)</code> 来防止数组越界，写多了特别烦。</p><p>有了取余，这事儿就简单了：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不管 index 涨到几万，结果永远锁死在 0 到 length-1 之间</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> safeIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="降维与坐标映射" tabindex="-1">降维与坐标映射 <a class="header-anchor" href="#降维与坐标映射" aria-label="Permalink to &quot;降维与坐标映射&quot;">​</a></h3><p>这个主要解决&quot;一维变二维&quot;的问题。比如为了省流量，后端扔过来一个长长的一维数组，你需要在界面上画个九宫格。</p><p>别傻乎乎地去搞双层循环，直接用数学搞定。假设一行有 <code>col</code> 列：</p><ul><li><strong>找列号（X轴）</strong>：看它在当前行走了几步 -&gt; <strong>取余</strong> (<code>% col</code>)</li><li><strong>找行号（Y轴）</strong>：看它已经填满了几行 -&gt; <strong>整除</strong> (<code>Math.floor(i / col)</code>)</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设数组索引 i=7，一行3个 (col=3)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1 （第2列）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2 （第3行）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 坐标就是 (1, 2)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="均匀离散与分流" tabindex="-1">均匀离散与分流 <a class="header-anchor" href="#均匀离散与分流" aria-label="Permalink to &quot;均匀离散与分流&quot;">​</a></h3><p>一大堆随机数据（比如 1000 万个用户 ID），把它们公平地分给 3 台服务器，怎么分最匀称？</p><p>别搞什么复杂的随机算法，直接按 ID 取余。这不仅分得匀，还能保证同一个用户每次都能分到同一台机器上（这在分布式里叫 Hash 一致性）。</p><ul><li><strong>数字 ID</strong>：直接取余。</li><li><strong>字符串 ID</strong>：先算 Hash 值（转成数字），再取余。</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 简单又高效的负载均衡</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> targetServer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> servers[userId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果是字符串 ID，就先转成数字（Hash）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// const hash = stringToNumber(userId); </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// const targetServer = servers[hash % 3];</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="声明式逻辑" tabindex="-1">声明式逻辑 <a class="header-anchor" href="#声明式逻辑" aria-label="Permalink to &quot;声明式逻辑&quot;">​</a></h3><p>代码是写给人看的。<code>if-else</code> 是告诉机器&quot;怎么做流程控制&quot;，而 <code>%</code> 是告诉人&quot;这里是个循环&quot;。</p><p>用 <code>%</code> 最大的好处就是——你再也不会把 <code>&gt;</code> 误写成 <code>&gt;=</code> 了。那种差 1 的 Bug（Off-by-one error），写过代码的都懂有多坑。</p><h3 id="倍数与规律捕捉" tabindex="-1">倍数与规律捕捉 <a class="header-anchor" href="#倍数与规律捕捉" aria-label="Permalink to &quot;倍数与规律捕捉&quot;">​</a></h3><p>想每隔 10 行打个日志？或者给表格弄个&quot;斑马纹&quot;（奇偶变色）？</p><p>这种&quot;每隔 N 次搞点事情&quot;的逻辑，用取余是最直观的。它就像个节拍器，到了那个点就会响。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 经典的斑马纹逻辑</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> color</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;white&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;gray&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="常见的面试题-由简到难" tabindex="-1">常见的面试题（由简到难） <a class="header-anchor" href="#常见的面试题-由简到难" aria-label="Permalink to &quot;常见的面试题（由简到难）&quot;">​</a></h2><h3 id="_1-秒转时分秒-倒计时" tabindex="-1">1. 秒转时分秒（倒计时） <a class="header-anchor" href="#_1-秒转时分秒-倒计时" aria-label="Permalink to &quot;1. 秒转时分秒（倒计时）&quot;">​</a></h3><p><strong>问</strong>：给你一个总秒数 <code>3661</code>，怎么在页面上显示 <code>01:01:01</code>？</p><p><strong>答</strong>：这是最基础的&quot;进制转换&quot;题。</p><ul><li><strong>低位（秒）</strong>：总秒数对 60 取余 -&gt; 剩下的零头就是秒。</li><li><strong>中位（分）</strong>：总秒数先除以 60 得到总分钟数，再对 60 取余 -&gt; 剩下的零头就是分。</li><li><strong>高位（时）</strong>：总分钟数除以 60 -&gt; 剩下的就是时。</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> totalSeconds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3661</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> seconds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> totalSeconds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;            </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> minutes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(totalSeconds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 61 % 60 = 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> hours</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(totalSeconds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3600</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> format</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> time</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> time.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">padStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;0&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\${</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">format</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hours</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}:\${</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">format</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">minutes</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}:\${</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">format</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">seconds</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 01:01:01</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_2-判断质数-prime-number" tabindex="-1">2. 判断质数（Prime Number） <a class="header-anchor" href="#_2-判断质数-prime-number" aria-label="Permalink to &quot;2. 判断质数（Prime Number）&quot;">​</a></h3><p><strong>问</strong>：怎么判断一个数 <code>n</code> 是不是质数？</p><p><strong>答</strong>：质数就是只能被 1 和它自己整除的数。</p><p>所以，拿 2 到 n-1 之间的所有数去试着除它。只要有一个能被整除（<code>n % i === 0</code>），它就不是质数。</p><p><strong>优化点</strong>：其实只需要试到 <code>Math.sqrt(n)</code> 就够了，后面都是重复的。</p><blockquote><p><strong>为什么？</strong> 因子都是成对出现的。比如 <code>36</code>：</p><ul><li><code>2 × 18</code></li><li><code>3 × 12</code></li><li><code>4 × 9</code></li><li><code>6 × 6</code> (根号 n)</li><li><code>9 × 4</code> (重复了！)</li></ul><p>只要在 <code>6</code> (根号 n) 之前没找到因子，后面也绝不会有（除非是它自己）。同理 <code>100</code> 的根号是 <code>10</code>，你只要试到 <code>10</code> 就行了，不用傻乎乎试到 <code>99</code>。</p></blockquote><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isPrime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2 是质数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 偶数直接排除</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 只需要试除奇数，步长为 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sqrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n); i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_3-判断回文数-不转字符串" tabindex="-1">3. 判断回文数（不转字符串） <a class="header-anchor" href="#_3-判断回文数-不转字符串" aria-label="Permalink to &quot;3. 判断回文数（不转字符串）&quot;">​</a></h3><p><strong>问</strong>：给你个数字 <code>12321</code>，怎么判断它是回文？不许转成 String。</p><p><strong>答</strong>：这题考的是数字拆解的基本功。</p><p>你需要理解 <code>%</code> 和 <code>/</code> 在十进制里的<strong>黄金搭档</strong>关系：</p><ul><li><b><code>% 10</code> 是&quot;拿&quot;</b>：拿到个位数（剥洋葱的第一层）。</li><li><b><code>/ 10</code> 是&quot;扔&quot;</b>：扔掉个位数（把洋葱缩小一圈）。</li></ul><p><strong>一边拆，一边装</strong>： 把 <code>x</code> 的屁股（最后一位）拆下来，装到 <code>reversed</code> 的头上。如果装完发现 <code>reversed === x</code>，那就是回文。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 12321</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, reversed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设 x=123</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第一轮：123 % 10 = 3 (拿3), 123 / 10 = 12 (剩12)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第二轮：12 % 10 = 2 (拿2), 12 / 10 = 1 (剩1)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第三轮：1 % 10 = 1 (拿1), 1 / 10 = 0 (剩0) -&gt; 结束</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  reversed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reversed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 拼到新数末尾</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);            </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 原数去掉末尾</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_4-负数取余的坑-js-vs-其他语言" tabindex="-1">4. 负数取余的坑（JS vs 其他语言） <a class="header-anchor" href="#_4-负数取余的坑-js-vs-其他语言" aria-label="Permalink to &quot;4. 负数取余的坑（JS vs 其他语言）&quot;">​</a></h3><p><strong>问</strong>：<code>(-1) % 5</code> 在 JS 里等于多少？在 Python 里呢？</p><p><strong>答</strong>：这题特容易踩坑。</p><ul><li>在 JS（C/Java）里，结果是 <code>-1</code>。因为它们看重&quot;商&quot;向 0 取整。</li><li>在 Python 里，结果是 <code>4</code>。因为 Python 看重&quot;商&quot;向下取整。</li></ul><p><strong>实战解法</strong>：</p><p>如果在 JS 做轮播图（点击上一张），算出 <code>-1</code> 程序就崩了。</p><p>记住这个<strong>万能公式</strong>，不管正负都能转正：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> step </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>为什么加 <code>length</code>？</strong></p><p>因为 <code>%</code> 运算在 JS 里会保留符号。假设当前是第 0 张图（current=0），你要退一张（step=-1），总共5张图（length=5）。</p><ul><li><strong>不加 length</strong>：<code>(0 + (-1)) % 5 = -1</code> ❌（不仅不对，还越界了）</li><li><strong>加 length</strong>：<code>(0 + (-1) + 5) % 5 = 4</code> ✅（这就对了，回到了最后一个）</li><li><strong>正向移动</strong>：<code>(0 + 1 + 5) % 5 = 1</code> ✅（加一圈不影响正数结果，没副作用）</li></ul><p><strong>场景举例</strong>：</p><ol><li><b>轮播图&quot;上一张&quot;</b>：<code>current=0, step=-1</code>。<code>(0 - 1 + 5) % 5 = 4</code> -&gt; 完美跳到最后一张。</li><li><strong>贪吃蛇穿墙</strong>：蛇头钻出左边界 <code>x=-1</code>。<code>(-1 + width) % width</code> -&gt; 瞬间从右边出来。</li><li><strong>日期计算</strong>：今天是周三 <code>3</code>，问 5 天前是周几？<code>(3 - 5 + 7) % 7 = 5</code> -&gt; 周五。不用脑补倒着数数了。</li></ol><h3 id="_5-不用临时变量交换两个数" tabindex="-1">5. 不用临时变量交换两个数 <a class="header-anchor" href="#_5-不用临时变量交换两个数" aria-label="Permalink to &quot;5. 不用临时变量交换两个数&quot;">​</a></h3><p><strong>问</strong>：给你两个整数 a 和 b，不许用 <code>temp</code> 变量，怎么交换它们？</p><p><strong>答</strong>：除了烂大街的位运算（异或），取余其实也能干这事儿（虽然不如位运算快，但思路很骚）。</p><p>思路是把两个数&quot;压缩&quot;到一个大数里，再拆出来。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 456</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设 n 足够大，比 a 和 b 都大</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 压缩：把 b 藏在高位，a 藏在低位</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 123 + 456 * 1000 = 456123</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n;        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 取出低位，也就是原来的 a </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 取出高位，也就是原来的 b</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 456, 123</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_6-约瑟夫环问题" tabindex="-1">6. 约瑟夫环问题 <a class="header-anchor" href="#_6-约瑟夫环问题" aria-label="Permalink to &quot;6. 约瑟夫环问题&quot;">​</a></h3><p><strong>场景描述</strong>： 有 <code>n</code> 个人围成一圈（编号 0 到 n-1）。从第 0 号开始报数，报到 <code>m</code> 的人出局。下一位继续从 1 开始报数，直到只剩最后一个人。问最后这个人的原始编号是多少？</p><p><strong>例子</strong>：</p><ul><li><strong>n = 5</strong>（5个人：0, 1, 2, 3, 4）</li><li><strong>m = 3</strong>（报到3出局）</li><li><strong>出局过程</strong>：2号出局 -&gt; 0号出局 -&gt; 4号出局 -&gt; 1号出局 -&gt; <strong>3号幸存</strong>。</li><li><strong>幸存过程</strong>：0, 1, 2, 3, 4 -&gt; 0, 1, 3, 4 -&gt; 1, 3, 4 -&gt; 1, 3 -&gt; 3</li></ul><p>这道题有点复杂，先上答案，后面咱们掰开揉碎了讲</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 总人数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 报数号码（报到几出局）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 最后幸存者的编号</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lastRemaining</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 时光倒流终点：最后只剩1个人时，幸存者索引是0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 开始倒推：从2个人 -&gt; 3个人 -&gt; ... -&gt; n个人</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 每一轮人数变多(i)，位置都要往后挪 m 位</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pos;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>解法思路：时光倒流（坐标偏移）</strong></p><p>这个问题如果顺着想（模拟淘汰），数组删元素很麻烦。但如果我们<strong>倒着想</strong>，利用<strong>坐标偏移</strong>规律，就非常简单。</p><p><strong>1. 正向（淘汰 = 坐标前移）：</strong> 想象一下，<code>m=3</code>，第 3 个人（索引 2）被淘汰后。</p><ul><li>按照规则，<strong>下一轮报数从被淘汰者的下一个人（索引 3）开始</strong>。</li><li>这就意味着，<strong>索引 3</strong> 变成了新一轮的 <strong>排头兵（新的索引 0）</strong>。</li><li>相当于所有人整体<strong>往前挪了 3 位</strong>（注意：不仅仅是填补空缺，而是连起点都变了）。</li><li>即：<code>旧索引 - 3 = 新索引</code>。</li></ul><p><strong>2. 逆向（恢复 = 坐标后移）：</strong> 我们要找幸存者最初在哪，可以从<strong>终局</strong>（只剩他 1 人，索引 0）开始，一步步把时光倒流，恢复之前被淘汰的人。</p><ul><li><strong>恢复就是淘汰的逆操作</strong>。</li><li>既然淘汰是&quot;往前挪 3 位&quot;，那恢复就是<b>&quot;往后挪 3 位&quot;</b>（<code>+3</code>）。</li><li>公式呼之欲出：<code>新索引 + 3 = 旧索引</code>。</li><li><strong>核心补丁</strong>：因为是圆圈，往后挪超出了队尾就要绕回队头，所以必须 <code>% 上轮人数</code>。</li></ul><p><strong>推导过程演示（N=5, M=3）</strong>：</p><p>我们只关注<strong>最后那个幸存者</strong>（假设他叫&quot;天选之子&quot;），他在每一轮的索引是多少？</p><blockquote><p><strong>表头说明</strong>：</p><ul><li><strong>n</strong>：当前轮剩余人数。</li><li><strong>倒推公式</strong>：<code>(当前索引 + m) % 上轮人数</code>。通过这个公式，我们可以算出幸存者在上一轮（人数更多时）的位置。</li></ul></blockquote><table tabindex="0"><thead><tr><th style="text-align:left;">轮次</th><th style="text-align:left;">剩余人数</th><th style="text-align:left;">场景描述</th><th style="text-align:left;">计算过程</th><th style="text-align:left;">幸存者索引</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>终局</strong></td><td style="text-align:left;">1</td><td style="text-align:left;">只剩天选之子</td><td style="text-align:left;">0 (固定)</td><td style="text-align:left;"><strong>0</strong></td></tr><tr><td style="text-align:left;"><strong>倒数第2轮</strong></td><td style="text-align:left;">2</td><td style="text-align:left;">恢复成2人</td><td style="text-align:left;"><code>(0 + 3) % 2</code></td><td style="text-align:left;"><strong>1</strong></td></tr><tr><td style="text-align:left;"><strong>倒数第3轮</strong></td><td style="text-align:left;">3</td><td style="text-align:left;">恢复成3人</td><td style="text-align:left;"><code>(1 + 3) % 3</code></td><td style="text-align:left;"><strong>1</strong></td></tr><tr><td style="text-align:left;"><strong>倒数第4轮</strong></td><td style="text-align:left;">4</td><td style="text-align:left;">恢复成4人</td><td style="text-align:left;"><code>(1 + 3) % 4</code></td><td style="text-align:left;"><strong>0</strong></td></tr><tr><td style="text-align:left;"><strong>开局</strong></td><td style="text-align:left;">5</td><td style="text-align:left;">恢复成5人</td><td style="text-align:left;"><code>(0 + 3) % 5</code></td><td style="text-align:left;"><strong>3</strong></td></tr></tbody></table><p><strong>结论</strong>：一开始索引为 <strong>3</strong> 的那个人，就是天选之子。</p><p><strong>💡 核心疑点 Q&amp;A</strong>：</p><ol><li><p><strong>为什么要倒推？</strong></p><ul><li><strong>正推太麻烦</strong>：如果正向模拟，你需要不断地删除数组元素、处理索引越界，数组长度一直在变，计算极其复杂。</li><li><strong>终局是已知的</strong>：无论过程多复杂，<strong>最后一定只剩 1 个人</strong>，且那个人的索引一定是 <code>0</code>。从确定的结果出发找源头，比从源头去猜结果要容易得多。</li></ul></li><li><p><strong>为什么要恢复上一轮的状态？</strong></p><ul><li>这是一个<strong>递归/递推</strong>的问题。<code>5个人</code> 的游戏淘汰一个，就变成了 <code>4个人</code> 的游戏。</li><li>如果我们知道 <code>4个人</code> 里的幸存者是谁，只要把这个幸存者在 <code>4个人</code> 局里的位置，<strong>映射（还原）</strong> 回 <code>5个人</code> 局里的位置，问题就解决了。</li><li>所谓&quot;恢复&quot;，其实就是<strong>坐标变换</strong>。</li></ul></li><li><p><strong>为什么要 % i（当前人数），而不是 % n（总人数）？</strong></p><ul><li>这是很多人的盲点！</li><li>每一轮淘汰一个人，<strong>圈子的大小都在变</strong>。</li><li>倒数第 2 轮时，圈子只有 2 个人，所以是 <code>% 2</code>；倒数第 3 轮时，圈子有 3 个人，所以是 <code>% 3</code>。</li><li>我们是在<strong>那一轮的圈子</strong>里进行坐标恢复，当然要模<strong>那一轮的人数</strong>。</li></ul></li><li><p><strong>公式 <code>(当前索引 + m) % 上轮人数</code> 怎么来的？</strong></p><ul><li>这就是我们上面提到的<strong>坐标偏移</strong>：</li><li><strong>+ m</strong>：代表时光倒流，恢复被删掉的 <code>m</code> 个位置。</li><li><strong>% 上轮人数</strong>：代表在恢复后的圈子里转圈圈，防止索引越界。</li></ul></li></ol><p><strong>💡 小贴士：数学公式版（递归实现）</strong></p><p>如果你在算法书上看到这个公式，别慌，它和我们的代码是一回事：</p><p><code>f(n, m) = (f(n-1, m) + m) % n</code></p><ul><li><code>f(n, m)</code>：n 个人时幸存者的索引。</li><li><code>f(n-1, m)</code>：n-1 个人时幸存者的索引（也就是我们代码里的 <code>pos</code>）。</li><li>代码里的 <code>for</code> 循环，就是把这个数学递归公式变成了<strong>从 2 到 n 的递推</strong>。</li></ul><p><strong>递归版代码（仅供参考）</strong>：</p><p>虽然代码看着短，但如果 n 很大，会爆栈哦。还是推荐用上面的 <code>for</code> 循环（迭代版）。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lastRemainingRecursive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 剩下1个人，索引肯定是0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lastRemainingRecursive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, m) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>动态规划版（标准 DP）</strong>：</p><p>有了推导公式，自然就能写出 DP。</p><p><code>dp[i]</code> 表示 <code>i</code> 个人时的幸存者索引。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lastRemainingDP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dp[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只有1个人时，索引是0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dp[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (dp[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 状态转移方程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[n];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><em>注：我们最开始写的那个 <code>let pos</code> 的版本，其实就是这个 DP 版本的<strong>空间优化版</strong>（滚动数组思想），把 <code>dp</code> 数组压缩成了一个变量。</em></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>说实话，取余（Modulo）这个概念，以前我也觉得它只是个数学符号，顶多用来算算奇偶数。但当你真的深入去理解它，你会发现它其实是一种<code>化直为曲</code> 的思维方式。</p><p>无论是处理时间、轮播图，还是解决像约瑟夫环这样复杂的算法题，取余的核心永远只有两点：<strong>控制边界</strong>和<strong>制造循环</strong>。</p><p>希望这篇文章能帮你打破对 <code>%</code> 的固有印象。下次在代码里遇到&quot;溢出&quot;、&quot;循环&quot;或者&quot;映射&quot;的问题时，试着停下来想一想：这里是不是可以用取余来简化一下？</p><p>多思考，多动手，编程不仅是写代码，更是对数据规律的优雅掌控。</p>`,110)]))}const E=i(t,[["render",e]]);export{g as __pageData,E as default};
